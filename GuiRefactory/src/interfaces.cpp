#include "interfaces.h"

#include "imgpng.h"
#include "imgjpg.h"
#include "imgtga.h"

///////////////////////////////////////////////
///////////////////////////////////////////////
/////////////////////globals///////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

Ide*										globalIdeInstance=0;
GuiFont*									globalDefaultFont=0;
std::vector<GuiFont*>						globalFontPool;
GuiSceneViewer*								globalGuiSceneViewer=0;
GuiProjectViewer*							globalGuiProjectViewer=0;
GuiCompilerViewer*							globalGuiCompilerViewer=0;
GuiConsoleViewer*							globalGuiConsoleViewer=0;
std::list<GuiScriptViewer*>					globalScriptViewers;
std::list<GuiEntityViewer*>					globalEntityViewers;
std::list<GuiViewport*>						globalViewports;
ResourceNodeDir*							globalRootProjectDirectory=0;


GLOBALGETTERFUNC(GlobalGuiProjectViewerInstance,globalGuiProjectViewer,GuiProjectViewer*&);
GLOBALGETTERFUNC(GlobalGuiSceneViewerInstance,globalGuiSceneViewer,GuiSceneViewer*&);
GLOBALGETTERFUNC(GlobalGuiCompilerViewerInstance,globalGuiCompilerViewer,GuiCompilerViewer*&);
GLOBALGETTERFUNC(GlobalGuiConsoleViewerInstance,globalGuiConsoleViewer,GuiConsoleViewer*&);
GLOBALGETTERFUNC(GlobalDefaultFontInstance,globalDefaultFont,GuiFont*);
GLOBALGETTERFUNC(GlobalFontPoolInstance,globalFontPool,std::vector<GuiFont*>&);
GLOBALGETTERFUNC(GlobalIdeInstance,globalIdeInstance,Ide*&);
GLOBALGETTERFUNC(GlobalScriptViewers,globalScriptViewers,std::list<GuiScriptViewer*>&);
GLOBALGETTERFUNC(GlobalViewports,globalViewports,std::list<GuiViewport*>&);
GLOBALGETTERFUNC(GlobalRootProjectDirectory,globalRootProjectDirectory,ResourceNodeDir*&);
GLOBALGETTERFUNC(GlobalGuiEntityViewerInstance,globalEntityViewers,std::list<GuiEntityViewer*>&);

///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////SerializerHelpers///////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

namespace SerializerHelpers
{
	extern std::list<Skin*>							globalSkinsToBind;
	extern std::list< std::list<unsigned int> >		globalSkinsClusterBoneIdToBind;

	extern std::list<AnimationController*>			globalAnimationControllersToBind;
	extern std::list< std::list<unsigned int> >		globalAnimationControllersAnimationsIndicesToBind;

	extern void SetEntityId(Entity* iEntity,unsigned int& iId);
	extern Entity* GetRootEntity(Entity* iEntity);
	extern Entity* GetEntityById(Entity* iEntity,unsigned int iId);

	void			saveSceneEntityRecursively(Entity* iEntity,FILE* iFile);
	EditorEntity*	loadSceneEntityRecursively(EditorEntity* iEntity,FILE* iFile);

	void Save(Mesh*,FILE*);
	void Save(Skin*,FILE*);
	void Save(Animation*,FILE*);
	void Save(AnimationController*,FILE*);
	void Save(Skin*,FILE*);
	void Save(Line*,FILE*);
	void Save(Script*,FILE*);

	extern void Load(Mesh*,FILE*);
	extern void Load(Skin*,FILE*);
	extern void Load(Animation*,FILE*);
	extern void Load(AnimationController*,FILE*);
	extern void Load(Skin*,FILE*);
	extern void Load(Line*,FILE*);
	extern void Load(Script*,FILE*);

	void Load(EditorLine*,FILE*);

	extern void BindSkinLinks(Entity* iEntityParent);
	extern void BindAnimationLinks(Entity* iEntityParent);

	void WriteComponentCode(int,FILE*);
}

///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////ResourceNode/////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////



ResourceNode::ResourceNode():
	parent(0),
	isDir(0)
{
}

ResourceNode::~ResourceNode()
{
	this->parent=0;
	this->fileName.clear();
	this->isDir=false;
}

ResourceNodeDir::ResourceNodeDir()
{
}

ResourceNodeDir::~ResourceNodeDir()
{
	//this->directoryViewerRow.SetParent(0);

	for(std::list<ResourceNode*>::iterator tFile=this->files.begin();tFile!=this->files.end();tFile++)
		SAFEDELETE(*tFile);

	for(std::list<ResourceNodeDir*>::iterator tDir=this->dirs.begin();tDir!=this->dirs.end();tDir++)
		SAFEDELETE(*tDir);

	this->files.clear();
	this->dirs.clear();
}

String ResourceNode::BuildPath()
{
	if(!this->parent)
		return this->fileName;

	String tReturnPath=L"\\" + this->fileName;

	ResourceNode* t=this;

	while(t->parent)
	{
		tReturnPath.insert(0, !t->parent->parent ? t->parent->fileName : L"\\" + t->parent->fileName);
		t=t->parent;
	}
	 
	return tReturnPath;
}



ResourceNodeDir* ResourceNodeFindDirNode(const String& iFile,ResourceNodeDir* iNode,String &tmp)
{
	tmp+= iNode->parent ? L"\\"+iNode->fileName : iNode->fileName;

	if(tmp==iFile)
		return iNode;

	for(std::list<ResourceNodeDir*>::iterator iterDir=iNode->dirs.begin();iterDir!=iNode->dirs.end();iterDir++)
	{
		ResourceNodeDir* tResult=(*iterDir)->FindDirNode(iFile);

		if(tResult)
			return tResult;
	}

	return 0;
}

ResourceNodeDir* ResourceNodeDir::FindDirNode(String iFile)
{
	ResourceNodeDir* tRootNode=ResourceNodeDir::GetRootDirNode();

	if(tRootNode && tRootNode->fileName.size())
	{
		String tmp;
		return ResourceNodeFindDirNode(iFile,tRootNode,tmp);
	}

	return 0;
}

ResourceNode* ResourceNodeFindFileNode(const String& iFile,ResourceNodeDir* iNode,String &tmp)
{
	tmp+= iNode->parent ? L"\\"+iNode->fileName : iNode->fileName;

	if(tmp==iFile)
		return iNode;
	
	for(std::list<ResourceNode*>::iterator iterFile=iNode->files.begin();iterFile!=iNode->files.end();iterFile++)
	{
		if((tmp+L"\\"+(*iterFile)->fileName)==iFile)
			return *iterFile;
	}

	for(std::list<ResourceNodeDir*>::iterator iterDir=iNode->dirs.begin();iterDir!=iNode->dirs.end();iterDir++)
	{
		ResourceNode* tResult=ResourceNodeFindFileNode(iFile,*iterDir,tmp);

		if(tResult)
			return tResult;
	}

	return 0;
}

ResourceNode* ResourceNodeDir::FindFileNode(String iFile)
{
	ResourceNodeDir* tRootNode=ResourceNodeDir::GetRootDirNode();

	if(tRootNode && tRootNode->fileName.size())
	{
		String tmp;
		return ResourceNodeFindFileNode(iFile,tRootNode,tmp);
	}

	return 0;
}

ResourceNodeDir* ResourceNodeDir::GetRootDirNode()
{
	return GlobalRootProjectDirectory();
}

String gFindResource(String& iCurrentDirectory,String& iProjectDir,ResourceNodeDir* iResDir,String& iResourceName)
{
	//store current dir

	if(iResDir->parent)
	{
		iCurrentDirectory+=iResDir->fileName.c_str();
		iCurrentDirectory+=L"\\";
	}

	//if node contains files, process them, later process other dir nodes

	for(std::list<ResourceNode*>::iterator tResFile=iResDir->files.begin();tResFile!=iResDir->files.end();tResFile++)
	{
		String	tVirtualFileName=iCurrentDirectory + (*tResFile)->fileName;

		if(tVirtualFileName==iResourceName)
		{
			return iProjectDir + iCurrentDirectory + (*tResFile)->fileName;
		}
	}

	for(std::list<ResourceNodeDir*>::iterator tResNodeDir=iResDir->dirs.begin();tResNodeDir!=iResDir->dirs.end();tResNodeDir++)
	{
		String t=gFindResource(iCurrentDirectory,iProjectDir,*tResNodeDir,iResourceName);

		return t;
	}

	return String();
}

void* Resource::Load(FilePath iResourceName)
{
	String tRootTrailingSlashes(L"\\");

	FilePath tResourcePath=gFindResource(tRootTrailingSlashes,globalRootProjectDirectory->fileName,globalRootProjectDirectory,iResourceName);

	if(!tResourcePath.File().empty())
	{
		String tFileExtension=tResourcePath.Extension();

		if(tFileExtension==L"engineScene")
		{

		}
	}

	return 0;
}


///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////////AppInterface////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////




Ide::Ide():
	timer(0),
	mainAppWindow(0),
	compiler(0),
	processId(0),
	processThreadId(0),
	stringEditor(0),
	popup(0)
{
	globalIdeInstance=this->Instance();
}

Ide::~Ide(){}

String Ide::GetSceneExtension()
{
	return L".engineScene";
}
String Ide::GetEntityExtension()
{
	return L".engineEntity";
}

Ide* Ide::GetInstance()
{
	return GlobalIdeInstance();
}

bool Ide::IsInstanced()
{
	return GlobalIdeInstance() ? true : false;
}



GuiProjectViewer*	Ide::GetProjectViewer()
{
	return GuiProjectViewer::GetInstance();
}
GuiSceneViewer*		Ide::GetSceneViewer()
{
	return GuiSceneViewer::GetInstance();
}
GuiCompilerViewer*	Ide::GetCompilerViewer()
{
	return GuiCompilerViewer::GetInstance();
}
GuiConsoleViewer*	Ide::GetConsoleViewer()
{
	return GuiConsoleViewer::GetInstance();
}

///////////////////////////////////////////////
///////////////////////////////////////////////
///////////EditorWindowContainer///////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

Container::Container()
{
	resizeDiffHeight=0;
	resizeDiffWidth=0;
	resizeEnumType=-1;
	resizeCheckWidth=0;
	resizeCheckHeight=0;
}

Container::~Container(){}

void Container::BroadcastToTabs(void (Tab::*func)(void*),void* iData)
{
	for(std::vector<Tab*>::iterator tTab=this->tabs.begin();tTab!=this->tabs.end();tTab++)
		((*tTab)->*func)(iData);
}

void Container::BroadcastToSelectedTabRects(void (Gui::*func)(Tab*,Event*),Event* iEvent)
{
	for(std::vector<Tab*>::iterator tTabIter=this->tabs.begin();tTabIter!=this->tabs.end();tTabIter++)
	{
		Tab* tTab=*tTabIter;

		if(tTab->GetSelected())
			(tTab->GetSelected()->*func)(*tTabIter,iEvent);
	}
}


///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////////Debugger//////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////
Debugger::Debugger():breaked(false),threadSuspendend(false),runningScript(0),runningScriptFunction(0),debuggerCode(0),lastBreakedAddress(0),sleep(1){}


///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////////TouchInput//////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

TouchInput::TouchInput()
{
	for(int i=0;i<10;i++)
	{
		pressed[i]=0;
		released[i]=0;
		position[i].make(0,0);
	}
}

bool TouchInput::IsPressed(int i){return pressed[i];}
bool TouchInput::IsReleased(int i){return released[i];}

void TouchInput::SetPressed(bool b,int i){pressed[i]=b;}
void TouchInput::SetReleased(bool b,int i){released[i]=b;}


vec2& TouchInput::GetPosition(int i){return position[i];}
void   TouchInput::SetPosition(vec2& pos,int i){position[i]=pos;}

MouseInput::MouseInput()
{}

bool MouseInput::Left(){return this->left;}
bool MouseInput::Right(){return this->right;}
bool MouseInput::Middle(){return this->middle;}

TouchInput InputManager::touchInput;
MouseInput InputManager::mouseInput;
KeyboardInput InputManager::keyboardInput;

/*
InputInterface InputManager::voiceInput;
InputInterface InputManager::joystickInput;*/


///////////////////////////////////////////////
///////////////////////////////////////////////
//////////////////TabContainer/////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

namespace GuiHelpers
{
	void Broadcast(Gui* iGui,void (Gui::*func)(Tab*,Event*),Tab* iTab,Event* iData=0)
	{
		(iGui->*func)(iTab,iData);

		for(std::list<Gui*>::const_iterator it=iGui->GetChilds().begin();it!=iGui->GetChilds().end();it++)
			((*it)->*func)(iTab,iData);
	}
};


unsigned char Tab::rawUpArrow[]={0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0xa7,0x0,0x0,0x0,0xa8,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x87,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0x88,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6a,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0x6b,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4b,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0x4c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2b,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xfe,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xfe,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0x2c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xb,0x0,0x0,0x0,0xfa,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xfb,0x0,0x0,0x0,0xc,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7,0x0,0x0,0x0,0xdc,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xdc,0x0,0x0,0x0,0x7,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc,0x0,0x0,0x0,0xe7,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xe7,0x0,0x0,0x0,0xc,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0};
unsigned char Tab::rawRightArrow[]={0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc,0x0,0x0,0x0,0x7,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe7,0x0,0x0,0x0,0xdc,0x0,0x0,0x0,0xb,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xfa,0x0,0x0,0x0,0x2b,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0x4b,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xfe,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0x6a,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0x87,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xa7,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xa8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0x88,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xfe,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0x6b,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0x4c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xfb,0x0,0x0,0x0,0x2c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe7,0x0,0x0,0x0,0xdc,0x0,0x0,0x0,0xc,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc,0x0,0x0,0x0,0x7,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0};
unsigned char Tab::rawLeftArrow[]={0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x07,0x0,0x0,0x0,0x0c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0c,0x0,0x0,0x0,0xdc,0x0,0x0,0x0,0xe7,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2c,0x0,0x0,0x0,0xfb,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4c,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6b,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xfe,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x01,0x0,0x0,0x0,0x88,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa8,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa7,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x01,0x0,0x0,0x0,0x87,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6a,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xfe,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4b,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2b,0x0,0x0,0x0,0xfa,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0b,0x0,0x0,0x0,0xdc,0x0,0x0,0x0,0xe7,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x07,0x0,0x0,0x0,0x0c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0};
unsigned char Tab::rawDownArrow[]={0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc,0x0,0x0,0x0,0xe7,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xe7,0x0,0x0,0x0,0xc,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7,0x0,0x0,0x0,0xdc,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xdc,0x0,0x0,0x0,0x7,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc,0x0,0x0,0x0,0xfb,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xfa,0x0,0x0,0x0,0xb,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2c,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xfe,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xfe,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0x2b,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4c,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0x4b,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6b,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0x6a,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x88,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0x87,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0xa8,0x0,0x0,0x0,0xa7,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0};
unsigned char Tab::rawFolder[]={0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe6,0xc1,0x9b,0x12,0xe9,0xc4,0x9f,0xd8,0xe9,0xc4,0xa0,0xff,0xe9,0xc4,0xa0,0xff,0xe9,0xc4,0xa0,0xff,0xe9,0xc4,0xa0,0xff,0xe9,0xc4,0xa0,0xff,0xe6,0xc0,0x9a,0x5b,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe5,0xc1,0x9e,0x20,0xe5,0xc2,0x9e,0xef,0xe5,0xc2,0x9e,0xff,0xe5,0xc2,0x9e,0xff,0xe5,0xc2,0x9d,0xff,0xe5,0xc2,0x9d,0xff,0xe5,0xc2,0x9d,0xff,0xe4,0xc2,0x9c,0xa6,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe3,0xbe,0x98,0x21,0xdf,0xb9,0x94,0xee,0xdf,0xb9,0x93,0xff,0xdf,0xb9,0x93,0xff,0xde,0xb9,0x92,0xff,0xde,0xb9,0x93,0xff,0xde,0xb9,0x93,0xff,0xdd,0xb7,0x90,0xe4,0xda,0xb2,0x89,0xa2,0xda,0xb2,0x8a,0xa3,0xda,0xb2,0x8a,0xa3,0xda,0xb2,0x8a,0xa3,0xda,0xb2,0x8a,0x86,0xe6,0xc1,0x97,0xf,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfb,0xda,0xaf,0xd2,0xf7,0xd6,0xab,0xfd,0xf7,0xd6,0xab,0xff,0xf7,0xd6,0xab,0xff,0xf7,0xd6,0xab,0xff,0xf6,0xd6,0xab,0xff,0xf6,0xd6,0xab,0xff,0xf6,0xd6,0xab,0xff,0xf6,0xd5,0xab,0xff,0xf6,0xd5,0xab,0xff,0xf6,0xd5,0xab,0xff,0xf6,0xd5,0xab,0xff,0xf6,0xd5,0xab,0xff,0xfa,0xda,0xaf,0xd7,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf7,0xd5,0xaa,0xff,0xf7,0xd5,0xaa,0xff,0xf7,0xd5,0xaa,0xff,0xf7,0xd5,0xaa,0xff,0xf7,0xd5,0xaa,0xff,0xf7,0xd5,0xaa,0xff,0xf7,0xd5,0xaa,0xff,0xf7,0xd5,0xaa,0xff,0xf7,0xd5,0xaa,0xff,0xf7,0xd5,0xaa,0xff,0xf7,0xd5,0xaa,0xff,0xf7,0xd5,0xaa,0xff,0xf7,0xd5,0xaa,0xff,0xf7,0xd5,0xaa,0xff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf3,0xcf,0xa3,0xff,0xf3,0xcf,0xa3,0xff,0xf3,0xcf,0xa3,0xff,0xf3,0xcf,0xa3,0xff,0xf3,0xcf,0xa3,0xff,0xf3,0xcf,0xa3,0xff,0xf3,0xcf,0xa3,0xff,0xf3,0xcf,0xa3,0xff,0xf3,0xcf,0xa3,0xff,0xf3,0xcf,0xa3,0xff,0xf3,0xcf,0xa3,0xff,0xf3,0xcf,0xa3,0xff,0xf3,0xcf,0xa3,0xff,0xf3,0xcf,0xa3,0xff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xee,0xc8,0x9b,0xff,0xee,0xc8,0x9b,0xff,0xee,0xc8,0x9b,0xff,0xee,0xc8,0x9b,0xff,0xee,0xc8,0x9b,0xff,0xee,0xc8,0x9b,0xff,0xee,0xc8,0x9b,0xff,0xee,0xc8,0x9b,0xff,0xee,0xc8,0x9b,0xff,0xee,0xc8,0x9b,0xff,0xee,0xc8,0x9b,0xff,0xee,0xc8,0x9b,0xff,0xee,0xc8,0x9b,0xff,0xee,0xc8,0x9b,0xff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xea,0xc2,0x95,0xff,0xea,0xc2,0x95,0xff,0xea,0xc2,0x95,0xff,0xea,0xc2,0x95,0xff,0xea,0xc2,0x95,0xff,0xea,0xc2,0x95,0xff,0xea,0xc2,0x95,0xff,0xea,0xc2,0x95,0xff,0xea,0xc2,0x95,0xff,0xea,0xc2,0x95,0xff,0xea,0xc2,0x95,0xff,0xea,0xc2,0x95,0xff,0xea,0xc2,0x95,0xff,0xea,0xc2,0x95,0xff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe5,0xbb,0x8e,0xff,0xe5,0xbb,0x8e,0xff,0xe5,0xbb,0x8e,0xff,0xe5,0xbb,0x8e,0xff,0xe5,0xbb,0x8e,0xff,0xe5,0xbb,0x8e,0xff,0xe5,0xbb,0x8e,0xff,0xe5,0xbb,0x8e,0xff,0xe5,0xbb,0x8e,0xff,0xe5,0xbb,0x8e,0xff,0xe5,0xbb,0x8e,0xff,0xe5,0xbb,0x8e,0xff,0xe5,0xbb,0x8e,0xff,0xe5,0xbb,0x8e,0xff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe1,0xb6,0x87,0xff,0xe1,0xb6,0x87,0xff,0xe1,0xb6,0x87,0xff,0xe1,0xb6,0x87,0xff,0xe1,0xb6,0x87,0xff,0xe1,0xb6,0x87,0xff,0xe1,0xb6,0x87,0xff,0xe1,0xb6,0x87,0xff,0xe1,0xb6,0x87,0xff,0xe1,0xb6,0x87,0xff,0xe1,0xb6,0x87,0xff,0xe1,0xb6,0x87,0xff,0xe1,0xb6,0x87,0xff,0xe1,0xb6,0x87,0xff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xdc,0xb0,0x7f,0xff,0xdc,0xb0,0x7f,0xff,0xdc,0xb0,0x7f,0xff,0xdc,0xb0,0x7f,0xff,0xdc,0xb0,0x7f,0xff,0xdc,0xb0,0x7f,0xff,0xdc,0xb0,0x7f,0xff,0xdc,0xb0,0x7f,0xff,0xdc,0xb0,0x7f,0xff,0xdc,0xb0,0x7f,0xff,0xdc,0xb0,0x7f,0xff,0xdc,0xb0,0x7f,0xff,0xdc,0xb0,0x7f,0xff,0xdc,0xb0,0x7f,0xff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xd8,0xa9,0x78,0xff,0xd8,0xa9,0x78,0xff,0xd8,0xa9,0x78,0xff,0xd8,0xa9,0x78,0xff,0xd8,0xa9,0x78,0xff,0xd8,0xa9,0x78,0xff,0xd8,0xa9,0x78,0xff,0xd8,0xa9,0x78,0xff,0xd8,0xa9,0x78,0xff,0xd8,0xa9,0x78,0xff,0xd8,0xa9,0x78,0xff,0xd8,0xa9,0x78,0xff,0xd8,0xa9,0x78,0xff,0xd8,0xa9,0x78,0xff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xd3,0xa3,0x71,0xff,0xd3,0xa3,0x71,0xff,0xd3,0xa3,0x71,0xff,0xd3,0xa3,0x71,0xff,0xd3,0xa3,0x71,0xff,0xd3,0xa3,0x71,0xff,0xd3,0xa3,0x71,0xff,0xd3,0xa3,0x71,0xff,0xd3,0xa3,0x71,0xff,0xd3,0xa3,0x71,0xff,0xd3,0xa3,0x71,0xff,0xd3,0xa3,0x71,0xff,0xd3,0xa3,0x71,0xff,0xd3,0xa3,0x71,0xff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc9,0x96,0x64,0xe7,0xca,0x97,0x65,0xff,0xca,0x97,0x65,0xff,0xca,0x97,0x65,0xff,0xca,0x97,0x65,0xff,0xca,0x97,0x65,0xff,0xca,0x97,0x65,0xff,0xca,0x97,0x65,0xff,0xca,0x97,0x65,0xff,0xca,0x97,0x65,0xff,0xca,0x97,0x65,0xff,0xca,0x97,0x65,0xff,0xca,0x97,0x65,0xff,0xc9,0x97,0x64,0xf1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0};
unsigned char Tab::rawFile[]={0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc8,0xc8,0xc8,0x4c,0xe0,0xe0,0xe0,0xcd,0xe1,0xe1,0xe1,0xc0,0xe1,0xe1,0xe1,0xbf,0xe1,0xe1,0xe1,0xbf,0xe1,0xe1,0xe1,0xbf,0xe1,0xe1,0xe1,0xc0,0xd6,0xd6,0xd6,0xc4,0xbd,0xbd,0xbd,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc5,0xc5,0xc5,0x70,0xec,0xec,0xec,0xff,0xed,0xed,0xed,0xff,0xed,0xed,0xed,0xff,0xed,0xed,0xed,0xff,0xed,0xed,0xed,0xff,0xee,0xee,0xee,0xff,0xeb,0xeb,0xeb,0xff,0xce,0xce,0xce,0xff,0xbd,0xbd,0xbd,0xa6,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xbe,0xbe,0xbe,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc5,0xc5,0xc5,0x6c,0xec,0xec,0xec,0xff,0xed,0xed,0xed,0xff,0xed,0xed,0xed,0xff,0xed,0xed,0xed,0xff,0xed,0xed,0xed,0xff,0xed,0xed,0xed,0xff,0xef,0xef,0xef,0xff,0xd3,0xd3,0xd3,0xfd,0xe1,0xe1,0xe1,0xff,0xde,0xde,0xde,0xae,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc8,0xc8,0xc8,0x6c,0xee,0xee,0xee,0xff,0xef,0xef,0xef,0xff,0xef,0xef,0xef,0xff,0xef,0xef,0xef,0xff,0xef,0xef,0xef,0xff,0xef,0xef,0xef,0xff,0xf0,0xf0,0xf0,0xff,0xdb,0xdb,0xdb,0xff,0xc0,0xc0,0xc0,0xfe,0xc9,0xc9,0xc9,0xff,0xb9,0xb9,0xb9,0xbd,0x0,0x0,0x0,0x0,0xff,0xff,0xff,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc9,0xc9,0xc9,0x6b,0xf0,0xf0,0xf0,0xff,0xf1,0xf1,0xf1,0xff,0xf1,0xf1,0xf1,0xff,0xf1,0xf1,0xf1,0xff,0xf1,0xf1,0xf1,0xff,0xf1,0xf1,0xf1,0xff,0xf1,0xf1,0xf1,0xff,0xe7,0xe7,0xe7,0xff,0xc3,0xc3,0xc3,0xff,0xb6,0xb6,0xb6,0xfc,0xc2,0xc2,0xc2,0xff,0xbd,0xbd,0xbd,0x95,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xcb,0xcb,0xcb,0x6b,0xf2,0xf2,0xf2,0xff,0xf3,0xf3,0xf3,0xff,0xf3,0xf3,0xf3,0xff,0xf3,0xf3,0xf3,0xff,0xf3,0xf3,0xf3,0xff,0xf3,0xf3,0xf3,0xff,0xf3,0xf3,0xf3,0xff,0xf2,0xf2,0xf2,0xff,0xf2,0xf2,0xf2,0xff,0xf4,0xf4,0xf4,0xff,0xf2,0xf2,0xf2,0xff,0xd5,0xd5,0xd5,0xc0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xcd,0xcd,0xcd,0x6b,0xf4,0xf4,0xf4,0xff,0xf5,0xf5,0xf5,0xff,0xf5,0xf5,0xf5,0xff,0xf5,0xf5,0xf5,0xff,0xf5,0xf5,0xf5,0xff,0xf5,0xf5,0xf5,0xff,0xf5,0xf5,0xf5,0xff,0xf5,0xf5,0xf5,0xff,0xf6,0xf6,0xf6,0xff,0xf6,0xf6,0xf6,0xff,0xf8,0xf8,0xf8,0xff,0xe4,0xe4,0xe4,0xbc,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xcf,0xcf,0xcf,0x6b,0xf6,0xf6,0xf6,0xff,0xf7,0xf7,0xf7,0xff,0xf7,0xf7,0xf7,0xff,0xf7,0xf7,0xf7,0xff,0xf7,0xf7,0xf7,0xff,0xf7,0xf7,0xf7,0xff,0xf7,0xf7,0xf7,0xff,0xf7,0xf7,0xf7,0xff,0xf7,0xf7,0xf7,0xff,0xf7,0xf7,0xf7,0xff,0xf9,0xf9,0xf9,0xff,0xe5,0xe5,0xe5,0xbc,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xd0,0xd0,0xd0,0x6b,0xf8,0xf8,0xf8,0xff,0xf9,0xf9,0xf9,0xff,0xf9,0xf9,0xf9,0xff,0xf9,0xf9,0xf9,0xff,0xf9,0xf9,0xf9,0xff,0xf9,0xf9,0xf9,0xff,0xf9,0xf9,0xf9,0xff,0xf9,0xf9,0xf9,0xff,0xf9,0xf9,0xf9,0xff,0xf9,0xf9,0xf9,0xff,0xfb,0xfb,0xfb,0xff,0xe8,0xe8,0xe8,0xbc,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xd2,0xd2,0xd2,0x6b,0xf9,0xf9,0xf9,0xff,0xfa,0xfa,0xfa,0xff,0xfa,0xfa,0xfa,0xff,0xfa,0xfa,0xfa,0xff,0xfa,0xfa,0xfa,0xff,0xfa,0xfa,0xfa,0xff,0xfa,0xfa,0xfa,0xff,0xfa,0xfa,0xfa,0xff,0xfa,0xfa,0xfa,0xff,0xfa,0xfa,0xfa,0xff,0xfc,0xfc,0xfc,0xff,0xe9,0xe9,0xe9,0xbb,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xd3,0xd3,0xd3,0x6b,0xfb,0xfb,0xfb,0xff,0xfc,0xfc,0xfc,0xff,0xfc,0xfc,0xfc,0xff,0xfc,0xfc,0xfc,0xff,0xfc,0xfc,0xfc,0xff,0xfc,0xfc,0xfc,0xff,0xfc,0xfc,0xfc,0xff,0xfc,0xfc,0xfc,0xff,0xfc,0xfc,0xfc,0xff,0xfc,0xfc,0xfc,0xff,0xfe,0xfe,0xfe,0xff,0xeb,0xeb,0xeb,0xbb,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xd4,0xd4,0xd4,0x6b,0xfc,0xfc,0xfc,0xff,0xfd,0xfd,0xfd,0xff,0xfd,0xfd,0xfd,0xff,0xfd,0xfd,0xfd,0xff,0xfd,0xfd,0xfd,0xff,0xfd,0xfd,0xfd,0xff,0xfd,0xfd,0xfd,0xff,0xfd,0xfd,0xfd,0xff,0xfd,0xfd,0xfd,0xff,0xfd,0xfd,0xfd,0xff,0xff,0xff,0xff,0xff,0xec,0xec,0xec,0xbb,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xd4,0xd4,0xd4,0x6b,0xfd,0xfd,0xfd,0xff,0xfe,0xfe,0xfe,0xff,0xfe,0xfe,0xfe,0xff,0xfe,0xfe,0xfe,0xff,0xfe,0xfe,0xfe,0xff,0xfe,0xfe,0xfe,0xff,0xfe,0xfe,0xfe,0xff,0xfe,0xfe,0xfe,0xff,0xfe,0xfe,0xfe,0xff,0xfe,0xfe,0xfe,0xff,0xff,0xff,0xff,0xff,0xec,0xec,0xec,0xbb,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xd5,0xd5,0xd5,0x6a,0xfd,0xfd,0xfd,0xff,0xfe,0xfe,0xfe,0xff,0xfe,0xfe,0xfe,0xff,0xfe,0xfe,0xfe,0xff,0xfe,0xfe,0xfe,0xff,0xfe,0xfe,0xfe,0xff,0xfe,0xfe,0xfe,0xff,0xfe,0xfe,0xfe,0xff,0xfe,0xfe,0xfe,0xff,0xfe,0xfe,0xfe,0xff,0xff,0xff,0xff,0xff,0xed,0xed,0xed,0xbb,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xdb,0xdb,0xdb,0x70,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf1,0xf1,0xf1,0xc5,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa4,0xa4,0xa4,0x41,0xbc,0xbc,0xbc,0xab,0xbb,0xbb,0xbb,0xa2,0xbb,0xbb,0xbb,0xa1,0xbb,0xbb,0xbb,0xa1,0xbb,0xbb,0xbb,0xa1,0xbb,0xbb,0xbb,0xa1,0xbb,0xbb,0xbb,0xa1,0xbb,0xbb,0xbb,0xa1,0xbb,0xbb,0xbb,0xa2,0xbb,0xbb,0xbb,0xa2,0xbd,0xbd,0xbd,0xaa,0xb4,0xb4,0xb4,0x73,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x4,0x0,0x0,0x0,0x5,0x0,0x0,0x0,0x5,0x0,0x0,0x0,0x5,0x0,0x0,0x0,0x5,0x0,0x0,0x0,0x5,0x0,0x0,0x0,0x5,0x0,0x0,0x0,0x5,0x0,0x0,0x0,0x5,0x0,0x0,0x0,0x5,0x0,0x0,0x0,0x5,0x0,0x0,0x0,0x5,0x0,0x0,0x0,0x5,0x0,0x0,0x0,0x4,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0};





Tab::Tab(float x,float y,float w,float h):
	windowData(0),
	container(0),
	viewerSelected(0),
	mouseDown(false),
	isRender(false),
	splitterContainer(0),
	renderer3D(0),
	renderer2D(0),
	recreateTarget(false),
	resizeTarget(true),
	resizing(false),
	lastFrameTime(0),
	iconUp(0),
	iconLeft(0),
	iconRight(0),
	iconDown(0),
	iconFolder(0),
	iconFile(0),
	thread(0),
	focused(0),
	pressed(0),
	hovered(0),
	isModal(false),
	hasFrame(true),
	guiRoot(this)
{}

Tab::~Tab()
{
	this->container->tabs.erase(std::find(container->tabs.begin(),container->tabs.end(),this));

	//this->rectsLayered.name=L"RECTLAYERED";
}

Gui* Tab::GetSelected()
{
	return viewerSelected;
}


void Tab::DrawBlock(bool iBool)
{
	Thread* tProjectDirChangedThread=Ide::GetInstance()->projectDirChangedThread;

	if(iBool)
	{
		this->drawTask->Block(iBool);
		tProjectDirChangedThread->Block(true);
	}

	for(std::list<DrawInstance*>::iterator iterDrawInstance=this->drawInstances.begin();iterDrawInstance!=this->drawInstances.end();iterDrawInstance++)
	{
		if((*iterDrawInstance) && (*iterDrawInstance)->remove==true)
		{
			SAFEDELETE(*iterDrawInstance);
		}
	}

	this->SetHover(0);
	this->SetPressed(0);
	this->SetFocus(0);

	if(!iBool)
	{
		tProjectDirChangedThread->Block(false);
		this->drawTask->Block(iBool);
	}
}


void Tab::Draw()
{
	if(this->drawTask->pause)
		DEBUG_BREAK();

	if(!this->drawInstances.empty())
	{
		for(std::list<DrawInstance*>::iterator it=this->drawInstances.begin();it!=this->drawInstances.end();it)
		{
			DrawInstance*& tDrawInstance=*it;

			if(tDrawInstance && !tDrawInstance->skip)
			{
				if(this->BeginDraw())
				{
					if(!tDrawInstance->rect)
						this->OnGuiPaint();
					else
					{
						tDrawInstance->rect->OnBeginClip(this);
						tDrawInstance->rect->OnPaint(this);
						tDrawInstance->rect->OnEndClip(this);
					}

					this->EndDraw();
				}
			}

			if(!tDrawInstance || tDrawInstance->remove)
			{
				SAFEDELETE(tDrawInstance);
				it=this->drawInstances.erase(it);
			}
			else it++;
		}
	}

	Ide::GetInstance()->stringEditor->Draw(this);
}

DrawInstance* Tab::SetDraw(Gui* iRect,bool iRemove,bool iSkip)
{
	DrawInstance* newInstance=new DrawInstance(iRect,iRemove,iSkip);
	this->drawInstances.push_back(newInstance);
	return newInstance;
}

void Tab::BroadcastToSelected(void (Gui::*iFunc)(Tab*,Event* iData),Event* iData)
{

}

void Tab::BroadcastToAll(void (Gui::*iFunc)(Tab*,Event* iData),Event* iData)
{
	
}


void Tab::SetSelection(Gui* iRect)
{
	if(this->GetSelected())
		this->GetSelected()->OnDeactivate(this);

	this->viewerSelected=iRect;

	if(this->GetSelected())
	{
		this->GetSelected()->OnResize(this);
		this->GetSelected()->OnActivate(this);
	}

	this->SetDraw();
}


void Tab::OnGuiSize(void* iData)
{
	this->guiRoot.SetEdges(this->GetEdges());
	this->guiRoot.OnResize(this);

	this->resizeTarget=true;
}

void Tab::OnWindowPosChanging(void* iData)
{
	this->resizeTarget=true;

	this->guiRoot.SetEdges(this->GetEdges());
	this->guiRoot.OnResize(this);
}



void Tab::OnGuiMouseMove(void* data)
{
	splitterContainer->currentTabContainer=this;

	EventMouse	tEvent;

				tEvent.mouse=this->mouse;
				tEvent.button=0;

	Gui*			tOldHover=this->hovered;
	Gui*			tNewHover=0;

	if(this->hovered && this->hovered->IsPressing())
	{
		this->hovered->OnMouseMove(this,&tEvent);
		return;
	}

	this->guiRoot.FindHover(this,this->mouse,tNewHover);

	if(tOldHover!=tNewHover)
	{
		if(tOldHover)
			tOldHover->OnMouseExit(this);

		if(tNewHover)
			tNewHover->OnMouseEnter(this);
	}

	if(tNewHover)
		tNewHover->OnMouseMove(this,&tEvent);

	this->hovered=tNewHover;
}

void Tab::OnGuiLMouseUp(void* data)
{
	mouseDown=false;

	EventMouse tEvent;
	tEvent.mouse=this->mouse;
	tEvent.button=1;

	if(this->hovered)
		this->hovered->OnButtonUp(this,&tEvent);
}

void Tab::OnGuiMouseWheel(void* data)
{
	EventMouse tEvent;
	tEvent.mouse=this->mouse;
	tEvent.button=2;

	if(this->hovered)
		this->hovered->OnMouseWheel(this,&tEvent);
}

void Tab::OnGuiLMouseDown(void* data)
{
	if(this->hasFrame && this->mouse.y<=BAR_HEIGHT)
	{
		float &x=this->mouse.x;
		float &y=this->mouse.y;

		Gui* tPreviousTabSelected=this->GetSelected();

		vec2 tDim(0,LABEL_LEFT_OFFSET);

		for(std::list<Gui*>::const_iterator i=this->guiRoot.GetChilds().begin();i!=this->guiRoot.GetChilds().end();i++)
		{
			vec2 tTextSize = this->renderer2D->MeasureText((*i)->GetName().c_str());

			tDim.x = tDim.y;
			tDim.y = tDim.x + tTextSize.x + LABEL_RIGHT_OFFSET;

			bool tMouseContained = (x>tDim.x && x< tDim.y) && (y>(BAR_HEIGHT-LABEL_HEIGHT) &&  y<BAR_HEIGHT);

			if(tMouseContained && (*i)!=tPreviousTabSelected)
			{
				mouseDown=true;

				this->SetSelection(*i);

				break;
			}
		}
	}
	else
	{
		EventMouse tInput;
		
		tInput.mouse=this->mouse;
		tInput.button=1;
		
		if(this->hovered)
			this->hovered->OnButtonDown(this,&tInput);
	}
}

void Tab::OnGuiDLMouseDown(void* data)
{
	if(!this->hasFrame || this->mouse.y>BAR_HEIGHT)
	{
		EventMouse tInput;

		tInput.mouse=this->mouse;
		tInput.button=1;

		if(this->hovered)
			this->hovered->OnDoubleClick(this,&tInput);
	}
}

void Tab::OnGuiUpdate(void* data)
{
	if(this->GetSelected())
		this->GetSelected()->OnUpdate(this);
}

void Tab::OnGuiRMouseUp(void* data)
{
	EventMouse tInput;

	tInput.mouse=this->mouse;
	tInput.button=3;

	if(this->hovered)
		this->hovered->OnButtonUp(this,&tInput);
}

void Tab::OnEntitiesChange(void* data)
{
	if(this->GetSelected())
		this->GetSelected()->OnEntitiesChange(this);
}

void Tab::OnGuiActivate(void* iGui)
{
	bool tActive=true;
}
void Tab::OnGuiDeactivate(void* data)
{
	bool tActive=true;
}
void Tab::OnGuiEntitySelected(void* data)
{
	if(this->GetSelected())
		this->GetSelected()->OnEntitySelected(this);
}

void Tab::OnGuiKeyDown(void* data)
{
	EventKey tKey;
	tKey.key=*(char*)data;

	if(this->focused)
		this->focused->OnKeyDown(this,&tKey);
}

void Tab::OnGuiKeyUp(void* data)
{
	EventKey tKey;
	tKey.key=*(char*)data;

	if(this->focused)
		this->focused->OnKeyUp(this,&tKey);
}

void Tab::OnGuiRecreateTarget(void* data)
{
	if(this->GetSelected())
		this->GetSelected()->OnRecreateTarget(this);
}

vec2 Tab::GetSize()
{
	return this->windowData->Size();
}

vec4 Tab::GetEdges()
{
	vec2 tTabSize=this->GetSize();

	return vec4(0,this->hasFrame ? Tab::BAR_HEIGHT : 0,tTabSize.x,tTabSize.y);
}


void Tab::DrawFrame()
{
	if(!this->hasFrame)
		return;

	vec2 iTabDim=this->GetSize();

	float tLabelLeft=0;
	float tLabelRight=5;

	this->renderer2D->Identity();

	vec2 tDim(0,LABEL_LEFT_OFFSET);

	//render label text
	for(std::list<Gui*>::const_iterator i=this->guiRoot.GetChilds().begin();i!=this->guiRoot.GetChilds().end();i++)
	{
		vec2 tTextSize = this->renderer2D->MeasureText((*i)->GetName().c_str());

		tDim.x = tDim.y;
		tDim.y = tDim.x + tTextSize.x + LABEL_RIGHT_OFFSET;

		if(this->viewerSelected==*i)
			this->renderer2D->DrawRectangle(tDim.x,(float)(BAR_HEIGHT-LABEL_HEIGHT),tDim.y,(float)((BAR_HEIGHT-LABEL_HEIGHT)+LABEL_HEIGHT),Gui::COLOR_BACK);

		this->renderer2D->DrawText((*i)->GetName(),tDim.x,(float)BAR_HEIGHT-LABEL_HEIGHT,tDim.y,(float)(BAR_HEIGHT-LABEL_HEIGHT) + (float)LABEL_HEIGHT,vec2(0.5f,0.5f),vec2(0.5f,0.5f),GuiString::COLOR_TEXT);
	}
}

void Tab::PaintBackground()
{
	vec2 iTabDim=this->GetSize();

	this->renderer2D->DrawRectangle(0,0,iTabDim.x,iTabDim.y/*-Tab::CONTAINER_HEIGHT*/,Tab::COLOR_BACK);
	//this->renderer2D->DrawRectangle(0,0,iTabDim.x,iTabDim.y/*-Tab::CONTAINER_HEIGHT*/,0xff0000,false);

	this->DrawFrame();
}


void Tab::OnGuiPaint(void* data)
{
	this->PaintBackground();

	if(this->GetSelected())
		this->GetSelected()->OnPaint(this);
}

void Tab::OnResizeContainer(void* data)
{

}



void Tab::SetFocus(Gui* iFocusedRect)
{
	if(this->focused && this->focused!=iFocusedRect)
		this->focused->OnExitFocus(this);

	this->focused=iFocusedRect;

	if(this->focused)
		this->focused->OnEnterFocus(this);
}

void Tab::SetHover(Gui* iHoveredRect)
{
	this->hovered=iHoveredRect;
}

void Tab::SetPressed(Gui* iPressedRect)
{
	/*if(Tab::pressed)
		Tab::pressed->pressing=false;

	Tab::pressed=iPressedRect;

	if(Tab::pressed)
		Tab::pressed->pressing=true;*/
}

Gui* Tab::GetFocus()
{
	return Tab::focused;
}

Gui* Tab::GetPressed()
{
	return Tab::pressed;
}

Gui* Tab::GetHover()
{
	return Tab::hovered;
}




///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////SplitterContainer///////////////
///////////////////////////////////////////////
///////////////////////////////////////////////
Splitter::Splitter():
splitterSize(4)
{
	floatingTabRef=0;
	floatingTab=0;
	floatingTabTarget=0;
	floatingSelectedTebGuiRect=0;
	floatingTabRefTabCount=-1;
	floatingTabTargetAnchorPos=-1;
	floatingTabTargetAnchorTabIndex=-1;

	splitterCursor=L"IDC_ARROW";
}
Splitter::~Splitter()
{
}

///////////////////////////////////////////////
///////////////////////////////////////////////
//////////////////GuiCaret///////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

StringEditor::Cursor::Cursor():cursor(0){}

StringEditor::StringEditor():
	string(0),
	tab(0),
	lastBlinkTime(0),
	blinking(false),
	enabled(false),
	blinkingRate(BLINKRATE)
{}

StringEditor::~StringEditor()
{
}

void StringEditor::Bind(GuiString* iString)
{
}

void StringEditor::Enable(bool iEnable)
{
}

GuiString* StringEditor::Binded()
{
	return 0;
}

bool StringEditor::Enabled()
{
	return false;
}

bool StringEditor::EditText(unsigned int iCaretOp,void* iParam)
{
	return false;
}

void StringEditor::Draw(Tab* iCallerTab)
{
	
}


///////////////////////////////////////////////
///////////////////////////////////////////////
//////////////////Renderer2D///////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////


const GuiFont* GuiFont::GetDefaultFont()
{
	return ::GlobalDefaultFontInstance();
}

const std::vector<GuiFont*>& GuiFont::GetFontPool()
{
	return ::GlobalFontPoolInstance();
}

GuiFont::GuiFont():tabSpaces(4){}

float GuiFont::GetHeight()const
{
	return this->height;
}

float GuiFont::GetCharWidth(wchar_t tCharacter)const
{
	return this->widths[tCharacter];
}

vec2 GuiFont::MeasureText(const wchar_t* iText)const
{
	float width=0,tWidth=0;
	float height=0;

	if(!iText)
		vec2(width,height);

	float fontHeight=height=this->height;

	wchar_t* t=(wchar_t*)iText;

	while(*t)
	{
		float tW;

		if(*t=='\n' || *t=='\r')
		{
			height+=fontHeight;
			tWidth>width?width=tWidth:0;
			tWidth=0;
		}
		else
		{
			tW=this->widths[*t];
			tWidth+=tW;
		}

		t++;
	}

	tWidth>width?width=tWidth:0;

	return vec2(width,height);
}

///////////////////////////////////////////////
///////////////////////////////////////////////
//////////////////Renderer2D///////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////



Renderer2D::Renderer2D(Tab* iTabContainer):
	tab(iTabContainer),
	tabSpaces(4)
{
	
}

Renderer2D::~Renderer2D(){}



vec2 Renderer2D::MeasureText(const wchar_t* iText,const GuiFont* iFont)
{
	return iFont->MeasureText(iText);
}

///////////////////////////////////////////////
///////////////////////////////////////////////
/////////////Renderer3DInterface///////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

Renderer3D::Renderer3D(Tab* iTabContainer):
	tab(iTabContainer)
{

}



Shader* Renderer3D::FindShader(const char* name,bool exact)
{
	return Shader::Find(name,exact);
}

void Renderer3D::SetMatrices(const float* view,const float* mdl)
{
	for(size_t i=0;i<this->shaders.size();i++)
	{
		this->shaders[i]->Use();

		if(view)
			this->shaders[i]->SetProjectionMatrix((float*)view);
		if(mdl)
			this->shaders[i]->SetModelviewMatrix((float*)mdl);
	}
}

bool Renderer3D::LoadTexture(String iFilename,Texture* iTexture)
{
    FILE *tFile=fopen(StringUtils::ToChar(iFilename).c_str(),"rb");
	bool tReturn=false;

	if(tFile)
	{
		short int bmp_signature=0x4d42;
		int jpg_signature1=0xe0ffd8ff;
		int jpg_signature2=0xdbffd8ff;
		int jpg_signature3=0xe1ffd8ff;
		int png_signature1=0x474e5089;
		int png_signature2=0x0a1a0a0d;

		int sign1;
		int sign2;

		fread(&sign1,4,1,tFile);
		fread(&sign2,4,1,tFile);

		if(bmp_signature==(short int)sign1)
		{
            fseek(tFile,0x12,SEEK_SET);
            fread(&iTexture->m_width,2,1,tFile);
            fseek(tFile,0x16,SEEK_SET);
            fread(&iTexture->m_height,2,1,tFile);
            fseek(tFile,0x1c,SEEK_SET);
            fread(&iTexture->m_bpp,2,1,tFile);

            rewind(tFile);

            fseek(tFile,0,SEEK_END);
            iTexture->m_bufsize=ftell(tFile)-54;
            rewind(tFile);
            fseek(tFile,54,SEEK_SET);

            iTexture->m_buf=new unsigned char[iTexture->m_bufsize];

            fread(iTexture->m_buf,1,iTexture->m_bufsize,tFile);

            fclose(tFile);

			return true;
		}
		else
		{
			fclose(tFile);

			std::string tCharFilename=StringUtils::ToChar(iFilename);

			if(jpg_signature1==sign1 || jpg_signature3==sign1 || jpg_signature2==sign2  || jpg_signature3==sign2 )
			{
				int ncomp;

				iTexture->m_buf=jpgd::decompress_jpeg_image_from_file(tCharFilename.c_str(),&iTexture->m_width,&iTexture->m_height,&ncomp,4);

				tReturn=iTexture->m_buf ? true : false;
			}
			else if(png_signature1==sign1 && png_signature2==sign2)
			{
				{
					std::vector<unsigned char> image;
					unsigned long w, h;
					std::vector<unsigned char> buffer;
					int error=-1;

					loadFile(buffer,tCharFilename);

					error = decodePNG(image, w, h, buffer.empty() ? 0 : &buffer[0], (unsigned long)buffer.size());

					if(!error)
					{
						iTexture->m_bufsize=image.size();
						iTexture->m_buf=new unsigned char[iTexture->m_bufsize];
						memcpy(iTexture->m_buf,&image[0],iTexture->m_bufsize);
						iTexture->m_width=w;
						iTexture->m_height=h;

						tReturn=true;
					}

					tReturn=false;
				}
			}
			else if(655360==sign1 && 0==sign2)
			{
				tReturn=LoadTGA(tCharFilename.c_str(),iTexture->m_buf,iTexture->m_bufsize,iTexture->m_width,iTexture->m_height,iTexture->m_bpp);
			}
		}
	}

	return tReturn;

}

///////////////////////////////////////////////
///////////////////////////////////////////////
////////////////////GuiRect////////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

const vec4 ____GuiEdges;

Gui::Gui():owner(0),parent(0),hovering(false),pressing(false),active(false){}

Gui::~Gui(){}

void Gui::AddChild(Gui* iRect)
{
	iRect->parent=this;
	this->childs.push_back(iRect);
}

void Gui::RemoveChild(Gui* iRect)
{
	this->childs.remove(iRect);
	iRect->parent=0;
}

void Gui::RemoveAllChilds()
{
	this->parent=0;
	this->childs.clear();
}


const Gui*				Gui::GetParent()
{
	return this->parent;
}

const std::list<Gui*>&  Gui::GetChilds()
{
	return this->childs;
}

void Gui::SetOwner(Gui* iOwner)
{
	this->owner=iOwner;
}

Gui*	Gui::GetOwner()
{
	return this->owner;
}

GuiRoot* Gui::GetRoot()
{
	Gui* tParent=this->parent;

	while(tParent)
	{
		if(tParent->parent)
			tParent=tParent->parent;
		else
			return dynamic_cast<GuiRoot*>(tParent);
	}

	return dynamic_cast<GuiRoot*>(this);
}

vec4 Gui::GetEdges()
{
	return ____GuiEdges;
}

String Gui::GetName()
{
	return this->name;
}

unsigned int Gui::GetColor()
{
	return Gui::COLOR_BACK;
}

void Gui::SetName(String iName)
{
	this->name=iName;
}

float	Gui::GetWidth()
{
	const vec4& tEdges=this->GetEdges();

	return tEdges.z-tEdges.x;
}
float	Gui::GetHeight()
{
	const vec4& tEdges=this->GetEdges();

	return tEdges.w-tEdges.y;
}

bool Gui::Contains(const vec2& iMouse)
{
	const vec4& tEdges=this->GetEdges();

	return (iMouse.x>tEdges.x && iMouse.x<tEdges.z && iMouse.y>tEdges.y && iMouse.y<tEdges.w);
}

bool	Gui::IsHovering(){return this->hovering;}
bool	Gui::IsPressing(){return this->pressing;}
bool	Gui::IsActive(){return this->active;}
void	Gui::SetActive(bool iActive){this->active=iActive;}




///////////////////////////////////////////////
///////////////////////////////////////////////
//////////////////GuiRoot/////////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

GuiRoot::GuiRoot(Tab* iTab):tab(iTab){}

Tab*	GuiRoot::GetTab()
{
	return this->tab;
}

void	GuiRoot::OnResize(Tab* iTab,Event* iData)
{
	if(this->tab->GetSelected())
	{
		this->tab->GetSelected()->SetEdges(this->GetEdges());
		this->tab->GetSelected()->OnResize(this->tab);
	}
}

void GuiRoot::FindHover(Tab* iTab,vec2& iMouse,Gui*& iGui)
{
	if(this->Contains(iMouse))
		iGui=this;

	if(this->GetTab()->GetSelected())
		this->GetTab()->GetSelected()->FindHover(iTab,iMouse,iGui);
}

///////////////////////////////////////////////
///////////////////////////////////////////////
//////////////////Compiler/////////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

Compiler::Compiler()
{
	ideSrcPath=Ide::GetInstance()->pathExecutable.PathUp(5) + L"\\src";
	ideLibPath=Ide::GetInstance()->pathExecutable.Path();

	COMPILER msCompiler={L"ms",
						 L"vc2010",
						 L"cl.exe ",
						 L"linker.exe ",
						 L" /nologo /MDd /ZI /EHsc ",
						 L" /link /MANIFEST:NO /DLL /NOENTRY ",
						 L" /OUT:",
						 L"enginelibMS",
						 L".lib ",
						 L" /I",
						 L" ",
						 L"kernel32.lib"
						};

	COMPILER mingwCompiler={L"mingw",
							L"i686-w64-mingw32",
							L"c:\\sdk\\mingw32\\bin\\i686-w64-mingw32-g++.exe ",
							L"c:\\sdk\\mingw32\\bin\\i686-w64-mingw32-ld.exe ",
							L" -O0 -g -shared ",
							L"",
							L" -o ",
							L"enginelibMingW",
							L".dll ",
							L" -I"
						   };

	COMPILER llvmCompiler={L"llvm",
						   L"5.0.0 32bit",
						   L"c:\\sdk\\llvm32\\bin\\clang-cl.exe ",
						   L"c:\\sdk\\llvm32\\bin\\lld-link.exe ",
						   L" /nologo /MDd /ZI /EHsc ",
						   L" /link /MANIFEST:NO /DLL /NOENTRY ",
						   L" /OUT:",
						   L"enginelibLLVM",
						   L".lib ",
						   L" /I"
						  };

	compilers.push_back(msCompiler);
	compilers.push_back(mingwCompiler);
	compilers.push_back(llvmCompiler);
}


Compiler::~Compiler(){}


String Compiler::Compose(unsigned int iCompiler,EditorScript* iScript)
{
	Compiler*			icplr=Ide::GetInstance()->compiler;
	Compiler::COMPILER& cplr=icplr->compilers[iCompiler];

	String tOutputModule=iScript->module + L"\\" + iScript->file.Name() + L".dll ";
	String tScriptSource=Ide::GetInstance()->folderProject + L"\\" + iScript->file.File();
	String tIdeSourcePath=Ide::GetInstance()->compiler->ideSrcPath +  L" ";
	String tEngineLibrary=icplr->ideLibPath + L"\\" + cplr.engineLibraryName + cplr.engineLibraryExtension + L" ";


	String tCompilerExecutableString;

	if(iCompiler==Compiler::COMPILER_MS)
		tCompilerExecutableString=L"vcvars32.bat && ";

	tCompilerExecutableString+=cplr.compilerExecutable;

	String	tComposedOutput=tCompilerExecutableString +
		cplr.compilerFlags +
		cplr.includeHeadersPrefix +
		tIdeSourcePath +
		tScriptSource +
		cplr.linkerFlags +
		cplr.outputCommand +
		tOutputModule +
		tEngineLibrary +
		cplr.includeLibPrefix + 
		cplr.additionalLibs;

	return	tComposedOutput;
}

bool Compiler::Compile(EditorScript* iScript)
{
	if(iScript->runtime)
		return false;

	bool retVal;

	String tOriginalScriptSource=iScript->LoadScript();
	String tCompileScriptSource=tOriginalScriptSource;

	{
		tCompileScriptSource+=L"\n\nextern \"C\" __declspec(dllexport) EntityScript* Create(){return new " + iScript->entity->name + L"_;}";
		tCompileScriptSource+=L"\n\nextern \"C\" __declspec(dllexport) void Destroy(EntityScript* iDestroy){SAFEDELETE(iDestroy);}\n\n";
	}

	File tCompilerErrorOutput=Ide::GetInstance()->folderAppData + L"\\error.output";


	//delete error.output

	if(tCompilerErrorOutput.Exist())
	{
		if(!tCompilerErrorOutput.Delete())
			DEBUG_BREAK();
	}

	//create random directory for the module if not exist yet

	if(iScript->module.empty())
		iScript->module=Ide::GetInstance()->subsystem->RandomDir(Ide::GetInstance()->folderAppData,8);

	//append exports to source

	iScript->SaveScript(tCompileScriptSource);

	//compose the compiler command line

	unsigned int tCompiler=Compiler::COMPILER_MS;

	String tCommandLineMingW=this->Compose(tCompiler,iScript);

	//execute compilation

	bool tExecuteWithSuccess=Ide::GetInstance()->subsystem->Execute(iScript->module,tCommandLineMingW,tCompilerErrorOutput.path,true,true,true);

	if(!tExecuteWithSuccess)
		DEBUG_BREAK();

	//unroll exports

	iScript->SaveScript(tOriginalScriptSource);

	//convert compiler output to readable locale

	String tWideCharCompilationOutput=StringUtils::ReadCharFile(tCompilerErrorOutput.path,L"rb");

	//extract and parse breakpoint line addresses

	File tLineAddressesOutput=iScript->module + L"\\laddrss.output";

	String tScriptFileName=iScript->file.Name();

	String tSharedObjectFileName=tScriptFileName + L".dll";
	String tSharedObjectSourceName=tScriptFileName + L".cpp";

	String tParseLineAddressesCommandLine=L"objdump --dwarf=decodedline " + tSharedObjectFileName + L" | find \""+ tSharedObjectSourceName + L"\" | find /V \":\"";

	tExecuteWithSuccess=Ide::GetInstance()->subsystem->Execute(iScript->module,tParseLineAddressesCommandLine,tLineAddressesOutput.path,true,true,true);

	if(!tExecuteWithSuccess)
		DEBUG_BREAK();

	if(tLineAddressesOutput.Open(L"rb"))
	{
		EditorScript* tEditorScript=(EditorScript*)iScript;

		int tNumberOfLines=tLineAddressesOutput.CountOccurrences('\n');

		char c[500];
		unsigned int line;

		for(int i=0;i<tNumberOfLines;i++)
		{
			fscanf(tLineAddressesOutput.data,"%s",c);
			fscanf(tLineAddressesOutput.data,"%u",&line);
			fscanf(tLineAddressesOutput.data,"%s",&c);

			if(i>7)//skip source exports
			{
				Debugger::Breakpoint tLineAddress;

				sscanf(c,"%lx", &tLineAddress.address);
				tLineAddress.line=line;
				tLineAddress.script=iScript;


				Ide::GetInstance()->debugger->allAvailableBreakpoints.push_back(tLineAddress);
			}
		}

		tLineAddressesOutput.Close();

		if(!tLineAddressesOutput.Delete())
			DEBUG_BREAK();
	}

	//spawn a compilerViewer and show it if errors  @mic best to send message to the guicompilerviewer

	EditorScript* tEditorScript=(EditorScript*)iScript;
	std::vector<GuiCompilerViewer*> tGuiCompilerViewers;
	MainContainer* tMainContainer=Ide::GetInstance()->mainAppWindow;

	return retVal;
}


bool Compiler::LoadScript(EditorScript* iScript)
{
	if(!iScript->module.size())
		return false;

	EntityScript*	(*tCreateModuleClassFunction)()=0;
	String          tModuleFile=iScript->module + L"\\" + iScript->file.Name() + L".dll";

	if(!iScript->handle)
	{
		iScript->handle=Ide::GetInstance()->subsystem->LoadLibrary(tModuleFile.c_str());

		if(!iScript->handle)
			return false;

	}

	tCreateModuleClassFunction=(EntityScript* (*)())Ide::GetInstance()->subsystem->GetProcAddress(iScript->handle,L"Create");

	if(tCreateModuleClassFunction)
	{
		iScript->runtime=tCreateModuleClassFunction();
		iScript->runtime->entity=iScript->entity;

		Ide::GetInstance()->debugger->RunDebuggeeFunction(iScript,0);

		return true;
	}
	else
	{
		wprintf(L"error creating module %s\n",tModuleFile.c_str());

		SAFEDELETEARRAY(iScript->runtime);

		if(iScript->handle && Ide::GetInstance()->subsystem->FreeLibrary(iScript->handle))
			DEBUG_BREAK();
	}

	return false;
}

bool Compiler::UnloadScript(EditorScript* iScript)
{
	const bool tDestroyInTheDLL=false;

	if(iScript->runtime)
	{
		if(!iScript->handle)
			return false;

		//iScript->runtime->deinit();
		Ide::GetInstance()->debugger->RunDebuggeeFunction(iScript,2);

		if(!Ide::GetInstance()->subsystem->FreeLibrary(iScript->handle))
			return false;
		else
			iScript->handle=0;

		if(tDestroyInTheDLL)
		{
			void (*DestroyScript)(EntityScript*)=(void(*)(EntityScript*))Ide::GetInstance()->subsystem->GetProcAddress(iScript->handle,L"Destroy");

			DestroyScript(iScript->runtime);
			iScript->runtime=0;
		}
		else
			iScript->runtime=0;

		return true;
	}

	return true;
}

///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////////EditorEntity////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

EditorEntity::EditorEntity()
{
	
}

EditorEntity* EditorEntity::GetParent(){return (EditorEntity*)this->parent;}

const std::list<EditorEntity*>& EditorEntity::Childs(){return (std::list<EditorEntity*>&)this->childs;}
const std::list<EntityComponent*>& EditorEntity::Components(){return this->components;}

EditorEntity*	EditorEntity::AddEntity(EditorEntity* iEditorEntity)
{
	this->childs.push_back(iEditorEntity);
	iEditorEntity->parent=this;
	this->sceneLabel.Insert(iEditorEntity->sceneLabel);
	return iEditorEntity;
}
void	EditorEntity::RemoveEntity(EditorEntity* iEditorEntity)
{
	this->childs.remove(iEditorEntity);
	iEditorEntity->parent=0;
	this->sceneLabel.RemoveChild(&iEditorEntity->sceneLabel);
}

EntityComponent*	EditorEntity::AddComponent(EntityComponent* iComponent)
{
	this->components.push_back(iComponent);
	iComponent->entity=this;
	return iComponent;
}
void	EditorEntity::RemoveComponent(EntityComponent* iComponent)
{
	this->components.remove(iComponent);
	iComponent->entity=0;
}


EditorEntity::~EditorEntity()
{
}

void EditorEntity::DestroyChilds()
{
}

///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////GuiTreeview/////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////


unsigned int Blend(unsigned int in,unsigned int icol)
{
	unsigned int ret=0;
	unsigned char* a=(unsigned char*)&in;
	unsigned char* b=(unsigned char*)&icol;
	unsigned char* c=(unsigned char*)&ret;

	for(int i=0;i<4;i++)
	{
		unsigned char tMax=std::max<unsigned char>(a[i],b[i]);
		unsigned char tMin=std::min<unsigned char>(a[i],b[i]);
		c[i]=tMin+(tMax-tMin)/2.0f;
	}

	return ret;
}

GuiTreeView::Item::Item():expanded(true),selected(false),treeview(0){}

vec4 GuiTreeView::Item::GetEdges()
{
	return vec4(this->treeview->edges.x,this->top,this->treeview->leftEdge,this->top+Tab::ICON_WH);
}

vec4 GuiTreeView::Item::GetExpandosEdges()
{
	float	tExpandosLeft=this->GetLeadEdge();

	return vec4(tExpandosLeft,this->top,tExpandosLeft+Tab::ICON_WH,this->top+Tab::ICON_WH);
}

float GuiTreeView::Item::GetLeadEdge()
{
	return this->treeview->edges.x+this->level*Tab::ICON_WH;
}


bool GuiTreeView::Item::ExpandosContains(const vec2& iMouse)
{
	vec4 tExpandosEdges=this->GetExpandosEdges();

	return iMouse.x>tExpandosEdges.x && iMouse.x<tExpandosEdges.z && iMouse.y>tExpandosEdges.y && iMouse.y<tExpandosEdges.w;
}

void GuiTreeView::Item::SetName(String iString)
{
	this->name=iString;
}

void GuiTreeView::Item::Insert(Item& iItem)
{
	this->AddChild(&iItem);

	if(this->treeview)
		this->treeview->RecalcItems();
}

GuiTreeView* GuiTreeView::Item::GetTreeView()
{
	return this->treeview;
}

void GuiTreeView::Item::OnButtonDown(Tab* iTab,EventMouse* iData/*=0*/)
{
	Gui::OnButtonDown(iTab,iData);
}



void GuiTreeView::Item::OnButtonUp(Tab* iTab,EventMouse* iData/*=0*/)
{
	Gui::OnButtonUp(iTab,iData);

	if(iData->button==1)
	{
		vec2	tcm=this->treeview->GetClippedMouse(iData->mouse);
		float	tItemStart=this->GetLeadEdge();

		if(this->GetChilds().size() && tcm.x>tItemStart && tcm.x<tItemStart+Tab::ICON_WH)
		{
			this->expanded=!this->expanded;

			this->OnExpandos(iTab);

			this->treeview->RecalcItems();

			iTab->SetDraw(this->treeview);
		}
		else
		{
			this->selected=!this->selected;
			iTab->SetDraw(this);
		}
	}
}

void GuiTreeView::Item::OnMouseEnter(Tab* iTab,EventMouse* iData/*=0*/)
{
	Gui::OnMouseEnter(iTab,iData);
	iTab->SetDraw(this);
}

void GuiTreeView::Item::OnMouseExit(Tab* iTab,EventMouse* iData/*=0*/)
{
	Gui::OnMouseExit(iTab,iData);
	iTab->SetDraw(this);
}



void GuiTreeView::Item::OnBeginClip(Tab* iTab,Event* iData)
{
	this->treeview->BeginClip(iTab);
}

void GuiTreeView::Item::OnEndClip(Tab* iTab,Event* iData)
{
	this->treeview->EndClip(iTab);
}

void GuiTreeView::Item::OnPaint(Tab* iTab,Event* iData)
{
	unsigned int tColor=Gui::COLOR_BACK;

	if(this->IsHovering())
		tColor=Blend(tColor,Tab::COLOR_BACK);
	if(this->IsPressing())
		tColor=Blend(tColor,Tab::COLOR_BACK+0x101010);
	if(this->selected)
		tColor=Blend(tColor,0x00ff00);

	vec4 tEdges=this->GetEdges();

	iTab->renderer2D->DrawRectangle(tEdges.x,tEdges.y,tEdges.z,tEdges.w,tColor);

	float tX=this->GetLeadEdge();

	if(this->GetChilds().size())
	{
		iTab->renderer2D->DrawBitmap(this->expanded ? iTab->iconDown : iTab->iconRight,tX,tEdges.y,tX+Tab::ICON_WH,tEdges.w);
		tX+=Tab::ICON_WH;
	}

	iTab->renderer2D->DrawText(this->name,tX,tEdges.y,tEdges.z,tEdges.w,vec2(0,0.5f),vec2(0,0.5f));
}

void GuiTreeView::DrawItems(Tab* iTab,Item* iItem)
{
	iItem->OnPaint(iTab);

	if(iItem->expanded)
	{
		for(std::list<Gui*>::const_iterator it=iItem->GetChilds().begin();it!=iItem->GetChilds().end();it++)
			DrawItems(iTab,(Item*)*it);
	}
}

void GuiTreeView::OnPaint(Tab* iTab,Event* iData)
{
	iTab->renderer2D->DrawRectangle(this->edges.x,this->edges.y,this->edges.z,this->edges.w,Gui::COLOR_BACK);

	if(this->GetChilds().size())
	{
		this->BeginClip(iTab);
		this->DrawItems(iTab,(Item*)this->GetChilds().front());
		this->EndClip(iTab);
	}

	if(this->vscroll.IsVisible())
		this->vscroll.OnPaint(iTab);

	if(this->hscroll.IsVisible())
		this->hscroll.OnPaint(iTab);
}


void GuiTreeView::OnResize(Tab* iTab,Event* iData)
{
	Gui::OnResize(iTab,iData);
	this->RecalcScrollBars();

	this->leftEdge=this->edges.x + ((this->clippedEdges.z-this->clippedEdges.x) > this->contentWidth ? (this->clippedEdges.z-this->clippedEdges.x) : this->contentWidth);
}

void GuiTreeView::RecalcScrollBars()
{
	float tWidth=this->GetWidth();
	float tHeight=this->GetHeight();

	bool hactive=this->contentWidth>tWidth;
	bool vactive=this->contentHeight>(tHeight - (hactive ? GuiScrollBar::TICK : 0));

	hactive=this->contentWidth>(tWidth - (vactive ? GuiScrollBar::TICK : 0));

	float hclip=tWidth - (vactive ? GuiScrollBar::TICK : 0);
	float vclip=tHeight - (hactive ? GuiScrollBar::TICK : 0);

	vec4 hScrollVec(
		this->edges.x,
		this->edges.w-GuiScrollBar::TICK,
		this->edges.x + hclip,
		this->edges.w
		);

	vec4 vScrollVec(
		this->edges.z-GuiScrollBar::TICK,
		this->edges.y,
		this->edges.z,
		this->edges.y + vclip
		);

	this->hscroll.SetEdges(hScrollVec);
	this->vscroll.SetEdges(vScrollVec);

	this->hscroll.SetRatio(this->contentWidth,hclip);
	this->vscroll.SetRatio(this->contentHeight,vclip);

	float x=this->edges.x + this->hscroll.GetPosition();
	float y=this->edges.y + this->vscroll.GetPosition();

	this->clippedEdges.make(x,
		y,
		x + this->GetWidth() - (this->vscroll.IsVisible() ? GuiScrollBar::TICK : 0),
		y + this->GetHeight() - (this->hscroll.IsVisible() ? GuiScrollBar::TICK : 0)
		);
}

void GuiTreeView::FindItemHovered(Tab* iTab,vec2& iMouse,Item* iItem,Gui*& iGui)
{
	if(iGui)
		return;

	if(iItem->Contains(iMouse))
		iGui=iItem;

	if(iGui)
		return;

	if(iItem->expanded)
	{
		for(std::list<Gui*>::const_iterator it=iItem->GetChilds().begin();it!=iItem->GetChilds().end();it++)
		{
			this->FindItemHovered(iTab,iMouse,(GuiTreeView::Item*)*it,iGui);

			if(iGui)
				return;
		}
	}
}

void GuiTreeView::FindHover(Tab* iTab,vec2& iMouse,Gui*& iGui)
{
	if(this->Contains(iMouse))
		iGui=this;
	if(this->hscroll.Contains(iMouse))
		iGui=&this->hscroll;
	else if(this->vscroll.Contains(iMouse))
		iGui=&this->vscroll;
	else if(this->GetChilds().size())
	{
		Gui* tHover=0;
		this->FindItemHovered(iTab,iMouse,(Item*)this->GetChilds().front(),tHover);
		iGui=tHover;
	}
}

void GuiTreeView::SetContent(GuiTreeView::Item* iLabel,float& iTop,unsigned int iLevel,GuiRoot* iRoot)
{
	iLabel->level=iLevel;
	iLabel->treeview=this;
	iLabel->top=iTop;

	iTop+=Tab::ICON_WH;

	this->SetContentHeight(this->GetContentHeight()+Tab::ICON_WH);

	float tLength=GuiFont::GetDefaultFont()->MeasureText(iLabel->name.c_str()).x;

	{
		tLength+=(iLevel*Tab::ICON_WH)+(iLabel->GetChilds().size() ? Tab::ICON_WH : 0);
		tLength>this->GetContentWidth() ? this->SetContentWidth(tLength) : 0;
	}

	if(iLabel->GetChilds().size())
	{
		if(iLabel->expanded)
		{
			iLevel++;

			for(std::list<Gui*>::const_iterator iterLabel=iLabel->GetChilds().begin();iterLabel!=iLabel->GetChilds().end();iterLabel++)
				this->SetContent((GuiTreeView::Item*)*iterLabel,iTop,iLevel,iRoot);
		}
	}
}

GuiTreeView::GuiTreeView():
	clipped(false),
	hscroll(GuiScrollBar::SCROLLBAR_HORIZONTAL),
	vscroll(GuiScrollBar::SCROLLBAR_VERTICAL)
{
	this->vscroll.SetOwner(this);
	this->hscroll.SetOwner(this);
}

void GuiTreeView::Insert(Item* iParentLabel,Item* iLabel)
{
	iParentLabel ? iParentLabel->AddChild(iLabel) : this->AddChild(iLabel);

	this->RecalcItems();
}


vec2 GuiTreeView::GetClippedMouse(const vec2& iMouse)
{
	return vec2(iMouse.x+this->hscroll.GetPosition(),iMouse.y+this->vscroll.GetPosition());
}

const vec4& GuiTreeView::GetClippedEdges()
{
	return this->clippedEdges;
}

const float GuiTreeView::GetContentWidth()
{
	return this->contentWidth;
}

const float GuiTreeView::GetContentHeight()
{
	return this->contentHeight;
}

void GuiTreeView::SetContentWidth(float iWidth)
{
	this->contentWidth=iWidth;
	this->RecalcScrollBars();
	this->leftEdge = this->edges.x + ((this->clippedEdges.z-this->clippedEdges.x) > this->contentWidth ? (this->clippedEdges.z-this->clippedEdges.x) : this->contentWidth);
}
void GuiTreeView::SetContentHeight(float iHeight)
{
	this->contentHeight=iHeight;
	this->RecalcScrollBars();
}


void GuiTreeView::BeginClip(Tab* iTab)
{
	if(!this->clipped)
	{
		vec4 tClippingRect(
			this->edges.x,
			this->edges.y,
			this->vscroll.IsVisible() ? this->vscroll.GetEdges().x : this->edges.z,
			this->hscroll.IsVisible() ? this->hscroll.GetEdges().y : this->edges.w
			);

		iTab->renderer2D->PushScissor(tClippingRect.x,tClippingRect.y,tClippingRect.z,tClippingRect.w);

		iTab->renderer2D->Translate(-this->hscroll.GetPosition(),-this->vscroll.GetPosition());

		this->clipped=true;
	}
}

void GuiTreeView::EndClip(Tab* iTab)
{
	if(this->clipped)
	{
		iTab->renderer2D->PopScissor();
		iTab->renderer2D->Identity();
		this->clipped=false;
	}
}

void GuiTreeView::RecalcItems()
{
	this->SetContentHeight(0);
	this->SetContentWidth(0);

	float			tTop=Tab::BAR_HEIGHT;
	unsigned int	tLevel=0;

	if(this->GetChilds().size())
		this->SetContent((Item*)this->GetChilds().front(),tTop,tLevel,this->GetRoot());
}



///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////GuiPropertyTree/////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

///////////////////////////////////////////////
//////GuiPropertyTree::Container::Property/////
///////////////////////////////////////////////

GuiPropertyTree::Container::PropertyContainer::PropertyContainer(Property* iProperty):container(0),top(0),property(iProperty){}
GuiPropertyTree::Container::PropertyContainer::PropertyContainer(String iDescription,Property* iProperty):container(0),top(0),description(iDescription),property(iProperty){}

vec4 GuiPropertyTree::Container::PropertyContainer::GetEdges()
{
	return vec4(this->container->propertytree->edges.x,this->top,this->container->propertytree->leftEdge,this->top + (this->property ? this->property->GetHeight() : Tab::ICON_WH));
}

float GuiPropertyTree::Container::PropertyContainer::GetLeadEdge()
{
	return this->container->propertytree->edges.x+this->container->level*Tab::ICON_WH + Tab::ICON_WH;
}

const GuiPropertyTree::Container* GuiPropertyTree::Container::PropertyContainer::GetContainer()
{
	return this->container;
}

void GuiPropertyTree::Container::PropertyContainer::OnResize(Tab* iTab,Event* iData)
{
	if(this->property)
		this->property->OnResize(iTab,iData);
}

void GuiPropertyTree::Container::PropertyContainer::OnPaint(Tab* iTab,Event* iData)
{
	unsigned int tColor=Gui::COLOR_BACK;

	if(this->IsHovering())
		tColor=Blend(tColor,Tab::COLOR_BACK);

	vec4 tEdges=this->GetEdges();
	vec4 tce=this->container->propertytree->GetClippedEdges();

	float tLeft=GetLeadEdge();
	float tItemBottom=this->top+this->GetHeight();
	float tSplitterLeft=tLeft+this->container->splitter;

	//draw background
	iTab->renderer2D->DrawRectangle(tce.x,this->top,tSplitterLeft,tItemBottom,tColor);
	//draw splitter
	iTab->renderer2D->DrawRectangle(tSplitterLeft,this->top,tSplitterLeft+4,tItemBottom,0x202020);
	//draw description
	iTab->renderer2D->DrawText(this->description,tLeft,this->top,tSplitterLeft,tItemBottom,vec2(0,0.5f),vec2(0,0.5f),0xffffff);
	//draw property
	if(this->property)
		this->property->OnPaint(iTab);

	/*//draw line
	iTab->renderer2D->DrawLine(vec2(tEdges.x,tEdges.y),vec2(tEdges.z,tEdges.y),0x000000);*/
}

void GuiPropertyTree::Container::PropertyContainer::OnMouseEnter(Tab* iTab,EventMouse* iData/*=0*/)
{
	Gui::OnMouseEnter(iTab,iData);
	iTab->SetDraw(this);
}

void GuiPropertyTree::Container::PropertyContainer::OnMouseExit(Tab* iTab,EventMouse* iData/*=0*/)
{
	Gui::OnMouseExit(iTab,iData);
	iTab->SetDraw(this);
}

void GuiPropertyTree::Container::PropertyContainer::OnButtonDown(Tab* iTab,EventMouse* iData/*=0*/)
{
	Gui::OnButtonDown(iTab,iData);

	float tPropertyLeft=this->GetLeadEdge();
	float tSplitterLeft= tPropertyLeft+this->container->splitter;

	vec2 tcm=this->container->propertytree->GetClippedMouse(iData->mouse);

	if(tcm.x>tSplitterLeft && tcm.x<tSplitterLeft+4)
	{
		this->container->propertytree->splitterPressed=this->container;
		iTab->SetCursor(1);
	}
}

void GuiPropertyTree::Container::PropertyContainer::FindHover(Tab* iTab,vec2& iMouse,Gui*& iGui)
{
	if(this->Contains(iMouse))
	{
		iGui=this;

		if(iMouse.x > this->container->GetSplitterEdge() && this->property)
			this->property->FindHover(iTab,iMouse,iGui);
	}
};

void GuiPropertyTree::Container::PropertyContainer::OnMouseMove(Tab* iTab,EventMouse* iData)
{
	Container*&			tContainer=this->container;
	GuiPropertyTree*&	tPropTree=tContainer->propertytree;
	
	float tPropertyLeft=this->GetLeadEdge();
	float tSplitterLeft= tPropertyLeft+tContainer->splitter;

	vec2 tClipMouse=tPropTree->GetClippedMouse(iData->mouse);

	if(tPropTree->splitterPressed && tContainer==tPropTree->splitterPressed)
	{
		iTab->SetCursor(1);

		tPropTree->splitterPressed->splitter=tClipMouse.x - tPropertyLeft - 2;

		this->container->GetPropertyTree()->ResizeProperties(iTab,this->container);

		iTab->SetDraw(tPropTree);
	}
	else
	{
		if( tClipMouse.x>tSplitterLeft && tClipMouse.x<tSplitterLeft+4)
			iTab->SetCursor(1);
	}
}

void GuiPropertyTree::Container::PropertyContainer::OnButtonUp(Tab* iTab,EventMouse* iData/*=0*/)
{
	Gui::OnButtonUp(iTab,iData);

	if(this->container->propertytree->splitterPressed)
		this->container->propertytree->splitterPressed=0;
}



void GuiPropertyTree::Container::PropertyContainer::OnBeginClip(Tab* iTab,Event* iData)
{
	this->container->propertytree->BeginClip(iTab);
}

void GuiPropertyTree::Container::PropertyContainer::OnEndClip(Tab* iTab,Event* iData)
{
	this->container->propertytree->EndClip(iTab);
}



///////////////////////////////////////////////
//////GuiPropertyTree::Container::Property////
///////////////////////////////////////////////


GuiPropertyTree::Container::Property::Property():propertyContainer(this){this->propertyContainer.property=this;}
GuiPropertyTree::Container::Property::Property(String iString):propertyContainer(iString,this){}

vec4 GuiPropertyTree::Container::Property::GetEdges()
{
	vec4 tPropertyContainerEdges=this->propertyContainer.GetEdges();

	tPropertyContainerEdges.x+=this->propertyContainer.GetContainer()->GetSplitterEdge();
	//tPropertyContainerEdges.w=tPropertyContainerEdges.y+this->GetHeight();

	return tPropertyContainerEdges;
}

void GuiPropertyTree::Container::Property::FindHover(Tab* iTab,vec2& iMouse,Gui*& iGui)
{
	if(this->Contains(iMouse))
	{
		iGui=this;

		for(std::list<Gui*>::const_iterator it=this->GetChilds().begin();it!=this->GetChilds().end();it++)
			(*it)->FindHover(iTab,iMouse,iGui);
	}
}


void GuiPropertyTree::Container::Property::OnMouseEnter(Tab* iTab,EventMouse* iData)
{
	Gui::OnMouseEnter(iTab,iData);
	iTab->SetDraw(this);
}

void GuiPropertyTree::Container::Property::OnMouseExit(Tab* iTab,EventMouse* iData)
{
	Gui::OnMouseExit(iTab,iData);
	iTab->SetDraw(this);
}

void GuiPropertyTree::Container::Property::OnPaint(Tab* iTab,Event* iData)
{
	unsigned int tColor=Gui::COLOR_BACK;

	if(this->IsHovering())
		tColor=Blend(tColor,Tab::COLOR_BACK);

	vec4 tEdges=this->GetEdges();

	//draw background
	iTab->renderer2D->DrawRectangle(tEdges.x,tEdges.y,tEdges.z,tEdges.w,tColor);

	//draw childs
	for(std::list<Gui*>::const_iterator it=this->GetChilds().begin();it!=this->GetChilds().end();it++)
		GuiHelpers::Broadcast(*it,&Gui::OnPaint,iTab,iData);
}

///////////////////////////////////////////////
//////GuiPropertyTree::Container::Container////
///////////////////////////////////////////////

GuiPropertyTree::Container::Container():expanded(true),propertytree(0),expandedHeight(0),splitter(100){}

vec4 GuiPropertyTree::Container::GetEdges()
{
	return vec4(this->propertytree->edges.x,this->top,this->propertytree->leftEdge,this->top+Tab::ICON_WH);
}

vec4 GuiPropertyTree::Container::GetExpandosEdges()
{
	float	tExpandosLeft=this->GetLeadEdge();

	return vec4(tExpandosLeft,this->top,tExpandosLeft+Tab::ICON_WH,this->top+Tab::ICON_WH);
}

float GuiPropertyTree::Container::GetLeadEdge()const
{
	return this->propertytree->edges.x+this->level*Tab::ICON_WH;
}

float GuiPropertyTree::Container::GetSplitterEdge()const
{
	return this->GetLeadEdge()+Tab::ICON_WH+this->splitter+4;
}

bool GuiPropertyTree::Container::ExpandosContains(const vec2& iMouse)
{
	vec4 tExpandosEdges=this->GetExpandosEdges();

	return iMouse.x>tExpandosEdges.x && iMouse.x<tExpandosEdges.z && iMouse.y>tExpandosEdges.y && iMouse.y<tExpandosEdges.w;
}

void GuiPropertyTree::Container::SetName(String iString)
{
	this->name=iString;
}

bool GuiPropertyTree::Container::IsExpanded()
{
	return this->expanded;
}

GuiPropertyTree::Container* GuiPropertyTree::Container::InsertContainer(Container* iContainer)
{
	this->AddChild(iContainer);

	if(this->propertytree)
		this->propertytree->RecalcItems();

	return iContainer;
}

GuiPropertyTree::Container::Property* GuiPropertyTree::Container::InsertProperty(Property* iProperty)
{
	this->AddChild(&iProperty->propertyContainer);

	if(this->propertytree)
		this->propertytree->RecalcItems();

	return iProperty;
}

GuiPropertyTree* GuiPropertyTree::Container::GetPropertyTree()
{
	return this->propertytree;
}

void GuiPropertyTree::Container::FindHover(Tab* iTab,vec2& iMouse,Gui*& iGui)
{
	if(this->Contains(iMouse))
	{
		iGui=this;
		return;
	}

	for(std::list<Gui*>::const_iterator it=this->GetChilds().begin();it!=this->GetChilds().end();it++)
	{
		(*it)->FindHover(iTab,iMouse,iGui);

		if((*it)==iGui)
			return;
	}
};

void GuiPropertyTree::Container::OnButtonUp(Tab* iTab,EventMouse* iData/*=0*/)
{
	Gui::OnButtonUp(iTab,iData);

	if(iData->button==1)
	{
		vec2 tce=this->propertytree->GetClippedMouse(iData->mouse);
		float tItemLeft=this->GetLeadEdge();

		if(this->GetChilds().size() && tce.x>tItemLeft && tce.x<tItemLeft+Tab::ICON_WH)
		{
			this->expanded=!this->expanded;

			this->OnExpandos(iTab);

			this->propertytree->RecalcItems();

			iTab->SetDraw(this->propertytree);
		}
	}
}

/*
vec4 GuiPropertyTree::Container::GetEdges()
{
	const vec4& tcr=this->propertytree->GetClippedEdges();

	return vec4(tcr.x,this->top,tcr.z,this->top+Tab::ICON_WH);
}
*/

void GuiPropertyTree::Container::OnMouseEnter(Tab* iTab,EventMouse* iData/*=0*/)
{
	Gui::OnMouseEnter(iTab,iData);
	iTab->SetDraw(this);
}

void GuiPropertyTree::Container::OnMouseExit(Tab* iTab,EventMouse* iData/*=0*/)
{
	Gui::OnMouseExit(iTab,iData);
	iTab->SetDraw(this);
}





void GuiPropertyTree::Container::OnBeginClip(Tab* iTab,Event* iData)
{
	this->propertytree->BeginClip(iTab);
}
void GuiPropertyTree::Container::OnEndClip(Tab* iTab,Event* iData)
{
	this->propertytree->EndClip(iTab);
}

void GuiPropertyTree::Container::OnPaint(Tab* iTab,Event* iData)
{
	unsigned int tColor=Gui::COLOR_BACK;

	if(this->IsHovering())
		tColor=Blend(tColor,Tab::COLOR_BACK);

	float tItemBottom=this->top+Tab::ICON_WH;

	vec4 tce=this->propertytree->GetClippedEdges();

	iTab->renderer2D->DrawRectangle(tce.x,this->top,tce.z,tItemBottom,tColor);

	float tX=tce.x + this->level*Tab::ICON_WH;

	if(this->GetChilds().size())
	{
		iTab->renderer2D->DrawBitmap(this->expanded ? iTab->iconDown : iTab->iconRight,tX,this->top,tX+Tab::ICON_WH,tItemBottom);
		tX+=Tab::ICON_WH;
	}

	iTab->renderer2D->DrawText(this->name,tX,this->top,tce.z,tItemBottom,vec2(0,0.5f),vec2(0,0.5f));
}

///////////////////////////////////////////////
//////////////////GuiPropertyTree//////////////
///////////////////////////////////////////////


void GuiPropertyTree::DrawRecursive(Tab* iTab,Gui* iGui)
{
	Container* tContainer=dynamic_cast<Container*>(iGui);

	if(tContainer)
	{
		tContainer->OnPaint(iTab);

		if(tContainer->GetChilds().size() && tContainer->expanded)
		{
			for(std::list<Gui*>::const_iterator it=iGui->GetChilds().begin();it!=iGui->GetChilds().end();it++)
				this->DrawRecursive(iTab,*it);
		}
	}
	else
	{
		Container::PropertyContainer*	tProperty=dynamic_cast<Container::PropertyContainer*>(iGui);

		if(tProperty)
			tProperty->OnPaint(iTab);
		else
			DEBUG_BREAK();
	}
}

void GuiPropertyTree::OnPaint(Tab* iTab,Event* iData)
{
	iTab->renderer2D->DrawRectangle(this->edges.x,this->edges.y,this->edges.z,this->edges.w,Gui::COLOR_BACK);

	if(this->GetChilds().size())
	{
		this->BeginClip(iTab);
			this->DrawRecursive(iTab,this->GetChilds().front());
		this->EndClip(iTab);
	}

	if(this->vscroll.IsVisible())
		this->vscroll.OnPaint(iTab);

	if(this->hscroll.IsVisible())
		this->hscroll.OnPaint(iTab);
}

void GuiPropertyTree::FindHover(Tab* iTab,vec2& iMouse,Gui*& iGui)
{
	if(this->Contains(iMouse))
		iGui=this;
	if(this->hscroll.Contains(iMouse))
		iGui=&this->hscroll;
	else if(this->vscroll.Contains(iMouse))
		iGui=&this->vscroll;
	else if(this->GetChilds().size())
		this->GetChilds().front()->FindHover(iTab,iMouse,iGui);
}

void GuiPropertyTree::ResizeProperties(Tab* iTab,Gui* iGui)
{
	Container* tContainer=dynamic_cast<Container*>(iGui);

	if(tContainer)
	{
		if(tContainer->GetChilds().size() && tContainer->expanded)
		{
			for(std::list<Gui*>::const_iterator iterLabel=iGui->GetChilds().begin();iterLabel!=iGui->GetChilds().end();iterLabel++)
				this->ResizeProperties(iTab,*iterLabel);
		}
	}
	else
	{
		Container::PropertyContainer*	tProperty=dynamic_cast<Container::PropertyContainer*>(iGui);

		if(tProperty)
			tProperty->OnResize(iTab);
		else
			DEBUG_BREAK();
	}
}

void GuiPropertyTree::OnResize(Tab* iTab,Event* iData)
{
	this->RecalcScrollBars();
	this->leftEdge=this->edges.x + ((this->clippedEdges.z-this->clippedEdges.x) > this->contentWidth ? (this->clippedEdges.z-this->clippedEdges.x) : this->contentWidth);
	if(this->GetChilds().size())
		this->ResizeProperties(iTab,this->GetChilds().front());
}

void GuiPropertyTree::RecalcScrollBars()
{
	float tWidth=this->GetWidth();
	float tHeight=this->GetHeight();

	bool hactive=this->contentWidth>tWidth;
	bool vactive=this->contentHeight>(tHeight - (hactive ? GuiScrollBar::TICK : 0));

	hactive=this->contentWidth>(tWidth - (vactive ? GuiScrollBar::TICK : 0));

	float hclip=tWidth - (vactive ? GuiScrollBar::TICK : 0);
	float vclip=tHeight - (hactive ? GuiScrollBar::TICK : 0);

	vec4 hScrollVec(
		this->edges.x,
		this->edges.w-GuiScrollBar::TICK,
		this->edges.x + hclip,
		this->edges.w
		);

	vec4 vScrollVec(
		this->edges.z-GuiScrollBar::TICK,
		this->edges.y,
		this->edges.z,
		this->edges.y + vclip
		);

	this->hscroll.SetEdges(hScrollVec);
	this->vscroll.SetEdges(vScrollVec);

	this->hscroll.SetRatio(this->contentWidth,hclip);
	this->vscroll.SetRatio(this->contentHeight,vclip);

	float x=this->edges.x + this->hscroll.GetPosition();
	float y=this->edges.y + this->vscroll.GetPosition();

	this->clippedEdges.make(x,
		y,
		x + this->GetWidth() - (this->vscroll.IsVisible() ? GuiScrollBar::TICK : 0),
		y + this->GetHeight() - (this->hscroll.IsVisible() ? GuiScrollBar::TICK : 0)
		);
}

void GuiPropertyTree::SetContent(Gui* iParent,Gui* iGui,float& iTop,unsigned int iLevel,GuiRoot* iRoot)
{
	Container* tContainer=dynamic_cast<Container*>(iGui);

	if(tContainer)
	{
		tContainer->top=iTop;
		tContainer->level=iLevel;
		tContainer->propertytree=this;
		tContainer->expandedHeight=0;

		iTop+=Tab::ICON_WH;

		this->SetContentHeight(this->GetContentHeight()+Tab::ICON_WH);

		float tLength=GuiFont::GetDefaultFont()->MeasureText(tContainer->name.c_str()).x;

		{
			tLength+=(iLevel*Tab::ICON_WH)+(iGui->GetChilds().size() ? Tab::ICON_WH : 0);
			tLength>this->GetContentWidth() ? this->SetContentWidth(tLength) : 0;
		}

		if(tContainer->GetChilds().size())
		{
			if(tContainer->expanded)
			{
				iLevel++;

				for(std::list<Gui*>::const_iterator iterLabel=iGui->GetChilds().begin();iterLabel!=iGui->GetChilds().end();iterLabel++)
					this->SetContent(iGui,*iterLabel,iTop,iLevel,iRoot);
			}
		}
	}
	else
	{
		Container::PropertyContainer*	tProperty=dynamic_cast<Container::PropertyContainer*>(iGui);
		Container*				tContainer=dynamic_cast<Container*>(iParent);

		if(tProperty && tContainer)
		{
			tProperty->top=iTop;
			tProperty->container=tContainer;

			float tPropertyHeight=tProperty->GetHeight();

			iTop+=tPropertyHeight;
			tContainer->expandedHeight+=tPropertyHeight;

			this->SetContentHeight(this->GetContentHeight()+tPropertyHeight);

			tProperty->OnResize(iRoot->GetTab());
		}
		else
			DEBUG_BREAK();
	}
}

GuiPropertyTree::GuiPropertyTree():
clipped(false),
	hscroll(GuiScrollBar::SCROLLBAR_HORIZONTAL),
	vscroll(GuiScrollBar::SCROLLBAR_VERTICAL),
	splitterPressed(0)
{
	this->vscroll.SetOwner(this);
	this->hscroll.SetOwner(this);
}

GuiPropertyTree::Container* GuiPropertyTree::InsertContainer(Container* iParentLabel,Container* iLabel)
{
	iParentLabel ? iParentLabel->AddChild(iLabel) : this->AddChild(iLabel);
	this->RecalcItems();
	return iLabel;
}


vec2 GuiPropertyTree::GetClippedMouse(const vec2& iMouse)
{
	return vec2(iMouse.x+this->hscroll.GetPosition(),iMouse.y+this->vscroll.GetPosition());
}

const vec4& GuiPropertyTree::GetClippedEdges()
{
	return this->clippedEdges;
}

const float GuiPropertyTree::GetContentWidth()
{
	return this->contentWidth;
}

const float GuiPropertyTree::GetContentHeight()
{
	return this->contentHeight;
}

void GuiPropertyTree::SetContentWidth(float iWidth)
{
	this->contentWidth=iWidth;
	this->RecalcScrollBars();
	this->leftEdge=this->edges.x + ((this->clippedEdges.z-this->clippedEdges.x) > this->contentWidth ? (this->clippedEdges.z-this->clippedEdges.x) : this->contentWidth);
}
void GuiPropertyTree::SetContentHeight(float iHeight)
{
	this->contentHeight=iHeight;
	this->RecalcScrollBars();
}


void GuiPropertyTree::BeginClip(Tab* iTab)
{
	if(!this->clipped)
	{
		vec4 tClippingRect(
			this->edges.x,
			this->edges.y,
			this->vscroll.IsVisible() ? this->vscroll.GetEdges().x : this->edges.z,
			this->hscroll.IsVisible() ? this->hscroll.GetEdges().y : this->edges.w
			);

		iTab->renderer2D->PushScissor(tClippingRect.x,tClippingRect.y,tClippingRect.z,tClippingRect.w);

		iTab->renderer2D->Translate(-this->hscroll.GetPosition(),-this->vscroll.GetPosition());

		this->clipped=true;
	}
}

void GuiPropertyTree::EndClip(Tab* iTab)
{
	if(this->clipped)
	{
		iTab->renderer2D->PopScissor();
		iTab->renderer2D->Identity();
		this->clipped=false;
	}
}

void GuiPropertyTree::RecalcItems()
{
	this->SetContentHeight(0);
	this->SetContentWidth(0);

	float			tTop=this->edges.y;
	unsigned int	tLevel=0;

	this->SetContent(0,this->childs.front(),tTop,tLevel,GetRoot());
}





///////////////////////////////////////////////
///////////////////////////////////////////////
/////////////////////GuiViewer/////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

///////////////////////////////////////////////
///////////////////////////////////////////////
/////////////////GuiContainer//////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

GuiContainer::GuiContainer():expanded(false)
{
	this->edges.w=20;
}

GuiContainer::GuiContainer(String iString):expanded(false),description(iString)
{
	this->edges.w=20;
}

void GuiContainer::Insert(Gui* iGui)
{
	this->AddChild(iGui);
}

void GuiContainer::OnPaint(Tab* iTab,Event* iData)
{
	iTab->renderer2D->DrawRectangle(this->edges.x,this->edges.y,this->edges.z,this->edges.w,Gui::COLOR_BACK);	

	float tX=this->edges.x;

	if(this->childs.size())
	{
		iTab->renderer2D->DrawBitmap(this->expanded ? iTab->iconDown : iTab->iconRight,tX,this->edges.y,tX+Tab::ICON_WH,this->edges.w);
		tX+=Tab::ICON_WH;
	}

	iTab->renderer2D->DrawText(this->description,tX,this->edges.y,this->edges.z,this->edges.w,vec2(0,0.5f),vec2(0,0.5f),0xffffff);	

	if(this->childs.size() && this->expanded)
	{
		for(std::list<Gui*>::iterator it=this->childs.begin();it!=this->childs.end();it++)
			(*it)->OnPaint(iTab);
	}
}


void GuiContainer::OnResize(Tab* iTab,Event* iData)
{
	Gui::OnResize(iTab,iData);

	if(this->childs.size())
		for(std::list<Gui*>::iterator it=this->childs.begin();it!=this->childs.end();it++)
		{
			vec4 tNewSize(this->edges.x + Tab::ICON_WH,(*it)->GetEdges().y,this->edges.z,(*it)->GetEdges().w);
			(*it)->SetEdges(tNewSize);
		}
}

void GuiContainer::OnButtonDown(Tab* iTab,EventMouse* iData/*=0*/)
{
	
}

///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////////StringValue///////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

StringProperty::StringProperty(String iDescription,void* iValuePointer1,unsigned int iValueType,void* iValuePointer2,unsigned int iValueParameter1,unsigned int iValueParameter2):
	Property(iDescription),
	valuePointer1(iValuePointer1),
	valuePointer2(iValuePointer2),
	valueType(iValueType),
	valueParameter1(iValueParameter1),
	valueParameter2(iValueParameter2)
{
}

float StringProperty::GetHeight(){return 20;}
bool StringProperty::HasDescription(){return true;}

void StringProperty::OnPaint(Tab* iTab,Event* iData)
{
	Property::OnPaint(iTab,iData);

	const unsigned int ctMaxTmpArraySize=256;

	vec4 tEdges=this->GetEdges();
	String tValue;

	switch(this->valueType)
	{
	case StringProperty::BOOL:
		{
			bool& tBool=*(bool*)this->valuePointer1;

			tValue=tBool ? L"True" : L"False";
		}
		break;
	case StringProperty::STRING:
		{
			String& tString=*(String*)this->valuePointer1;

			tValue=tString;
		}
		break;
	case StringProperty::BOOLPTR:
		{
			void* pRef=*(void**)this->valuePointer1;

			tValue=pRef ? L"True" : L"False";
		}
		break;
	case StringProperty::INT:
		{
			int& tInt=*(int*)this->valuePointer1;

			wchar_t tCharInt[ctMaxTmpArraySize];
			swprintf(tCharInt,L"%d",tInt);

			tValue=tCharInt;
		}
		break;
	case StringProperty::FLOAT:
		{
			float& tFloat=*(float*)this->valuePointer1;

			//https://stackoverflow.com/questions/16413609/printf-variable-number-of-decimals-in-float

			wchar_t tCharFloat[ctMaxTmpArraySize];
			swprintf(tCharFloat,L"%*.*f",this->valueParameter1,this->valueParameter2,tFloat);

			tValue=tCharFloat;
		}
		break;
	case StringProperty::VEC2:
		{
			vec2& tVec2=*(vec2*)this->valuePointer1;

			wchar_t tCharVec2[ctMaxTmpArraySize];
			swprintf(tCharVec2,L"%*.*f , %*.*f",this->valueParameter1,this->valueParameter2,tVec2.x,this->valueParameter1,this->valueParameter2,tVec2.y);

			tValue=tCharVec2;
		}
		break;
	case StringProperty::VEC3:
		{
			vec3& tVec3=*(vec3*)this->valuePointer1;

			wchar_t tCharVec3[ctMaxTmpArraySize];
			swprintf(tCharVec3,L"%*.*f , %*.*f , %*.*f",	this->valueParameter1,this->valueParameter2,tVec3.x,
				this->valueParameter1,this->valueParameter2,tVec3.y,
				this->valueParameter1,this->valueParameter2,tVec3.z);

			tValue=tCharVec3;
		}
		break;
	case StringProperty::VEC4:
		{
			vec4& tVec4=*(vec4*)this->valuePointer1;

			wchar_t tCharVec4[ctMaxTmpArraySize];
			swprintf(tCharVec4,L"%*.*f , %*.*f , %*.*f , %*.*f",	this->valueParameter1,this->valueParameter2,tVec4.x,
				this->valueParameter1,this->valueParameter2,tVec4.y,
				this->valueParameter1,this->valueParameter2,tVec4.z,
				this->valueParameter1,this->valueParameter2,tVec4.w);

			tValue=tCharVec4;
		}
		break;
	case StringProperty::PTR:
		{
			wchar_t tCharPointer[ctMaxTmpArraySize];
			swprintf(tCharPointer,L"0x%p",this->valuePointer1);

			tValue=tCharPointer;
		}
		break;
	case StringProperty::MAT4POS:
		{
			mat4& tMat4=*(mat4*)this->valuePointer1;

			vec3 tPosition=tMat4.position();

			wchar_t tCharVec3[ctMaxTmpArraySize];
			swprintf(tCharVec3,L"%*.*f , %*.*f , %*.*f",	this->valueParameter1,this->valueParameter2,tPosition.x,
				this->valueParameter1,this->valueParameter2,tPosition.y,
				this->valueParameter1,this->valueParameter2,tPosition.z);

			tValue=tCharVec3;
		}
		break;
	case StringProperty::ENTITYLISTSIZE:
		{
			std::list<Entity*>& tEntityVec=*(std::list<Entity*>*)this->valuePointer1;

			size_t tCount=tEntityVec.size();

			wchar_t tCharVecSize[10];
			swprintf(tCharVecSize,L"%d",tCount);

			tValue=tCharVecSize;
		}
		break;
	case StringProperty::VEC3VECSIZE:
		{
			std::vector<vec3>& tVec3Vector=*(std::vector<vec3>*)this->valuePointer1;

			size_t tCount=tVec3Vector.size();

			wchar_t tCharVecSize[10];
			swprintf(tCharVecSize,L"%d",tCount);

			tValue=tCharVecSize;
		}
		break;
	case StringProperty::VEC3LISTSIZE:
		{
			std::list<vec3>& tVec3List=*(std::list<vec3>*)this->valuePointer1;

			size_t tCount=tVec3List.size();

			wchar_t tCharVecSize[10];
			swprintf(tCharVecSize,L"%d",tCount);

			tValue=tCharVecSize;
		}
		break;
	case StringProperty::ANIMATIONVECSIZE:
		{
			std::vector<Animation*>& tAnimationVec=*(std::vector<Animation*>*)this->valuePointer1;

			size_t tCount=tAnimationVec.size();

			wchar_t tCharVecSize[10];
			swprintf(tCharVecSize,L"%d",tCount);

			tValue=tCharVecSize;
		}
		break;
	case StringProperty::ISBONECOMPONENT:
		{
			Entity* tEntity=(Entity*)this->valueParameter1;

			tValue=L"must implement in GuiStringValue::ISBONECOMPONENT";
		}
		break;
	case StringProperty::FLOAT2MINUSFLOAT1:
		{
			float& a=*(float*)this->valuePointer1;
			float& b=*(float*)this->valuePointer2;

			wchar_t tCharFloatMinusOp[20];
			swprintf(tCharFloatMinusOp,L"%*.*g",this->valueParameter1,this->valueParameter2,b-a);

			tValue=tCharFloatMinusOp;
		}
		break;
	case StringProperty::VEC32MINUSVEC31:
		{
			vec3& a=*(vec3*)this->valuePointer1;
			vec3& b=*(vec3*)this->valuePointer2;

			vec3 tVecResult=b-a;

			wchar_t tCharVec3[ctMaxTmpArraySize];
			swprintf(tCharVec3,L"%*.*g , %*.*g , %*.*g",	this->valueParameter1,this->valueParameter2,tVecResult.x,
				this->valueParameter1,this->valueParameter2,tVecResult.y,
				this->valueParameter1,this->valueParameter2,tVecResult.z);

			tValue=tCharVec3;
		}
		break;
	default:
		tValue=L"GuiStringValue Must Implement";
	}

	iTab->renderer2D->DrawText(tValue,tEdges.x,tEdges.y,tEdges.z,tEdges.w,vec2(0,0.5f),vec2(0,0.5f),0xffffff,GuiFont::GetDefaultFont());
}
///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////////GuiString///////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

GuiString::GuiString():align(0.0f,0.5f),spot(0.0f,0.5f),color(GuiString::COLOR_TEXT),font((GuiFont*)GuiFont::GetDefaultFont()){}

void GuiString::OnPaint(Tab* iTab,Event* iData)
{
	iTab->renderer2D->DrawText(this->text,this->edges.x,this->edges.y,this->edges.z,this->edges.w,this->spot,this->align,this->color,this->font);
}

///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////////GuiString///////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////


///////////////////////////////////////////////
///////////////////////////////////////////////
////////////////////GuiListBox////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////


namespace GuiListBoxHelpers
{
	void OnItemPressed(void*);
}

GuiListBox::GuiListBox():selection(0)
{
}

void GuiListBox::DestroyItems()
{
}

void GuiListBox::AddItem(void* iValuePointer1,unsigned int iValueType,void* iValuePointer2,unsigned int iValueParameter1,unsigned int iValueParameter2)
{
}

void GuiListBox::AddItem(String iString)
{
}


GuiListBox::~GuiListBox()
{
}

void GuiListBoxHelpers::OnItemPressed(void* iData)
{
}

///////////////////////////////////////////////
///////////////////////////////////////////////
////////////////////GuiComboBox////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

void pfdGuiComboBoxLabelsButtonAction(Event* iData)
{
}


void pfdGuiComboBoxDownButtonAction(Event* iData)
{
	
}

void GuiComboBox::RecreateList()
{
}

GuiComboBox::GuiComboBox():selectedItem(0),list(0),popupPointer(0)
{
}

GuiComboBox::~GuiComboBox()
{
}

///////////////////////////////////////////////
///////////////////////////////////////////////
////////////////////GuiImage///////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

GuiImage::GuiImage():image(0){}
GuiImage::GuiImage(unsigned char* iRefData,float iWidth,float iHeight):image(new PictureRef(iRefData,iWidth,iHeight)){}
GuiImage::GuiImage(String iFilename):image(new PictureFile(iFilename)){}

GuiImage::~GuiImage()
{
	SAFEDELETE(this->image);
}

void GuiImage::OnPaint(Tab* iTab,Event* iData)
{
}

void GuiImage::OnActivate(Tab* iTab,Event* iData)
{
}

///////////////////////////////////////////////
///////////////////////////////////////////////
////////////////////GuiTextBox/////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////
GuiTextBox::GuiTextBox():cursor(0){}

GuiTextBox::~GuiTextBox(){SAFEDELETE(this->cursor);}


bool GuiTextBox::ParseKeyInput(Tab* iTab,Event* iData)
{
	StringEditor&	tStringEditor=*Ide::GetInstance()->stringEditor;

	bool			tRedraw=false;

	if(tStringEditor.Binded()==this && tStringEditor.Enabled())
	{
		unsigned int	tCaretOperation=tStringEditor.CARET_DONTCARE;
		void*			tCaretParameter=0;

		if(iData)
		{
			switch(*(char*)iData)
			{
			case 0x08:/*VK_BACK*/tCaretOperation=tStringEditor.CARET_BACKSPACE; break;
			default:
				tCaretOperation=tStringEditor.CARET_ADD;
				tCaretParameter=(char*)iData;
			}
		}
		else
		{
			if(InputManager::keyboardInput.IsPressed(0x25/*VK_LEFT*/))
				tCaretOperation=tStringEditor.CARET_ARROWLEFT;
			if(InputManager::keyboardInput.IsPressed(0x27/*VK_RIGHT*/))
				tCaretOperation=tStringEditor.CARET_ARROWRIGHT;
			if(InputManager::keyboardInput.IsPressed(0x26/*VK_UP*/))
				tCaretOperation=tStringEditor.CARET_ARROWUP;
			if(InputManager::keyboardInput.IsPressed(0x28/*VK_DOWN*/))
				tCaretOperation=tStringEditor.CARET_ARROWDOWN;
			if(InputManager::keyboardInput.IsPressed(0x03/*VK_CANCEL*/))
				tCaretOperation=tStringEditor.CARET_CANCEL;
			if(InputManager::keyboardInput.IsPressed(0x2E/*VK_DELETE*/))
				tCaretOperation=tStringEditor.CARET_CANCEL;
			if(InputManager::keyboardInput.IsPressed(0x1B/*VK_ESCAPE*/)) 
			{
				tStringEditor.Enable(false);
				return false;
			}
		}

		tRedraw=true;

		bool tMustResize=tStringEditor.EditText(tCaretOperation,tCaretParameter);
	}

	return tRedraw;
}

void GuiTextBox::OnKeyDown(Tab* iTab, Event* iData)
{
	if(this==iTab->GetFocus())
	{
		StringEditor& tStringEditor=*Ide::GetInstance()->stringEditor;

		if(InputManager::keyboardInput.IsPressed(0x71/*VK_F2*/))
		{
			tStringEditor.Bind(this);
			tStringEditor.Enable(true);
		}
		else if(InputManager::keyboardInput.IsPressed(0x1B/*VK_ESCAPE*/))
		{
			tStringEditor.Bind(0);
			tStringEditor.Enable(false);

		}

		bool tRedraw=false;

		if(tStringEditor.Binded()==this && tStringEditor.Enabled())
			tRedraw=this->ParseKeyInput(iTab);

		if(tRedraw)
			iTab->SetDraw(this);
	}

	Gui::OnKeyDown(iTab,iData);
}


void GuiTextBox::OnLMouseDown(Tab* iTab,EventMouse* iData)
{
	iTab->SetFocus(this);

	Gui::OnButtonDown(iTab,iData);
}

void GuiTextBox::OnPaint(Tab* iTab,Event* iData)
{
}



///////////////////////////////////////////////
///////////////////////////////////////////////
////////////////////GuiButton//////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

GuiButton::GuiButton():func(0),param(0),value(0),mode(-1){}

void GuiButton::OnButtonUp(Tab* iTab,EventMouse* iData/*=0*/)
{
	GuiString::OnButtonUp(iTab,iData);

	if(this->value)
	{
		switch(this->mode)
		{
		case -1:	*value=!*value; break;
		case 0:		*value=false;  break;
		case 1:		*value=true;	  break;
		}
	}

	/*if(this->func)
		this->func(this->param);*/

	iTab->SetDraw(this);
}

void GuiButton::OnMouseEnter(Tab* iTab,EventMouse* iData)
{
	Gui::OnMouseEnter(iTab,iData);
	iTab->SetDraw(this);
}

void GuiButton::OnMouseExit(Tab* iTab,EventMouse* iData)
{
	Gui::OnMouseExit(iTab,iData);
	iTab->SetDraw(this);
}

void GuiButton::OnButtonDown(Tab* iTab,EventMouse* iData)
{
	Gui::OnButtonDown(iTab,iData);
	iTab->SetDraw(this);
}

void GuiButton::OnPaint(Tab* iTab,Event* iData)
{
	unsigned int tColor=Gui::COLOR_BACK;

	if(this->IsHovering())
		tColor=Blend(tColor,Tab::COLOR_BACK);
	if(this->IsPressing())
		tColor=Blend(tColor,Tab::COLOR_BACK+0x101010);

	iTab->renderer2D->DrawRectangle(this->edges.x,this->edges.y,this->edges.z,this->edges.w,tColor);

	if(this->text.size())
		iTab->renderer2D->DrawText(this->text,this->edges.x,this->edges.y,this->edges.z,this->edges.w,vec2(0.5f,0.5f),vec2(0.5f,0.5f),0xffffff);
}


///////////////////////////////////////////////
///////////////////////////////////////////////
/////////////GuiPath////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

namespace GuiPathHelpers
{
	void OnSelectDirectoryButtonPressed(Event* iData);
}

GuiPath::GuiPath():func(0),param(0)
{
}

GuiPath::~GuiPath()
{

}

void GuiPathHelpers::OnSelectDirectoryButtonPressed(Event* iData)
{
}


///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////////GuiSlider///////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

GuiSlider::GuiSlider(float* iRef,float* iMin,float* iMax):referenceValue(iRef),minimum(iMin),maximum(iMax){}

void GuiSlider::OnPaint(Tab* iTab,Event* iData)
{
	vec4 tEdges=this->GetEdges();

	float		tWidth=this->GetWidth();
	float		tHeight=this->GetHeight();

	if(this->minimum && this->maximum && this->referenceValue)
	{
		iTab->renderer2D->DrawRectangle(tEdges.x+10,tEdges.y+tHeight/2.0f-2,tEdges.z-10,tEdges.y+tHeight/2.0f+2,0x000000);

		float tMinimum=*this->minimum;

		String smin(StringUtils::Float(*this->minimum));
		String smax(StringUtils::Float(*this->maximum));
		String value(StringUtils::Float(*this->referenceValue));

		iTab->renderer2D->DrawText(smin,tEdges.x+10,tEdges.y,tEdges.x+tWidth/2,tEdges.y+10,vec2(0,0.5f),vec2(0,0.5f),GuiString::COLOR_TEXT);
		iTab->renderer2D->DrawText(smax,tEdges.x+tWidth/2,tEdges.y,tEdges.z-10,tEdges.y+10,vec2(1,0.5f),vec2(1.0f,0.5f),GuiString::COLOR_TEXT);
		iTab->renderer2D->DrawText(value,tEdges.x,tEdges.y+20,tEdges.z,tEdges.w,vec2(0.5f,0.5f),vec2(0.5f,0.5f),GuiString::COLOR_TEXT);

		float tip=(tEdges.x+10) + ((*referenceValue)/(*maximum-*minimum))*(tWidth-20);

		iTab->renderer2D->DrawRectangle(tip-5,tEdges.y+tHeight/2.0f-5,tip+5,tEdges.y+tHeight/2.0f+5,GuiString::COLOR_TEXT);
	}
}


void GuiSlider::OnMouseMove(Tab* iTab,EventMouse* iData)
{
	if(this->IsPressing() && this->minimum && this->maximum && this->referenceValue)
	{
		vec4 tEdges=this->GetEdges();

		float		tWidth=tEdges.z-tEdges.x;
		float		tHeight=tEdges.w-tEdges.y;

		if(iData->mouse.x > tEdges.x && iData->mouse.x < tEdges.z)
		{
			float f1=(iData->mouse.x-(tEdges.x+10))/(tWidth-20);
			float f2=*maximum-*minimum;
			float cursor=f1*f2;

			cursor = cursor<*minimum ? *minimum : (cursor>*maximum ? *maximum : cursor);

			if(*referenceValue!=cursor)
			{
				*referenceValue=cursor;
				iTab->SetDraw(this->parent);
			}
		}
	}
}

SliderProperty::SliderProperty(String iDescription,float* iRef,float* iMin,float* iMax):Property(iDescription),slider(iRef,iMin,iMax)
{
	this->AddChild(&this->slider);
}

float SliderProperty::GetHeight(){return 30;}

void SliderProperty::OnResize(Tab* iTab,Event* iData)
{
	this->slider.SetEdges(this->GetEdges());
}
///////////////////////////////////////////////
///////////////////////////////////////////////
///////////GuiAnimationController//////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

namespace GuiAnimationControllerHelper
{
	void OnButtonPressed(Event* iData);
}

void GuiAnimationControllerHelper::OnButtonPressed(Event* iData)
{
	AnimationProperty* tGuiAnimContr=(AnimationProperty*)iData;

	if(tGuiAnimContr->animationController.play)
		tGuiAnimContr->animationController.Play();
	else
		tGuiAnimContr->animationController.Stop();
}

AnimationProperty::AnimationProperty(String iDescription,AnimationController& iAnimationController):
	Property(iDescription),
	animationController(iAnimationController),
	slider(&animationController.cursor,&this->animationController.start,&this->animationController.end)
{
	this->play.value=&this->animationController.play;
	this->stop.value=&this->animationController.play;

	this->play.func=GuiAnimationControllerHelper::OnButtonPressed;
	this->play.param=this;

	this->stop.func=GuiAnimationControllerHelper::OnButtonPressed;
	this->stop.param=this;

	this->play.mode=1;
	this->stop.mode=0;

	this->play.text=L"Play";
	this->stop.text=L"Stop";

	this->AddChild(&this->slider);
	this->AddChild(&this->play);
	this->AddChild(&this->stop);
}

float AnimationProperty::GetHeight(){return 50;}
bool AnimationProperty::HasDescription(){return true;}

void AnimationProperty::OnResize(Tab* iTab,Event* iData)
{
	vec4  tEdges=this->GetEdges();
	float tWidth=tEdges.z-tEdges.x;
	float tHeight=tEdges.w-tEdges.y;

	vec4 tSliderEdges(tEdges.x,tEdges.y,tEdges.z,tEdges.y+30);

	vec4 tStopButtonEdges(tEdges.x,
		tEdges.y+30,
		tEdges.x+tWidth/2,
		tEdges.y+this->GetHeight()
		);

	vec4 tPlayButtonEdges(tEdges.x+tWidth/2,
		tEdges.y+30,
		tEdges.z,
		tEdges.y+this->GetHeight()
		);

	this->slider.SetEdges(tSliderEdges);
	this->stop.SetEdges(tStopButtonEdges);
	this->play.SetEdges(tPlayButtonEdges);
}


///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////////GuiViewport/////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

void launchStopGuiViewportCallback(Event* iData)
{
	GuiViewport* guiViewport=(GuiViewport*)iData;
}

#define INITLIST \
	renderBuffer(0), \
	rootEntity(0), \
	needsPicking(0), \
	pickedEntity(0), \
	playStopButton(0), \
	renderDrawInstance(0), \
	renderFps(60), \
	renderBitmap(0)

void GuiViewportInitFunc(GuiViewport* iGuiViewport)
{
	GlobalViewports().push_back(iGuiViewport);

	iGuiViewport->playStopButton=new GuiButton;
	
	iGuiViewport->playStopButton->func=launchStopGuiViewportCallback;
	iGuiViewport->playStopButton->param=iGuiViewport;
	iGuiViewport->playStopButton->text=L"Run";
}

std::list<GuiViewport*>& GuiViewport::GetPool()
{
	return GlobalViewports();
}

GuiViewport::GuiViewport():INITLIST
{
	GuiViewportInitFunc(this);
}

GuiViewport::GuiViewport(vec3 pos,vec3 target,vec3 up,bool perspective):INITLIST
{
	GuiViewportInitFunc(this);

	this->projection= !perspective ? this->projection : this->projection.perspective(90,16/9,1,1000);
	this->view.move(pos);
	this->view.lookat(target,up);
}

void GuiViewport::OnResize(Tab* iTab,Event* iData)
{
}

void GuiViewport::OnPaint(Tab* iTab,Event* iData)
{
}

void GuiViewport::OnMouseWheel(Tab* iTab,EventMouse* iData/*=0*/)
{
}

void GuiViewport::OnButtonUp(Tab* iTab,EventMouse* iData/*=0*/)
{
}

void GuiViewport::OnMouseMove(Tab* iTab,EventMouse* iData/*=0*/)
{
}


void GuiViewport::OnActivate(Tab* iTab,Event* iData)
{
}

void GuiViewport::OnDeactivate(Tab* iTab,Event* iData)
{
}

void GuiViewport::OnReparent(Tab* iTab,Event* iData)
{
}

///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////////GuiScrollBar////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

GuiScrollBar::GuiScrollBar(ScrollBarType iScrollbarType):
	scrollbarType(iScrollbarType),
	scrollerPressed(-1),
	position(0),
	ratio(1)
{
}
GuiScrollBar::~GuiScrollBar()
{

}


void GuiScrollBar::SetType(ScrollBarType iScrollbarType)
{
	this->scrollbarType=iScrollbarType;
}

void GuiScrollBar::SetRatio(float iContentLength,float iContainerLength)
{
	float tOldScrollerContainerLength=this->GetContainerLength();

	this->contentLength=iContentLength;
	this->containerLength=iContainerLength;

	float tNewScrollerContainerLength=this->GetContainerLength();

	this->ratio = (iContentLength<iContainerLength) ? 1.0f : iContainerLength/iContentLength;

	this->SetPosition(this->position/(tNewScrollerContainerLength/tOldScrollerContainerLength));
}

void GuiScrollBar::SetPosition(float positionPercent)
{
	float oldScrollerPosition=this->position;

	float scrollerContainerLength=this->GetContainerLength();
	float scrollerLength=this->GetScrollerLength();

	if((positionPercent+ratio)>1)
		this->position=(scrollerContainerLength-scrollerLength)/scrollerContainerLength;
	else
		this->position = positionPercent < 0 ? 0 : positionPercent;
}

float GuiScrollBar::GetPosition()
{
	switch(this->scrollbarType)
	{
	case ScrollBarType::SCROLLBAR_VERTICAL:
		return this->position*(this->contentLength);
		break;
	case ScrollBarType::SCROLLBAR_HORIZONTAL:
		return this->position*(this->contentLength);
		break;
	default:
		return 0;
	}
	
}

void GuiScrollBar::Scroll(Tab* tabContainer,float upOrDown)
{
	float rowHeightRatio=this->ratio/GuiScrollBar::TICK;

	float amount=this->position + (upOrDown<0 ? rowHeightRatio : -rowHeightRatio);

	this->SetPosition(amount);
}

bool GuiScrollBar::IsVisible()
{
	return this->ratio<1.0f;
}

float GuiScrollBar::GetContainerLength()
{
	return	this->scrollbarType==SCROLLBAR_VERTICAL ? 
	(this->edges.w-this->edges.y)-(2.0f*TICK) :
	(this->edges.z-this->edges.x)-(2.0f*TICK);
}
float GuiScrollBar::GetScrollerBegin()
{
	return this->GetContainerBegin()+this->position*this->GetContainerLength();
}
float GuiScrollBar::GetScrollerEnd()
{
	return this->GetScrollerBegin()+this->ratio*this->GetContainerLength();
}
float GuiScrollBar::GetScrollerLength()
{
	return this->GetScrollerEnd()-this->GetScrollerBegin();
}
float GuiScrollBar::GetContainerBegin()
{
	return	this->scrollbarType==SCROLLBAR_VERTICAL ? 
	this->edges.y+TICK :
	this->edges.x+TICK;
}
float GuiScrollBar::GetContainerEnd()
{
	return	this->scrollbarType==SCROLLBAR_VERTICAL ? 
	this->edges.w-TICK :
	this->edges.z-TICK;
}

void GuiScrollBar::OnButtonUp(Tab* iTab,EventMouse* iData/*=0*/)
{
	Gui::OnButtonUp(iTab,iData);

	if(iData->button==1)
	{
		this->scrollerPressed=-1;
	}
}

void GuiScrollBar::OnButtonDown(Tab* iTab,EventMouse* iData/*=0*/)
{
	Gui::OnButtonDown(iTab,iData);

	if(ratio==1.0f)
		return;

	if(iData->button==1)
	{
		float& tTreshold=this->scrollbarType==SCROLLBAR_VERTICAL ? iData->mouse.y : iData->mouse.x;

		if(tTreshold<this->GetContainerBegin())
		{
			this->Scroll(iTab,1);
		}
		else if(tTreshold<this->GetContainerEnd())
		{
			this->scrollerPressed=0;

			if(tTreshold>=this->GetScrollerBegin() && tTreshold<=this->GetScrollerEnd())
				this->scrollerPressed=((tTreshold-this->GetScrollerBegin())/this->GetScrollerLength())*this->ratio;
			else
				SetPosition((tTreshold-this->GetContainerBegin())/this->GetContainerLength());
		}
		else
		{
			this->Scroll(iTab,-1);
		}

		Gui* tOwner=this->GetOwner();

		if(tOwner)
		{
			//tOwner->OnSizeRecursive(GuiSizeEvent(iTab,tOwner->GetEdges()));
			iTab->SetDraw(tOwner);
		}
	}
}

void GuiScrollBar::OnMouseMove(Tab* iTab,EventMouse* iData/*=0*/)
{
	if(this->IsPressing())
	{
		vec2& mouse=*(vec2*)iData;
		float& tTreshold=this->scrollbarType==SCROLLBAR_VERTICAL ? mouse.y : mouse.x;

		if(tTreshold>this->GetContainerBegin() && tTreshold<this->GetContainerEnd())
		{
			float mouseContainerTreshold=(tTreshold-this->GetContainerBegin())/this->GetContainerLength();

			this->SetPosition(mouseContainerTreshold-this->scrollerPressed);

			Gui* tOwner=this->GetOwner();

			if(tOwner)
			{
				iTab->SetDraw(tOwner);
			}
		}
	}
}

void GuiScrollBar::OnPaint(Tab* iTab,Event* iData)
{
	if(this->scrollbarType==SCROLLBAR_VERTICAL)
	{
		iTab->renderer2D->DrawRectangle(this->edges.x,this->edges.y,this->edges.x+TICK,this->edges.y+TICK,GuiScrollBar::COLOR_BACK);
		iTab->renderer2D->DrawRectangle(this->edges.x,this->edges.y,this->edges.x+TICK,this->edges.y+TICK,0x00000000,false);
		iTab->renderer2D->DrawRectangle(this->edges.x,this->edges.w-TICK,this->edges.x+TICK,this->edges.w,GuiScrollBar::COLOR_BACK);
		iTab->renderer2D->DrawRectangle(this->edges.x,this->edges.w-TICK,this->edges.x+TICK,this->edges.w,0x00000000,false);

		iTab->renderer2D->DrawBitmap(iTab->iconUp,this->edges.x,this->edges.y,this->edges.x+TICK,this->edges.y+TICK);
		iTab->renderer2D->DrawBitmap(iTab->iconDown,this->edges.x,this->edges.w-TICK,this->edges.x+TICK,this->edges.w);

		float tContainerBegin=this->GetContainerBegin();
		float tScrollerBegin=this->GetScrollerBegin();
		float tContainerEnd=this->GetContainerEnd();
		float tScrollerEnd=this->GetScrollerEnd();

		iTab->renderer2D->DrawRectangle(this->edges.x,tContainerBegin,this->edges.x+TICK,tContainerEnd,GuiScrollBar::COLOR_BACK);
		iTab->renderer2D->DrawRectangle(this->edges.x,tContainerBegin,this->edges.x+TICK,tContainerEnd,0x00000000,false);

		iTab->renderer2D->DrawRectangle(this->edges.x,tScrollerBegin,this->edges.x+TICK,tScrollerEnd,0x00000000);
	}
	else
	{
		iTab->renderer2D->DrawRectangle(this->edges.x,this->edges.y,this->edges.x+TICK,this->edges.y+TICK,GuiScrollBar::COLOR_BACK);
		iTab->renderer2D->DrawRectangle(this->edges.x,this->edges.y,this->edges.x+TICK,this->edges.y+TICK,0x00000000,false);
		iTab->renderer2D->DrawRectangle(this->edges.z-TICK,this->edges.y,this->edges.z,this->edges.w,GuiScrollBar::COLOR_BACK);
		iTab->renderer2D->DrawRectangle(this->edges.z-TICK,this->edges.y,this->edges.z,this->edges.w,0x00000000,false);

		iTab->renderer2D->DrawBitmap(iTab->iconLeft,this->edges.x,this->edges.y,this->edges.x+TICK,this->edges.y+TICK);
		iTab->renderer2D->DrawBitmap(iTab->iconRight,this->edges.z-TICK,this->edges.y,this->edges.z,this->edges.w);

		float tContainerBegin=this->GetContainerBegin();
		float tScrollerBegin=this->GetScrollerBegin();
		float tContainerEnd=this->GetContainerEnd();
		float tScrollerEnd=this->GetScrollerEnd();

		iTab->renderer2D->DrawRectangle(tContainerBegin,this->edges.y,tContainerEnd,this->edges.y+TICK,GuiScrollBar::COLOR_BACK);
		iTab->renderer2D->DrawRectangle(tContainerBegin,this->edges.y,tContainerEnd,this->edges.y+TICK,0x00000000,false);

		iTab->renderer2D->DrawRectangle(tScrollerBegin,this->edges.y,tScrollerEnd,this->edges.y+TICK,0x00000000);
	}
}


///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////GuiSceneViewer/////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

GuiSceneViewer* GuiSceneViewer::GetInstance()
{
	if(!::GlobalGuiSceneViewerInstance())
		::GlobalGuiSceneViewerInstance()=new GuiSceneViewer;

	return ::GlobalGuiSceneViewerInstance();
}

bool GuiSceneViewer::IsInstanced()
{
	return ::GlobalGuiSceneViewerInstance() ? true : false; 
}

GuiSceneViewer::GuiSceneViewer(){}

GuiSceneViewer::GuiSceneViewer(GuiSceneViewer const& gsv){}
GuiSceneViewer::~GuiSceneViewer(){}

void GuiSceneViewer::SceneLabel::OnButtonUp(Tab* iTab,EventMouse* iData/*=0*/)
{
	Item::OnButtonUp(iTab,iData);

	switch(iData->button)
	{
		case 3:
		{
			int tMenuItem=iTab->TrackGuiSceneViewerPopup(this);	

			EditorObjectBase*	tCreatedEditorObject=0;

			switch(tMenuItem)
			{
			case 1:
				{
					EditorEntity* tNewEntity=0;

					tCreatedEditorObject=tNewEntity=new EditorEntity;

					tNewEntity->name=L"__00000000000000000000000000000000000000000000000000000000000000000000000000000000000";

					this->entity->AddEntity(tNewEntity);

					tNewEntity->OnPropertiesCreate();
				}
				break;
			case 2:
				//GuiSceneLabelHelpers::hovered->DestroyChilds();
				break;
			case 3:tCreatedEditorObject=this->entity->CreateComponent<EditorLight>();break;
			case 4:tCreatedEditorObject=this->entity->CreateComponent<EditorMesh>();break;
			case 5:tCreatedEditorObject=this->entity->CreateComponent<EditorCamera>();break;
			case 14:tCreatedEditorObject=this->entity->CreateComponent<EditorScript>();break;
			}

			if(tCreatedEditorObject)
				tCreatedEditorObject->OnResourcesCreate();

			if(tMenuItem)
				iTab->SetDraw(this->GetTreeView());
		}
		break;
		case 1:
		{
			if(!this->ExpandosContains(iData->mouse))
			{
				for(std::list<GuiEntityViewer*>::const_iterator it=GuiEntityViewer::GetInstances().begin();it!=GuiEntityViewer::GetInstances().end();it++)
					(*it)->OnEntitySelected((*it)->GetRoot()->GetTab(),(Event*)this->entity);
			}
		}
		break;
	}
}



void GuiSceneViewer::OnActivate(Tab* iTab,Event* iData)
{
}

void GuiSceneViewer::OnButtonDown(Tab* iTab,EventMouse* iData/*=0*/)
{
	GuiTreeView::OnButtonDown(iTab,iData);
}	

void GuiSceneViewer::OnButtonUp(Tab* iTab,EventMouse* iData/*=0*/)
{
	GuiTreeView::OnButtonUp(iTab,iData);
}	

void GuiSceneViewer::OnMouseMove(Tab* iTab,EventMouse* iData/*=0*/)
{
	GuiTreeView::OnMouseMove(iTab,iData);
}	




void GuiSceneViewer::OnDeactivate(Tab* iTab,Event* iData)
{
	
}

void GuiSceneViewer::Save(String iFilename)
{
}

void GuiSceneViewer::Load(String iFilename)
{

}

///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////GuiEntityViewer/////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

GuiEntityViewer::GuiEntityViewer():entity(0),tab(0)
{
	GlobalGuiEntityViewerInstance().push_back(this);
}

GuiEntityViewer::~GuiEntityViewer()
{
	GlobalGuiEntityViewerInstance().remove(this);
}

const std::list<GuiEntityViewer*>& GuiEntityViewer::GetInstances()
{
	return GlobalGuiEntityViewerInstance();
}

void GuiEntityViewer::OnEntitySelected(Tab* iTab,Event* iData)
{
	EditorEntity* tReceivedEntity=(EditorEntity*)iData;

	if(this->entity!=tReceivedEntity)
	{
		if(this->entity)
			this->RemoveChild(&this->entity->container);

		if(tReceivedEntity)
		{
			this->entity=tReceivedEntity;
			this->InsertContainer(0,&tReceivedEntity->container);

		}
	}

	iTab->SetDraw(this);
}

void GuiEntityViewer::OnExpandos(Tab* iTab,Event* iData)
{
	//this->OnSize(iTab);
}

///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////GuiConsoleViewer////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////
GuiConsoleViewer::GuiConsoleViewer(){}
GuiConsoleViewer::~GuiConsoleViewer(){}

GuiConsoleViewer* GuiConsoleViewer::GetInstance()
{
	if(!::GlobalGuiConsoleViewerInstance())
		::GlobalGuiConsoleViewerInstance()=new GuiConsoleViewer;

	return ::GlobalGuiConsoleViewerInstance();
}

bool GuiConsoleViewer::IsInstanced()
{
	return ::GlobalGuiConsoleViewerInstance() ? true : false; 
}


///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////GuiProjectViewer////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

const int SPLITTER_SIZE=4;

GuiProjectViewer* GuiProjectViewer::GetInstance()
{
	if(!::GlobalGuiProjectViewerInstance())
		::GlobalGuiProjectViewerInstance()=new GuiProjectViewer;

	return ::GlobalGuiProjectViewerInstance();
}

bool GuiProjectViewer::IsInstanced()
{
	return ::GlobalGuiProjectViewerInstance() ? true : false; 
}

GuiProjectViewer::GuiProjectViewer(GuiProjectViewer const&):projectDirectory(globalRootProjectDirectory){}

GuiProjectViewer::GuiProjectViewer():
	projectDirectory(GlobalRootProjectDirectory()),
	splitterLeftActive(false),
	splitterRightActive(false),
	splitterLeft(100),
	splitterRight(200)
{
	projectDirectory=new ResourceNodeDir;
	this->projectDirectory->fileName=Ide::GetInstance()->folderProject;
	this->projectDirectory->isDir=true;
	this->projectDirectory->dirLabel.SetName(this->projectDirectory->fileName);
	this->projectDirectory->fileLabel.SetName(this->projectDirectory->fileName);
}

GuiProjectViewer::~GuiProjectViewer()
{
}



void GuiProjectViewer::OnActivate(Tab* iTab,Event* iData)
{
	Ide::GetInstance()->ScanDir(this->projectDirectory->fileName,this->projectDirectory);
	this->dirViewer.Insert(0,&this->projectDirectory->dirLabel);
	this->fileViewer.Insert(0,&this->projectDirectory->fileLabel);
}

void GuiProjectViewer::OnDeactivate(Tab* iTab,Event* iData)
{
}

void GuiProjectViewer::RefreshAll()
{
}

void GuiProjectViewer::FindHover(Tab* iTab,vec2& iMouse,Gui*& iGui)
{
	if(this->Contains(iMouse))
		iGui=this;

	if(this->dirViewer.Contains(iMouse))
		this->dirViewer.FindHover(iTab,iMouse,iGui);
	else if(this->fileViewer.Contains(iMouse))
		this->fileViewer.FindHover(iTab,iMouse,iGui);
	else if(this->resViewer.Contains(iMouse))
		this->resViewer.FindHover(iTab,iMouse,iGui);
}

void GuiProjectViewer::OnMouseMove(Tab* iTab,EventMouse* iData/*=0*/)
{
	iTab->SetCursor(1);

	if(this->IsPressing())
	{
		if(this->splitterLeftActive)
			this->splitterLeft=iData->mouse.x;

		if(this->splitterRightActive)
			this->splitterRight=iData->mouse.x;

		this->OnResize(iTab);
		iTab->SetDraw(this);
	}
}


void GuiProjectViewer::OnButtonDown(Tab* iTab,EventMouse* iData/*=0*/)
{
	Gui::OnButtonDown(iTab,iData);

	iTab->SetCursor(1);

	if(iData->mouse.x>=this->splitterLeft && iData->mouse.x<=this->splitterLeft+SPLITTER_SIZE)
		this->splitterLeftActive=true;
	else if(iData->mouse.x>=this->splitterRight && iData->mouse.x<=this->splitterRight+SPLITTER_SIZE)
		this->splitterRightActive=true;
}

void GuiProjectViewer::OnButtonUp(Tab* iTab,EventMouse* iData/*=0*/)
{
	Gui::OnButtonUp(iTab,iData);

	if(this->splitterLeftActive || this->splitterRightActive)
	{
		this->splitterLeftActive=false;
		this->splitterRightActive=false;
	}
}


void GuiProjectViewer::OnReparent(Tab* iTab,Event* iData)
{
}

void GuiProjectViewer::OnPaint(Tab* iTab,Event* iData)
{
	iTab->renderer2D->DrawRectangle(this->edges.x,this->edges.y,this->edges.z,this->edges.w,Tab::COLOR_BACK);

	this->dirViewer.OnPaint(iTab);
	this->fileViewer.OnPaint(iTab);
	this->resViewer.OnPaint(iTab);
}

void GuiProjectViewer::SetEdges(vec4 iEdges)
{
	float tWidth=this->GetWidth();

	float tLeftPercent=this->GetWidth()/this->splitterLeft;
	float tRightPercent=this->GetWidth()/this->splitterRight;

	this->edges=iEdges;

	if(tLeftPercent && tRightPercent)
	{
		this->splitterLeft=this->GetWidth()*(1.0f/tLeftPercent);
		this->splitterRight=this->GetWidth()*(1.0f/tRightPercent);
	}
}

void GuiProjectViewer::OnResize(Tab* iTab,Event* iData)
{
	vec4 tDirViewerEdges(
		this->edges.x,
		this->edges.y,
		this->splitterLeft,
		this->edges.w
		);

	vec4 tFileViewerEdges(
		tDirViewerEdges.z + SPLITTER_SIZE,
		this->edges.y,
		this->splitterRight,
		this->edges.w
		);

	vec4 tResViewerEdges(
		tFileViewerEdges.z + SPLITTER_SIZE,
		this->edges.y,
		this->GetEdges().z,
		this->edges.w
		);

	this->dirViewer.SetEdges(tDirViewerEdges);
	this->fileViewer.SetEdges(tFileViewerEdges);
	this->resViewer.SetEdges(tResViewerEdges);

	this->dirViewer.OnResize(iTab);
	this->fileViewer.OnResize(iTab);
	this->resViewer.OnResize(iTab);
}

void GuiProjectViewer::Delete(Tab* iTab,ResourceNode* iNode)
{
	
}


void GuiProjectViewer::findResources(std::vector<ResourceNode*>& oResultArray,ResourceNode* iResourceNode,String iExtension)
{
	if(iResourceNode->isDir)
	{
		ResourceNodeDir* tResourceNodeDir=(ResourceNodeDir*)iResourceNode;

		for(std::list<ResourceNode*>::iterator nCh=tResourceNodeDir->files.begin();nCh!=tResourceNodeDir->files.end();nCh++)
			this->findResources(oResultArray,*nCh,iExtension);

		for(std::list<ResourceNodeDir*>::iterator nCh=tResourceNodeDir->dirs.begin();nCh!=tResourceNodeDir->dirs.end();nCh++)
			this->findResources(oResultArray,*nCh,iExtension);
	}
	else if(iResourceNode->fileName.PointedExtension()==iExtension)
		oResultArray.push_back(iResourceNode);
}

std::vector<ResourceNode*> GuiProjectViewer::findResources(String iExtension)
{
	std::vector<ResourceNode*> oResultArray;

	this->findResources(oResultArray,this->projectDirectory,iExtension);

	return oResultArray;
}

void GuiProjectViewer::DataViewer::OnPaint(Tab* iTab,Event* iData)
{
	iTab->renderer2D->DrawRectangle(this->edges.x,this->edges.y,this->edges.z,this->edges.w,Gui::COLOR_BACK);
}


////////////////////////////////////////////
////////////////////////////////////////////
/////////GuiProjectViewer::DirViewer////////
////////////////////////////////////////////
////////////////////////////////////////////




/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
///////////////GuiProjectViewer::FileViewer/////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
void GuiProjectViewer::FileViewer::FileLabel::OnButtonUp(Tab* iTab,EventMouse* iData)
{
	Item::OnButtonUp(iTab,iData);

	if(iData->button==3)
	{
		int menuResult=iTab->TrackProjectFileViewerPopup(this->resource);

		switch(menuResult)
		{
		case 1:
			{
				iTab->concurrentInstances.push_back(std::function<void()>(std::bind(&GuiProjectViewer::Delete,GuiProjectViewer::GetInstance(),iTab,this->resource)));
			}
			break;
		case 3://load
			if(this->resource->fileName.PointedExtension() == Ide::GetInstance()->GetSceneExtension())
			{
				if(GuiSceneViewer::GetInstance())
				{
					Tab* tTab=GuiSceneViewer::GetInstance()->GetRoot()->GetTab();

					iTab->DrawBlock(true);
					tTab->DrawBlock(true);

					String tHoveredNodeFilename=this->resource->BuildPath();

					GuiSceneViewer::GetInstance()->Load(tHoveredNodeFilename.c_str());
					tTab->SetDraw(GuiSceneViewer::GetInstance());

					tTab->DrawBlock(false);
					iTab->DrawBlock(false);
				}
			}
			break;
		case 4://load
			if(this->resource->fileName.Extension() == L"cpp")
			{
				launchStopScriptEditorCallback();
			}
			break;
		}
	}

}

//////////////////////////////////////
//////////////////////////////////////
///////////////GuiImage///////////////
//////////////////////////////////////
//////////////////////////////////////

Picture::Picture():
handle(0),
	width(0),
	height(0),
	bpp(0)
{}

Picture::~Picture()
{
	this->Release();
	this->width=-1;
	this->height=-1;
	this->bpp=-1;
}

PictureRef::PictureRef(unsigned char* iRefData,float iWidth,float iHeight):refData(iRefData)
{
	this->width=iWidth;
	this->height=iHeight;
}

PictureFile::PictureFile(String iFilename):fileName(iFilename){}


///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////DrawInstance/////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////


DrawInstance::DrawInstance(Gui* iRect,bool iRemove,bool iSkip):rect(iRect),remove(iRemove),skip(iSkip){}

///////////////////////////////////////////////
///////////////////////////////////////////////
////////////////////GuiPaper///////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

void GuiScriptViewer::DrawBreakpoints(Tab* tabContainer)
{
}

///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////GuiScriptViewer/////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////
std::list<GuiScriptViewer*>& GuiScriptViewer::GetInstances()
{
	return GlobalScriptViewers();
}


GuiScriptViewer::GuiScriptViewer():
	script(0),
	lineNumbers(true)
{
	this->GetInstances().push_back(this);
}

GuiScriptViewer::~GuiScriptViewer()
{
	this->GetInstances().erase(std::find(this->GetInstances().begin(),this->GetInstances().end(),this));
}

void GuiScriptViewer::Open(Script* iScript)
{

	Tab* tabContainer=Ide::GetInstance()->mainAppWindow->mainContainer->tabs[0];

	if(!tabContainer)
		DEBUG_BREAK();

	if(!GuiScriptViewer::GetInstances().size())
		tabContainer->guiRoot.AddChild(new GuiScriptViewer);

	GuiScriptViewer* guiScriptViewer=GuiScriptViewer::GetInstances().front();

	if(guiScriptViewer)
	{
		guiScriptViewer->Open(editorScript);
		guiScriptViewer->OnSize(tabContainer);
		tabContainer->SetDraw();
	}
}

bool GuiScriptViewer::Save()
{
	return false;
}


bool GuiScriptViewer::Compile()
{
	return false;
}



void GuiScriptViewer::OnKeyDown(Tab* iTab,Event* iData)
{
}

void GuiScriptViewer::OnKeyUp(Tab* iTab,Event* iData)
{
}

void GuiScriptViewer::OnButtonDown(Tab*,Event* iData)
{
}

void GuiScriptViewer::OnDeactivate(Tab* iTab,Event* iData)
{
}

void GuiScriptViewer::OnMouseMove(Tab*,Event* iData)
{
}

void GuiScriptViewer::OnSize(Tab* iTab,Event* iData)
{
}


int GuiScriptViewer::CountScriptLines()
{
	return 0;
}

///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////GuiCompilerViewer///////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

GuiCompilerViewer* GuiCompilerViewer::GetInstance()
{
	if(!::GlobalGuiCompilerViewerInstance())
		::GlobalGuiCompilerViewerInstance()=new GuiCompilerViewer;

	return ::GlobalGuiCompilerViewerInstance();
}

bool GuiCompilerViewer::IsInstanced()
{
	return ::GlobalGuiCompilerViewerInstance() ? true : false; 
}

GuiCompilerViewer::GuiCompilerViewer(){}
GuiCompilerViewer::~GuiCompilerViewer(){}

const wchar_t* nthOccurrenceInLine(const wchar_t* iStr,char iChar,int iNth)
{
	const wchar_t* str=iStr;
	int occurr=0;

	char c=*str;

	while(c!='\0' || c!='\n')
	{
		if(c==iChar)
		{
			if(++occurr==iNth)
				return str;
		}

		c=*(++str);
	}

	return 0;
}


bool GuiCompilerViewer::ParseCompilerOutputFile(String iFileBuffer)
{
	return false;
}


void GuiCompilerViewer::OnSize(Tab* iTab,Event* iData)
{
}


///////////////////////////////////////////////
///////////////////////////////////////////////
/////////////////Properties////////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

void EditorEntity::OnPropertiesCreate()
{
	this->sceneLabel.entity=this;
	this->sceneLabel.SetName(this->name);
	this->container.SetName(L"Entity");

	this->container.InsertProperty(new StringProperty(L"Name",&this->name,StringProperty::STRING));

	this->container.InsertProperty(new StringProperty(L"Ptr",this,StringProperty::PTR));
	this->container.InsertProperty(new StringProperty(L"Id",&this->id,StringProperty::INT));
	this->container.InsertProperty(new StringProperty(L"Position",&this->world,StringProperty::MAT4POS));
	this->container.InsertProperty(new StringProperty(L"Childs",&this->Entity::childs,StringProperty::ENTITYLISTSIZE));

	GuiPropertyTree::Container* tAABBProperty=this->container.InsertContainer(new GuiPropertyTree::Container);

	tAABBProperty->SetName(L"AABB");

	tAABBProperty->InsertProperty(new StringProperty(L"Min",this->bbox.a,StringProperty::VEC3));
	tAABBProperty->InsertProperty(new StringProperty(L"Max",this->bbox.b,StringProperty::VEC3));
	tAABBProperty->InsertProperty(new StringProperty(L"Volume",this->bbox.a,StringProperty::VEC3,this->bbox.b));
}

void EditorEntity::OnPropertiesUpdate(Tab* tab)
{
	for(std::list<EntityComponent*>::iterator it=this->components.begin();it!=this->components.end();it++)
	{
		EditorObjectBase* componentProperties=dynamic_cast<EditorObjectBase*>(*it);

		if(componentProperties)
			componentProperties->OnPropertiesUpdate(tab);
	}
}

void EditorMesh::OnPropertiesCreate()
{
	this->container.SetName(L"Mesh");

	EditorEntity* tEditorEntity=(EditorEntity*)this->entity;

	tEditorEntity->container.InsertContainer(&this->container);

	this->container.InsertProperty(new StringProperty(L"Controlpoints",&this->ncontrolpoints,StringProperty::INT));
	this->container.InsertProperty(new StringProperty(L"Normals",&this->nnormals,StringProperty::INT));
	this->container.InsertProperty(new StringProperty(L"Polygons",&this->npolygons,StringProperty::INT));
	this->container.InsertProperty(new StringProperty(L"Texcoord",&this->ntexcoord,StringProperty::INT));
	this->container.InsertProperty(new StringProperty(L"Vertexindices",&this->nvertexindices,StringProperty::INT));
}

void EditorMesh::OnPropertiesUpdate(Tab* tab)
{
}

void EditorSkin::OnPropertiesCreate()
{
	this->container.SetName(L"Skin");

	EditorEntity* tEditorEntity=(EditorEntity*)this->entity;

	tEditorEntity->container.InsertContainer(&this->container);

	this->container.InsertProperty(new StringProperty(L"Clusters",&this->nclusters,StringProperty::INT));
	this->container.InsertProperty(new StringProperty(L"Textures",&this->ntextures,StringProperty::INT));

}
void EditorSkin::OnPropertiesUpdate(Tab* tab)
{
}
void EditorRoot::OnPropertiesCreate()
{
	this->container.SetName(L"Root");

}
void EditorRoot::OnPropertiesUpdate(Tab* tab)
{
}
void EditorSkeleton::OnPropertiesCreate()
{
	EditorEntity* tEditorEntity=(EditorEntity*)this->entity;

}
void EditorSkeleton::OnPropertiesUpdate(Tab* tab)
{
}
void EditorGizmo::OnPropertiesCreate()
{
	EditorEntity* tEditorEntity=(EditorEntity*)this->entity;

}
void EditorGizmo::OnPropertiesUpdate(Tab* tab)
{
}
void EditorAnimation::OnPropertiesCreate()
{
	this->container.SetName(L"Animation");

	EditorEntity* tEditorEntity=(EditorEntity*)this->entity;

	tEditorEntity->container.InsertContainer(&this->container);

	this->container.InsertProperty(new StringProperty(L"IsBone",this,StringProperty::ISBONECOMPONENT));
	this->container.InsertProperty(new StringProperty(L"Duration",&this->start,StringProperty::FLOAT2MINUSFLOAT1,&this->end));
	this->container.InsertProperty(new StringProperty(L"Begin",&this->start,StringProperty::FLOAT));
	this->container.InsertProperty(new StringProperty(L"End",&this->end,StringProperty::FLOAT));

}
void EditorAnimation::OnPropertiesUpdate(Tab* tab)
{
}

EditorAnimationController::EditorAnimationController():minSpeed(0),maxSpeed(2.0f){}
EditorAnimationController::~EditorAnimationController(){}

void EditorAnimationController::OnPropertiesCreate()
{
	this->container.SetName(L"Animation Controller");

	EditorEntity* tEditorEntity=(EditorEntity*)this->entity;

	tEditorEntity->container.InsertContainer(&this->container);

	this->container.InsertProperty(new StringProperty(L"Number of nodes",&this->animations,StringProperty::ANIMATIONVECSIZE));
	this->container.InsertProperty(new SliderProperty(L"Velocity",&this->speed,&this->minSpeed,&this->maxSpeed));
	this->container.InsertProperty(new StringProperty(L"Duration",&this->start,StringProperty::FLOAT2MINUSFLOAT1,&this->end));
	this->container.InsertProperty(new StringProperty(L"Begin",&this->start,StringProperty::FLOAT));
	this->container.InsertProperty(new StringProperty(L"End",&this->end,StringProperty::FLOAT));

	this->guiAnimationController=new AnimationProperty(L"Controller",*this);

	this->container.InsertProperty(this->guiAnimationController);
}

void EditorAnimationController::OnPropertiesUpdate(Tab* tab)
{
	if(this->container.IsExpanded() && this->oldCursor!=this->cursor)
	{
		tab->SetDraw(&guiAnimationController->slider);

		this->oldCursor=this->cursor;
	}
}

void EditorLine::OnPropertiesCreate()
{
	this->container.SetName(L"Line");

	EditorEntity* tEditorEntity=(EditorEntity*)this->entity;

	tEditorEntity->container.InsertContainer(&this->container);

	this->container.InsertProperty(new StringProperty(L"Number of Segments",&this->points,StringProperty::VEC3LISTSIZE));

	/*this->pointListBox=new GuiListBox;

	for(std::list<vec3>::iterator i=this->points.begin();i!=this->points.end();i++)
		this->pointListBox->AddItem(*i,StringProperty::VEC3);

	this->container->Insert(this->pointListBox);*/
}
void EditorLine::OnPropertiesUpdate(Tab* tab)
{
}

void EditorLine::DestroyPoints()
{
}
void EditorLine::AddPoint(vec3 iPoint)
{
}


void EditorBone::OnPropertiesCreate()
{
	EditorEntity* tEditorEntity=(EditorEntity*)this->entity;
}
void EditorBone::OnPropertiesUpdate(Tab* tab)
{
}
void EditorLight::OnPropertiesCreate()
{
	EditorEntity* tEditorEntity=(EditorEntity*)this->entity;
}
void EditorLight::OnPropertiesUpdate(Tab* tab)
{
}

void editScriptEditorCallback(Event* iData)
{
	EditorScript* editorScript=(EditorScript*)iData;

	
}

void compileScriptEditorCallback(void* iData)
{
	EditorScript* editorScript=(EditorScript*)iData;

    Ide::GetInstance()->compiler->Compile(editorScript);
}

void launchStopScriptEditorCallback(Event* iData)
{
	EditorScript* editorScript=(EditorScript*)iData;

	if(editorScript->runtime)
	{
		if(Ide::GetInstance()->compiler->UnloadScript(editorScript))
			editorScript->buttonLaunch->text=L"Launch";
	}
	else
	{
		if(Ide::GetInstance()->compiler->LoadScript(editorScript))
			editorScript->buttonLaunch->text=L"Stop";
	}

	editorScript->container.GetRoot()->GetTab()->SetDraw(editorScript->buttonLaunch);
}

EditorScript::EditorScript():scriptViewer(0)
{

};

void EditorScript::OnResourcesCreate()
{
	if(this->file.empty())
		this->file=Ide::GetInstance()->folderProject + L"\\" + this->entity->name + L".cpp";

	if(!File::Exist(this->file))
	{
		if(!File::Create(this->file))
			DEBUG_BREAK();

		String tDefaultScript=L"#include \"entities.h\"\n\nstruct " + this->entity->name + L"_ : EntityScript\n{\n\t int counter;\n\tvoid init()\n\t{\n\t\tcounter=0;\n\tthis->entity->local.identity();\n\t\tprintf(\"inited\\n\");\n\t}\n\n\tvoid update()\n\t{\n\t\tthis->entity->local.translate(0.1f,0,0);\n\t//printf(\"counter: %d\\n\",counter);\n\tcounter++;\n\t}\n\n\tvoid deinit()\n\t{\n\t\tprintf(\"deinited\\n\");\n\t}\n\n};\n";

		this->SaveScript(tDefaultScript);
	}

	GuiProjectViewer::GetInstance()->RefreshAll();

	this->resourceNode=ResourceNodeDir::FindFileNode(this->file);

	if(!this->resourceNode)
		DEBUG_BREAK();
}
void EditorScript::OnPropertiesCreate()
{
	this->container.SetName(L"Script");

	EditorEntity* tEditorEntity=(EditorEntity*)this->entity;

	tEditorEntity->container.InsertContainer(&this->container);

	container.InsertProperty(new StringProperty(L"File",&this->Script::file,StringProperty::STRING));
	container.InsertProperty(new StringProperty(L"Running",&this->Script::runtime,StringProperty::BOOLPTR));

// 	GuiButton* buttonEdit=new GuiButton;
// 	buttonEdit->func=editScriptEditorCallback;
// 	buttonEdit->param=this;
// 	buttonEdit->text=L"Edit";
// 	//buttonEdit->fixed.make(0,0,0,20);
// 	//container.AddChild(buttonEdit);
// 
// 	GuiButton* buttonCompile=new GuiButton;
// 	buttonCompile->func=compileScriptEditorCallback;
// 	buttonCompile->param=this;
// 	buttonCompile->text=L"Compile";
// 	//buttonCompile->fixed.make(0,0,0,20);
// 	//container.Insert(buttonCompile);
// 
// 	this->buttonLaunch=new GuiButton;
// 	this->buttonLaunch->func=launchStopScriptEditorCallback;
// 	this->buttonLaunch->param=this;
// 	this->buttonLaunch->text=L"Launch";
// 	//this->buttonLaunch->fixed.make(0,0,0,20);
// 	//container.Insert(this->buttonLaunch);

}
void EditorScript::OnPropertiesUpdate(Tab* tab)
{
}

void EditorScript::SaveScript(String& iString)
{
	StringUtils::WriteCharFile(this->file,iString,L"wb");
}

String EditorScript::LoadScript()
{
	return StringUtils::ReadCharFile(this->file,L"rb");
}



void EditorCamera::OnPropertiesCreate()
{
	EditorEntity* tEditorEntity=(EditorEntity*)this->entity;
}
void EditorCamera::OnPropertiesUpdate(Tab* tab)
{
}




///////////////////////////////////////////////
///////////////////////////////////////////////
/////////////////FileSystem////////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

bool FileExists(const char* iFile)
{
	FILE* tFile=fopen(iFile,"rb");

	if(tFile)
	{
		return true;
		fclose(tFile);
	}

	return false;
}


///////////////////////////////////////////////
///////////////////////////////////////////////
/////////////////PluginSystem//////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

PluginSystem::Plugin::Plugin():loaded(false),name(L"Plugin"){}
PluginSystem::PluginSystem():modalTab(0){}
PluginSystem::~PluginSystem(){}

namespace PluginSystemUtils
{
	void ptfCloseConfigurationPanel(void* tData)
	{
		PluginSystem* tPluginSystem=(PluginSystem*)tData;

		tPluginSystem->modalTab->Destroy();
		Ide::GetInstance()->mainAppWindow->mainContainer->windowData->Enable(true);
	}

	void ptfLoadUnloadConfigurationPanelRowButton(void* tData)
	{
		GuiButton* tButtonFunc=(GuiButton*)tData;

	}
}

void PluginSystem::ShowConfigurationPanel()
{
	Container* tContainer=Ide::GetInstance()->mainAppWindow->mainContainer;

	tContainer->windowData->Enable(false);

	vec2 tIdeFrameSize=tContainer->windowData->Size();
	vec2 tTabSize(500,300);
	vec2 tTabPos=tContainer->windowData->Pos();

	tTabPos.x+=tIdeFrameSize.x/2.0f-tTabSize.x/2.0f;
	tTabPos.y+=tIdeFrameSize.y/2.0f-tTabSize.y/2.0f;

	this->modalTab=tContainer->CreateModalTab(tTabPos.x,tTabPos.y,tTabSize.x,tTabSize.y);

}



///////////////////////////////////////////////
///////////////////////////////////////////////
/////////////////MainContainer/////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////


MainContainer::MainContainer():mainContainer(0){}
MainContainer::~MainContainer(){}

void MainContainer::OnMenuPressed(int iIdx)
{
	if(iIdx==MenuActionExit)
	{

	}
	else if(iIdx==MenuActionConfigurePlugin)
	{
		Ide::GetInstance()->pluginSystem->ShowConfigurationPanel();
	}
	else if(iIdx==MenuActionProgramInfo)
	{

	}

}


void MainContainer::BroadcastToTabs(void (Tab::*func)(void*),void* data)
{
	for(std::vector<Container*>::iterator tContainer=this->containers.begin();tContainer!=this->containers.end();tContainer++)
		(*tContainer)->BroadcastToTabs(func);
}
/*

void MainContainer::BroadcastToSelectedTabRects(void (GuiInterface::*func)(Tab*,Event* iData=0),const GuiEvent* tEvent)
{
	for(std::vector<Container*>::iterator tContainer=this->containers.begin();tContainer!=this->containers.end();tContainer++)
		(*tContainer)->BroadcastToSelectedTabRects(func,tEvent);
}*/

///////////////////////////////////////////////
///////////////////////////////////////////////
////////////////////Subsystem//////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

String Subsystem::RandomDir(String iWhere,int iSize,String iAlphabet)
{
	String tRandomWorkingDirectoryName;
	String tRandomWorkingDirectory;

	while(true)
	{
		tRandomWorkingDirectoryName=StringUtils::RandomString(iSize,iAlphabet);

		String tFullRandomDirName=iWhere + L"\\" + tRandomWorkingDirectoryName;

		if(!this->DirectoryExist(tRandomWorkingDirectory.c_str()))
			break;
	}

	tRandomWorkingDirectory=iWhere + L"\\" + tRandomWorkingDirectoryName;

	if(!this->CreateDirectory(tRandomWorkingDirectory.c_str()))
		DEBUG_BREAK();

	if(!this->DirectoryExist(tRandomWorkingDirectory.c_str()))
		DEBUG_BREAK();

	return tRandomWorkingDirectory;
}

///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////SerializerHelpers impl//////////
///////////////////////////////////////////////
///////////////////////////////////////////////

void SerializerHelpers::Save(Mesh* tMesh,FILE* iFile)
{
	WriteComponentCode(Serializer::Mesh,iFile);

	fwrite(&tMesh->ncontrolpoints,sizeof(unsigned int),1,iFile);
	fwrite(&tMesh->nvertexindices,sizeof(unsigned int),1,iFile);
	fwrite(&tMesh->ntexcoord,sizeof(unsigned int),1,iFile);
	fwrite(&tMesh->nnormals,sizeof(unsigned int),1,iFile);
	fwrite(&tMesh->npolygons,sizeof(unsigned int),1,iFile);
	fwrite(&tMesh->isCCW,sizeof(bool),1,iFile);

	if(tMesh->ncontrolpoints)
		fwrite(tMesh->controlpoints,sizeof(float)*3*tMesh->ncontrolpoints,1,iFile);

	if(tMesh->nvertexindices)
		fwrite(tMesh->vertexindices,sizeof(unsigned int)*tMesh->nvertexindices,1,iFile);

	if(tMesh->ntexcoord)
		fwrite(tMesh->texcoord,sizeof(float)*2*tMesh->ntexcoord,1,iFile);

	if(tMesh->nnormals)
		fwrite(tMesh->normals,sizeof(float)*3*tMesh->nnormals,1,iFile);
}


void SerializerHelpers::Save(Skin* tSkin,FILE* iFile)
{
	WriteComponentCode(Serializer::Skin,iFile);

	fwrite(&tSkin->nclusters,sizeof(unsigned int),1,iFile);
	fwrite(&tSkin->ntextures,sizeof(unsigned int),1,iFile);

	for(int clusterIdx=0;clusterIdx<tSkin->nclusters;clusterIdx++)
	{
		Cluster* tCluster=&tSkin->clusters[clusterIdx];

		fwrite(&tCluster->bone->id,sizeof(unsigned int),1,iFile);
		fwrite(&tCluster->ninfluences,sizeof(unsigned int),1,iFile);
		fwrite(tCluster->offset,sizeof(float),16,iFile);

		for(int influenceIdx=0;influenceIdx<tCluster->ninfluences;influenceIdx++)
		{
			Influence* tInfluence=&tCluster->influences[influenceIdx];

			fwrite(&tInfluence->weight,sizeof(float),1,iFile);
			fwrite(&tInfluence->ncontrolpointindex,sizeof(unsigned int),1,iFile);
			fwrite(tInfluence->controlpointindex,sizeof(unsigned int)*tInfluence->ncontrolpointindex,1,iFile);
		}
	}

	SerializerHelpers::Save((Mesh*)tSkin,iFile);
}


void SerializerHelpers::Save(Animation* tAnimation,FILE* iFile)
{
	WriteComponentCode(Serializer::Animation,iFile);

	fwrite(&tAnimation->start,sizeof(float),1,iFile);
	fwrite(&tAnimation->end,sizeof(float),1,iFile);
	fwrite(&tAnimation->index,sizeof(int),1,iFile);

	unsigned int tAnimClipsSize=tAnimation->clips.size();

	fwrite(&tAnimClipsSize,sizeof(unsigned int),1,iFile);

	for(std::vector<AnimClip*>::iterator iterAnimClip=tAnimation->clips.begin();iterAnimClip!=tAnimation->clips.end();iterAnimClip++)
	{
		AnimClip* tAnimClip=*iterAnimClip;

		fwrite(&tAnimClip->start,sizeof(float),1,iFile);
		fwrite(&tAnimClip->end,sizeof(float),1,iFile);

		unsigned int tKeyCurveSize=tAnimClip->curves.size();

		fwrite(&tKeyCurveSize,sizeof(unsigned int),1,iFile);

		for(std::vector<KeyCurve*>::iterator iterKeyCurve=tAnimClip->curves.begin();iterKeyCurve!=tAnimClip->curves.end();iterKeyCurve++)
		{
			KeyCurve* tKeyCurve=*iterKeyCurve;

			fwrite(&tKeyCurve->channel,sizeof(unsigned int),1,iFile);
			fwrite(&tKeyCurve->start,sizeof(float),1,iFile);
			fwrite(&tKeyCurve->end,sizeof(float),1,iFile);

			unsigned int tKeyframeSize=tKeyCurve->frames.size();

			fwrite(&tKeyframeSize,sizeof(unsigned int),1,iFile);

			for(std::vector<Keyframe*>::iterator iterKeyFrame=tKeyCurve->frames.begin();iterKeyFrame!=tKeyCurve->frames.end();iterKeyFrame++)
			{
				Keyframe* tKeyframe=*iterKeyFrame;

				fwrite(&tKeyframe->time,sizeof(float),1,iFile);
				fwrite(&tKeyframe->value,sizeof(float),1,iFile);
			}
		}
	}
}


void SerializerHelpers::Save(AnimationController* tAnimationController,FILE* iFile)
{
	WriteComponentCode(Serializer::AnimationController,iFile);

	unsigned int tAnimationIdsSize=tAnimationController->animations.size();
	fwrite(&tAnimationIdsSize,sizeof(unsigned int),1,iFile);

	if(tAnimationIdsSize)
	{
		unsigned int *tAnimationIdsArray=new unsigned int[tAnimationIdsSize];

		for(int i=0;i<tAnimationIdsSize;i++)
		{
			wprintf(L"animation[%d] entity: %s\n",i,tAnimationController->animations[i]->entity->name.c_str());
			tAnimationIdsArray[i]=tAnimationController->animations[i]->entity->id;
		}

		fwrite(tAnimationIdsArray,sizeof(unsigned int)*tAnimationIdsSize,1,iFile);
		SAFEDELETEARRAY(tAnimationIdsArray);
	}

	fwrite(&tAnimationController->speed,sizeof(float),1,iFile);
	fwrite(&tAnimationController->cursor,sizeof(float),1,iFile);
	fwrite(&tAnimationController->play,sizeof(bool),1,iFile);
	fwrite(&tAnimationController->looped,sizeof(bool),1,iFile);
	fwrite(&tAnimationController->start,sizeof(float),1,iFile);
	fwrite(&tAnimationController->end,sizeof(float),1,iFile);
	fwrite(&tAnimationController->framesPerSecond,sizeof(unsigned int),1,iFile);
	fwrite(&tAnimationController->frameTime,sizeof(unsigned int),1,iFile);
}


void SerializerHelpers::Save(Line* tLine,FILE* iFile)
{
	WriteComponentCode(Serializer::Line,iFile);

	unsigned int tPointSize=tLine->points.size();

	fwrite(&tPointSize,sizeof(unsigned int),1,iFile);

	for(std::list<vec3>::iterator it=tLine->points.begin();it!=tLine->points.end();it++)
		fwrite(&(*it),sizeof(float)*3,1,iFile);
}

void SerializerHelpers::Load(EditorLine* tLine,FILE* iFile)
{
	unsigned int	tPointSize;
	vec3			tPoint;

	fread(&tPointSize,sizeof(unsigned int),1,iFile);

	for(int i=0;i<tPointSize;i++)
	{
		fread(&tPoint,sizeof(float)*3,1,iFile);
		tLine->AddPoint(tPoint);
	}
}

void SerializerHelpers::Save(Script* tScript,FILE* iFile)
{
	WriteComponentCode(Serializer::Script,iFile);

	StringUtils::WriteWstring(iFile,tScript->file);
}


void SerializerHelpers::saveSceneEntityRecursively(Entity* iEntity,FILE* iFile)
{
	unsigned int childsSize=iEntity->childs.size();
	unsigned int componentsSize=iEntity->components.size();

	if(iEntity->id<0)
		DEBUG_BREAK();

	iEntity->saved=true;

	fwrite(&childsSize,sizeof(unsigned int),1,iFile);
	fwrite(&iEntity->id,sizeof(unsigned int),1,iFile);

	fwrite(iEntity->local,sizeof(float),16,iFile);
	fwrite(iEntity->world,sizeof(float),16,iFile);

	StringUtils::WriteWstring(iFile,iEntity->name);

	fwrite(iEntity->bbox.a,sizeof(float),3,iFile);
	fwrite(iEntity->bbox.b,sizeof(float),3,iFile);

	fwrite(&componentsSize,sizeof(unsigned int),1,iFile);

	for(std::list<EntityComponent*>::iterator iteratorComponent=iEntity->components.begin();iteratorComponent!=iEntity->components.end();iteratorComponent++)
	{
		if((*iteratorComponent)->is<Script>()) SerializerHelpers::Save((Script*)(*iteratorComponent),iFile);
		else if((*iteratorComponent)->is<Line>()) SerializerHelpers::Save((Line*)(*iteratorComponent),iFile);
		else if((*iteratorComponent)->is<Animation>()) SerializerHelpers::Save((Animation*)(*iteratorComponent),iFile);
		else if((*iteratorComponent)->is<AnimationController>()) SerializerHelpers::Save((AnimationController*)(*iteratorComponent),iFile);
		else if((*iteratorComponent)->is<Skin>()) SerializerHelpers::Save((Skin*)(*iteratorComponent),iFile);
		else if((*iteratorComponent)->is<Mesh>()) SerializerHelpers::Save((Mesh*)(*iteratorComponent),iFile);
		else if((*iteratorComponent)->is<Bone>()) WriteComponentCode(Serializer::Bone,iFile);
		else
			DEBUG_BREAK();
	}

	if(childsSize)
	{
		for(std::list<Entity*>::iterator eIter=iEntity->childs.begin();eIter!=iEntity->childs.end();eIter++)
			saveSceneEntityRecursively(*eIter,iFile);
	}
}



EditorEntity* SerializerHelpers::loadSceneEntityRecursively(EditorEntity* iEditorEntityParent,FILE* iFile)
{
	unsigned int componentsSize;
	unsigned int childsSize;
	int componentCode;

	EditorEntity* tEditorEntity=new EditorEntity;

	if(iEditorEntityParent)
		iEditorEntityParent->AddEntity(tEditorEntity);

	fread(&childsSize,sizeof(unsigned int),1,iFile);
	fread(&tEditorEntity->id,sizeof(unsigned int),1,iFile);

	fread(tEditorEntity->local,sizeof(float),16,iFile);
	fread(tEditorEntity->world,sizeof(float),16,iFile);

	StringUtils::ReadWstring(iFile,tEditorEntity->name);

	fread(tEditorEntity->bbox.a,sizeof(float),3,iFile);
	fread(tEditorEntity->bbox.b,sizeof(float),3,iFile);

	fread(&componentsSize,sizeof(unsigned int),1,iFile);

	for(int tComponentIndex=0;tComponentIndex<componentsSize;tComponentIndex++)
	{
		fread(&componentCode,sizeof(int),1,iFile);

		switch(componentCode)
		{
			case Serializer::Script: SerializerHelpers::Load(tEditorEntity->CreateComponent<EditorScript>(),iFile); break;
			case Serializer::Line: SerializerHelpers::Load(tEditorEntity->CreateComponent<EditorLine>(),iFile); break;
			case Serializer::Animation: SerializerHelpers::Load(tEditorEntity->CreateComponent<EditorAnimation>(),iFile); break;
			case Serializer::AnimationController: SerializerHelpers::Load(tEditorEntity->CreateComponent<EditorAnimationController>(),iFile); break; 
			case Serializer::Mesh: SerializerHelpers::Load(tEditorEntity->CreateComponent<EditorMesh>(),iFile); break;
			case Serializer::Skin: SerializerHelpers::Load(tEditorEntity->CreateComponent<EditorSkin>(),iFile); break;
			/*default:
				DEBUG_BREAK();*/
		}

		if(tEditorEntity->Components().back())
		{
			EditorObjectBase* tEditorObjectBase=dynamic_cast<EditorObjectBase*>(tEditorEntity->Components().back());
			
			if(tEditorObjectBase)
				tEditorObjectBase->OnResourcesCreate();
		}
	}

	if(childsSize)
	{
		for(int i=0;i<childsSize;i++)
			loadSceneEntityRecursively(tEditorEntity,iFile);
	}

	BindSkinLinks(tEditorEntity);
	BindAnimationLinks(tEditorEntity);

	tEditorEntity->OnResourcesCreate();
	tEditorEntity->OnPropertiesCreate();

	return tEditorEntity;
}

void SerializerHelpers::WriteComponentCode(int iCode,FILE* iFile)
{
	fwrite(&iCode,sizeof(int),1,iFile);
}