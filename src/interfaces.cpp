#include "interfaces.h"

#include "imgpng.h"
#include "imgjpg.h"
#include "imgtga.h"


///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////////AppInterface////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

Ide::Ide():
	timerMain(0),
	mainAppWindow(0),
	compiler(0),
	processId(0),
	processThreadId(0),
	stringEditor(0)
{}

const char* Ide::GetSceneExtension()
{
	return ".engineScene";
}
const char* Ide::GetEntityExtension()
{
	return ".engineEntity";
}

///////////////////////////////////////////////
///////////////////////////////////////////////
///////////EditorWindowContainer///////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

Container::Container()
{
	resizeDiffHeight=0;
	resizeDiffWidth=0;
	resizeEnumType=-1;
	resizeCheckWidth=0;
	resizeCheckHeight=0;
}

///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////////Debugger//////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////
Debugger::Debugger():breaked(false),threadSuspendend(false),runningScript(0),runningScriptFunction(0),debuggerCode(0),lastBreakedAddress(0){}


///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////////TouchInput//////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

TouchInput::TouchInput()
{
	for(int i=0;i<10;i++)
	{
		pressed[i]=0;
		released[i]=0;
		position[i].make(0,0);
	}
}

bool TouchInput::IsPressed(int i){return pressed[i];}
bool TouchInput::IsReleased(int i){return released[i];}

void TouchInput::SetPressed(bool b,int i){pressed[i]=b;}
void TouchInput::SetReleased(bool b,int i){released[i]=b;}


vec2& TouchInput::GetPosition(int i){return position[i];}
void   TouchInput::SetPosition(vec2& pos,int i){position[i]=pos;}

MouseInput::MouseInput()
{}

bool MouseInput::Left(){return this->left;}
bool MouseInput::Right(){return this->right;}
bool MouseInput::Middle(){return this->middle;}

TouchInput InputManager::touchInput;
MouseInput InputManager::mouseInput;
KeyboardInput InputManager::keyboardInput;

/*
InputInterface InputManager::voiceInput;
InputInterface InputManager::joystickInput;*/


///////////////////////////////////////////////
///////////////////////////////////////////////
//////////////////TabContainer/////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

unsigned char Tab::rawUpArrow[]={0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0xa7,0x0,0x0,0x0,0xa8,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x87,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0x88,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6a,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0x6b,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4b,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0x4c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2b,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xfe,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xfe,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0x2c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xb,0x0,0x0,0x0,0xfa,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xfb,0x0,0x0,0x0,0xc,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7,0x0,0x0,0x0,0xdc,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xdc,0x0,0x0,0x0,0x7,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc,0x0,0x0,0x0,0xe7,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xe7,0x0,0x0,0x0,0xc,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0};
unsigned char Tab::rawRightArrow[]={0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc,0x0,0x0,0x0,0x7,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe7,0x0,0x0,0x0,0xdc,0x0,0x0,0x0,0xb,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xfa,0x0,0x0,0x0,0x2b,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0x4b,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xfe,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0x6a,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0x87,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xa7,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xa8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0x88,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xfe,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0x6b,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0x4c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xfb,0x0,0x0,0x0,0x2c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe7,0x0,0x0,0x0,0xdc,0x0,0x0,0x0,0xc,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc,0x0,0x0,0x0,0x7,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0};
unsigned char Tab::rawLeftArrow[]={0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x07,0x0,0x0,0x0,0x0c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0c,0x0,0x0,0x0,0xdc,0x0,0x0,0x0,0xe7,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2c,0x0,0x0,0x0,0xfb,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4c,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6b,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xfe,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x01,0x0,0x0,0x0,0x88,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa8,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa7,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x01,0x0,0x0,0x0,0x87,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6a,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xfe,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4b,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2b,0x0,0x0,0x0,0xfa,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0b,0x0,0x0,0x0,0xdc,0x0,0x0,0x0,0xe7,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x07,0x0,0x0,0x0,0x0c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0};
unsigned char Tab::rawDownArrow[]={0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc,0x0,0x0,0x0,0xe7,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xe7,0x0,0x0,0x0,0xc,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7,0x0,0x0,0x0,0xdc,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xdc,0x0,0x0,0x0,0x7,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc,0x0,0x0,0x0,0xfb,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xfa,0x0,0x0,0x0,0xb,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2c,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xfe,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xfe,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0x2b,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4c,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0x4b,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6b,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0x6a,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x88,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0x87,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0xa8,0x0,0x0,0x0,0xa7,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0};
unsigned char Tab::rawFolder[]={0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe6,0xc1,0x9b,0x12,0xe9,0xc4,0x9f,0xd8,0xe9,0xc4,0xa0,0xff,0xe9,0xc4,0xa0,0xff,0xe9,0xc4,0xa0,0xff,0xe9,0xc4,0xa0,0xff,0xe9,0xc4,0xa0,0xff,0xe6,0xc0,0x9a,0x5b,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe5,0xc1,0x9e,0x20,0xe5,0xc2,0x9e,0xef,0xe5,0xc2,0x9e,0xff,0xe5,0xc2,0x9e,0xff,0xe5,0xc2,0x9d,0xff,0xe5,0xc2,0x9d,0xff,0xe5,0xc2,0x9d,0xff,0xe4,0xc2,0x9c,0xa6,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe3,0xbe,0x98,0x21,0xdf,0xb9,0x94,0xee,0xdf,0xb9,0x93,0xff,0xdf,0xb9,0x93,0xff,0xde,0xb9,0x92,0xff,0xde,0xb9,0x93,0xff,0xde,0xb9,0x93,0xff,0xdd,0xb7,0x90,0xe4,0xda,0xb2,0x89,0xa2,0xda,0xb2,0x8a,0xa3,0xda,0xb2,0x8a,0xa3,0xda,0xb2,0x8a,0xa3,0xda,0xb2,0x8a,0x86,0xe6,0xc1,0x97,0xf,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfb,0xda,0xaf,0xd2,0xf7,0xd6,0xab,0xfd,0xf7,0xd6,0xab,0xff,0xf7,0xd6,0xab,0xff,0xf7,0xd6,0xab,0xff,0xf6,0xd6,0xab,0xff,0xf6,0xd6,0xab,0xff,0xf6,0xd6,0xab,0xff,0xf6,0xd5,0xab,0xff,0xf6,0xd5,0xab,0xff,0xf6,0xd5,0xab,0xff,0xf6,0xd5,0xab,0xff,0xf6,0xd5,0xab,0xff,0xfa,0xda,0xaf,0xd7,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf7,0xd5,0xaa,0xff,0xf7,0xd5,0xaa,0xff,0xf7,0xd5,0xaa,0xff,0xf7,0xd5,0xaa,0xff,0xf7,0xd5,0xaa,0xff,0xf7,0xd5,0xaa,0xff,0xf7,0xd5,0xaa,0xff,0xf7,0xd5,0xaa,0xff,0xf7,0xd5,0xaa,0xff,0xf7,0xd5,0xaa,0xff,0xf7,0xd5,0xaa,0xff,0xf7,0xd5,0xaa,0xff,0xf7,0xd5,0xaa,0xff,0xf7,0xd5,0xaa,0xff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf3,0xcf,0xa3,0xff,0xf3,0xcf,0xa3,0xff,0xf3,0xcf,0xa3,0xff,0xf3,0xcf,0xa3,0xff,0xf3,0xcf,0xa3,0xff,0xf3,0xcf,0xa3,0xff,0xf3,0xcf,0xa3,0xff,0xf3,0xcf,0xa3,0xff,0xf3,0xcf,0xa3,0xff,0xf3,0xcf,0xa3,0xff,0xf3,0xcf,0xa3,0xff,0xf3,0xcf,0xa3,0xff,0xf3,0xcf,0xa3,0xff,0xf3,0xcf,0xa3,0xff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xee,0xc8,0x9b,0xff,0xee,0xc8,0x9b,0xff,0xee,0xc8,0x9b,0xff,0xee,0xc8,0x9b,0xff,0xee,0xc8,0x9b,0xff,0xee,0xc8,0x9b,0xff,0xee,0xc8,0x9b,0xff,0xee,0xc8,0x9b,0xff,0xee,0xc8,0x9b,0xff,0xee,0xc8,0x9b,0xff,0xee,0xc8,0x9b,0xff,0xee,0xc8,0x9b,0xff,0xee,0xc8,0x9b,0xff,0xee,0xc8,0x9b,0xff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xea,0xc2,0x95,0xff,0xea,0xc2,0x95,0xff,0xea,0xc2,0x95,0xff,0xea,0xc2,0x95,0xff,0xea,0xc2,0x95,0xff,0xea,0xc2,0x95,0xff,0xea,0xc2,0x95,0xff,0xea,0xc2,0x95,0xff,0xea,0xc2,0x95,0xff,0xea,0xc2,0x95,0xff,0xea,0xc2,0x95,0xff,0xea,0xc2,0x95,0xff,0xea,0xc2,0x95,0xff,0xea,0xc2,0x95,0xff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe5,0xbb,0x8e,0xff,0xe5,0xbb,0x8e,0xff,0xe5,0xbb,0x8e,0xff,0xe5,0xbb,0x8e,0xff,0xe5,0xbb,0x8e,0xff,0xe5,0xbb,0x8e,0xff,0xe5,0xbb,0x8e,0xff,0xe5,0xbb,0x8e,0xff,0xe5,0xbb,0x8e,0xff,0xe5,0xbb,0x8e,0xff,0xe5,0xbb,0x8e,0xff,0xe5,0xbb,0x8e,0xff,0xe5,0xbb,0x8e,0xff,0xe5,0xbb,0x8e,0xff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe1,0xb6,0x87,0xff,0xe1,0xb6,0x87,0xff,0xe1,0xb6,0x87,0xff,0xe1,0xb6,0x87,0xff,0xe1,0xb6,0x87,0xff,0xe1,0xb6,0x87,0xff,0xe1,0xb6,0x87,0xff,0xe1,0xb6,0x87,0xff,0xe1,0xb6,0x87,0xff,0xe1,0xb6,0x87,0xff,0xe1,0xb6,0x87,0xff,0xe1,0xb6,0x87,0xff,0xe1,0xb6,0x87,0xff,0xe1,0xb6,0x87,0xff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xdc,0xb0,0x7f,0xff,0xdc,0xb0,0x7f,0xff,0xdc,0xb0,0x7f,0xff,0xdc,0xb0,0x7f,0xff,0xdc,0xb0,0x7f,0xff,0xdc,0xb0,0x7f,0xff,0xdc,0xb0,0x7f,0xff,0xdc,0xb0,0x7f,0xff,0xdc,0xb0,0x7f,0xff,0xdc,0xb0,0x7f,0xff,0xdc,0xb0,0x7f,0xff,0xdc,0xb0,0x7f,0xff,0xdc,0xb0,0x7f,0xff,0xdc,0xb0,0x7f,0xff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xd8,0xa9,0x78,0xff,0xd8,0xa9,0x78,0xff,0xd8,0xa9,0x78,0xff,0xd8,0xa9,0x78,0xff,0xd8,0xa9,0x78,0xff,0xd8,0xa9,0x78,0xff,0xd8,0xa9,0x78,0xff,0xd8,0xa9,0x78,0xff,0xd8,0xa9,0x78,0xff,0xd8,0xa9,0x78,0xff,0xd8,0xa9,0x78,0xff,0xd8,0xa9,0x78,0xff,0xd8,0xa9,0x78,0xff,0xd8,0xa9,0x78,0xff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xd3,0xa3,0x71,0xff,0xd3,0xa3,0x71,0xff,0xd3,0xa3,0x71,0xff,0xd3,0xa3,0x71,0xff,0xd3,0xa3,0x71,0xff,0xd3,0xa3,0x71,0xff,0xd3,0xa3,0x71,0xff,0xd3,0xa3,0x71,0xff,0xd3,0xa3,0x71,0xff,0xd3,0xa3,0x71,0xff,0xd3,0xa3,0x71,0xff,0xd3,0xa3,0x71,0xff,0xd3,0xa3,0x71,0xff,0xd3,0xa3,0x71,0xff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc9,0x96,0x64,0xe7,0xca,0x97,0x65,0xff,0xca,0x97,0x65,0xff,0xca,0x97,0x65,0xff,0xca,0x97,0x65,0xff,0xca,0x97,0x65,0xff,0xca,0x97,0x65,0xff,0xca,0x97,0x65,0xff,0xca,0x97,0x65,0xff,0xca,0x97,0x65,0xff,0xca,0x97,0x65,0xff,0xca,0x97,0x65,0xff,0xca,0x97,0x65,0xff,0xc9,0x97,0x64,0xf1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0};
unsigned char Tab::rawFile[]={0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc8,0xc8,0xc8,0x4c,0xe0,0xe0,0xe0,0xcd,0xe1,0xe1,0xe1,0xc0,0xe1,0xe1,0xe1,0xbf,0xe1,0xe1,0xe1,0xbf,0xe1,0xe1,0xe1,0xbf,0xe1,0xe1,0xe1,0xc0,0xd6,0xd6,0xd6,0xc4,0xbd,0xbd,0xbd,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc5,0xc5,0xc5,0x70,0xec,0xec,0xec,0xff,0xed,0xed,0xed,0xff,0xed,0xed,0xed,0xff,0xed,0xed,0xed,0xff,0xed,0xed,0xed,0xff,0xee,0xee,0xee,0xff,0xeb,0xeb,0xeb,0xff,0xce,0xce,0xce,0xff,0xbd,0xbd,0xbd,0xa6,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xbe,0xbe,0xbe,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc5,0xc5,0xc5,0x6c,0xec,0xec,0xec,0xff,0xed,0xed,0xed,0xff,0xed,0xed,0xed,0xff,0xed,0xed,0xed,0xff,0xed,0xed,0xed,0xff,0xed,0xed,0xed,0xff,0xef,0xef,0xef,0xff,0xd3,0xd3,0xd3,0xfd,0xe1,0xe1,0xe1,0xff,0xde,0xde,0xde,0xae,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc8,0xc8,0xc8,0x6c,0xee,0xee,0xee,0xff,0xef,0xef,0xef,0xff,0xef,0xef,0xef,0xff,0xef,0xef,0xef,0xff,0xef,0xef,0xef,0xff,0xef,0xef,0xef,0xff,0xf0,0xf0,0xf0,0xff,0xdb,0xdb,0xdb,0xff,0xc0,0xc0,0xc0,0xfe,0xc9,0xc9,0xc9,0xff,0xb9,0xb9,0xb9,0xbd,0x0,0x0,0x0,0x0,0xff,0xff,0xff,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc9,0xc9,0xc9,0x6b,0xf0,0xf0,0xf0,0xff,0xf1,0xf1,0xf1,0xff,0xf1,0xf1,0xf1,0xff,0xf1,0xf1,0xf1,0xff,0xf1,0xf1,0xf1,0xff,0xf1,0xf1,0xf1,0xff,0xf1,0xf1,0xf1,0xff,0xe7,0xe7,0xe7,0xff,0xc3,0xc3,0xc3,0xff,0xb6,0xb6,0xb6,0xfc,0xc2,0xc2,0xc2,0xff,0xbd,0xbd,0xbd,0x95,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xcb,0xcb,0xcb,0x6b,0xf2,0xf2,0xf2,0xff,0xf3,0xf3,0xf3,0xff,0xf3,0xf3,0xf3,0xff,0xf3,0xf3,0xf3,0xff,0xf3,0xf3,0xf3,0xff,0xf3,0xf3,0xf3,0xff,0xf3,0xf3,0xf3,0xff,0xf2,0xf2,0xf2,0xff,0xf2,0xf2,0xf2,0xff,0xf4,0xf4,0xf4,0xff,0xf2,0xf2,0xf2,0xff,0xd5,0xd5,0xd5,0xc0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xcd,0xcd,0xcd,0x6b,0xf4,0xf4,0xf4,0xff,0xf5,0xf5,0xf5,0xff,0xf5,0xf5,0xf5,0xff,0xf5,0xf5,0xf5,0xff,0xf5,0xf5,0xf5,0xff,0xf5,0xf5,0xf5,0xff,0xf5,0xf5,0xf5,0xff,0xf5,0xf5,0xf5,0xff,0xf6,0xf6,0xf6,0xff,0xf6,0xf6,0xf6,0xff,0xf8,0xf8,0xf8,0xff,0xe4,0xe4,0xe4,0xbc,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xcf,0xcf,0xcf,0x6b,0xf6,0xf6,0xf6,0xff,0xf7,0xf7,0xf7,0xff,0xf7,0xf7,0xf7,0xff,0xf7,0xf7,0xf7,0xff,0xf7,0xf7,0xf7,0xff,0xf7,0xf7,0xf7,0xff,0xf7,0xf7,0xf7,0xff,0xf7,0xf7,0xf7,0xff,0xf7,0xf7,0xf7,0xff,0xf7,0xf7,0xf7,0xff,0xf9,0xf9,0xf9,0xff,0xe5,0xe5,0xe5,0xbc,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xd0,0xd0,0xd0,0x6b,0xf8,0xf8,0xf8,0xff,0xf9,0xf9,0xf9,0xff,0xf9,0xf9,0xf9,0xff,0xf9,0xf9,0xf9,0xff,0xf9,0xf9,0xf9,0xff,0xf9,0xf9,0xf9,0xff,0xf9,0xf9,0xf9,0xff,0xf9,0xf9,0xf9,0xff,0xf9,0xf9,0xf9,0xff,0xf9,0xf9,0xf9,0xff,0xfb,0xfb,0xfb,0xff,0xe8,0xe8,0xe8,0xbc,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xd2,0xd2,0xd2,0x6b,0xf9,0xf9,0xf9,0xff,0xfa,0xfa,0xfa,0xff,0xfa,0xfa,0xfa,0xff,0xfa,0xfa,0xfa,0xff,0xfa,0xfa,0xfa,0xff,0xfa,0xfa,0xfa,0xff,0xfa,0xfa,0xfa,0xff,0xfa,0xfa,0xfa,0xff,0xfa,0xfa,0xfa,0xff,0xfa,0xfa,0xfa,0xff,0xfc,0xfc,0xfc,0xff,0xe9,0xe9,0xe9,0xbb,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xd3,0xd3,0xd3,0x6b,0xfb,0xfb,0xfb,0xff,0xfc,0xfc,0xfc,0xff,0xfc,0xfc,0xfc,0xff,0xfc,0xfc,0xfc,0xff,0xfc,0xfc,0xfc,0xff,0xfc,0xfc,0xfc,0xff,0xfc,0xfc,0xfc,0xff,0xfc,0xfc,0xfc,0xff,0xfc,0xfc,0xfc,0xff,0xfc,0xfc,0xfc,0xff,0xfe,0xfe,0xfe,0xff,0xeb,0xeb,0xeb,0xbb,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xd4,0xd4,0xd4,0x6b,0xfc,0xfc,0xfc,0xff,0xfd,0xfd,0xfd,0xff,0xfd,0xfd,0xfd,0xff,0xfd,0xfd,0xfd,0xff,0xfd,0xfd,0xfd,0xff,0xfd,0xfd,0xfd,0xff,0xfd,0xfd,0xfd,0xff,0xfd,0xfd,0xfd,0xff,0xfd,0xfd,0xfd,0xff,0xfd,0xfd,0xfd,0xff,0xff,0xff,0xff,0xff,0xec,0xec,0xec,0xbb,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xd4,0xd4,0xd4,0x6b,0xfd,0xfd,0xfd,0xff,0xfe,0xfe,0xfe,0xff,0xfe,0xfe,0xfe,0xff,0xfe,0xfe,0xfe,0xff,0xfe,0xfe,0xfe,0xff,0xfe,0xfe,0xfe,0xff,0xfe,0xfe,0xfe,0xff,0xfe,0xfe,0xfe,0xff,0xfe,0xfe,0xfe,0xff,0xfe,0xfe,0xfe,0xff,0xff,0xff,0xff,0xff,0xec,0xec,0xec,0xbb,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xd5,0xd5,0xd5,0x6a,0xfd,0xfd,0xfd,0xff,0xfe,0xfe,0xfe,0xff,0xfe,0xfe,0xfe,0xff,0xfe,0xfe,0xfe,0xff,0xfe,0xfe,0xfe,0xff,0xfe,0xfe,0xfe,0xff,0xfe,0xfe,0xfe,0xff,0xfe,0xfe,0xfe,0xff,0xfe,0xfe,0xfe,0xff,0xfe,0xfe,0xfe,0xff,0xff,0xff,0xff,0xff,0xed,0xed,0xed,0xbb,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xdb,0xdb,0xdb,0x70,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf1,0xf1,0xf1,0xc5,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa4,0xa4,0xa4,0x41,0xbc,0xbc,0xbc,0xab,0xbb,0xbb,0xbb,0xa2,0xbb,0xbb,0xbb,0xa1,0xbb,0xbb,0xbb,0xa1,0xbb,0xbb,0xbb,0xa1,0xbb,0xbb,0xbb,0xa1,0xbb,0xbb,0xbb,0xa1,0xbb,0xbb,0xbb,0xa1,0xbb,0xbb,0xbb,0xa2,0xbb,0xbb,0xbb,0xa2,0xbd,0xbd,0xbd,0xaa,0xb4,0xb4,0xb4,0x73,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x4,0x0,0x0,0x0,0x5,0x0,0x0,0x0,0x5,0x0,0x0,0x0,0x5,0x0,0x0,0x0,0x5,0x0,0x0,0x0,0x5,0x0,0x0,0x0,0x5,0x0,0x0,0x0,0x5,0x0,0x0,0x0,0x5,0x0,0x0,0x0,0x5,0x0,0x0,0x0,0x5,0x0,0x0,0x0,0x5,0x0,0x0,0x0,0x5,0x0,0x0,0x0,0x4,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0};






GuiRect* Tab::focusedGlobal=0;

Tab::Tab(float x,float y,float w,float h):
tabs(this),
	windowData(0),
	parentWindowContainer(0),
	selected(0),
	mouseDown(false),
	isRender(false),
	splitterContainer(0),
	renderer3D(0),
	renderer2D(0),
	recreateTarget(false),
	resizeTarget(true),
	resizing(false),
	lastFrameTime(0),
	iconUp(0),
	iconLeft(0),
	iconRight(0),
	iconDown(0),
	iconFolder(0),
	iconFile(0),
	threadRender(0),
	focused(0)
{}

Tab::~Tab()
{
	printf("deleting TabContainer %p\n",this);
}

GuiRect* Tab::GetSelected()
{
	return selected<tabs.childs.size() ? tabs.childs[selected] : 0;
}

void Tab::Draw()
{
	if(this->taskDraw->pause)
		DEBUG_BREAK();

	if(!this->drawInstances.empty())
	{
		DrawInstance*& tDrawInstance=this->drawInstances.front();

		if(!tDrawInstance)
			DEBUG_BREAK();

		if(tDrawInstance->code || tDrawInstance->frame)
		{
			if(this->BeginDraw())
			{
				if(tDrawInstance->frame)
					this->DrawFrame();

				switch(tDrawInstance->code)
				{
				case 1:this->OnGuiPaint();break;
				case 2:tDrawInstance->rect->OnPaint(this);break;
				}

				this->EndDraw();
			}
		}

		if(tDrawInstance->remove)
		{
			SAFEDELETE(tDrawInstance);
			this->drawInstances.pop_front();
		}
	}
	else if(Timer::instance->GetTime()-this->lastFrameTime>(1000.0f/Timer::instance->renderFps))
	{
		this->lastFrameTime=Timer::instance->GetTime();
		this->renderer3D->Render();
	}

	Ide::instance->stringEditor->Draw(this);
}

DrawInstance* Tab::SetDraw(int iNoneAllRect,bool iFrame,GuiRect* iRect,const char* iName,bool iRemove)
{
	DrawInstance* newInstance=new DrawInstance(iNoneAllRect,iFrame,iRect,iName,iRemove);
	this->drawInstances.push_back(newInstance);
	return newInstance;
}

void Tab::BroadcastToSelected(void (GuiRect::*func)(Tab*,void*),void* data)
{
	GuiRect* selectedTab=this->GetSelected();

	if(selectedTab)
		(selectedTab->*func)(this,data);
}

void Tab::BroadcastToAll(void (GuiRect::*func)(Tab*,void*),void* data)
{
	(this->tabs.*func)(this,data);
}


template<class C> void Tab::BroadcastToSelected(void (GuiRect::*func)(Tab*,void*),void* data)
{
	GuiRect* selectedTab=this->GetSelected();

	if(selectedTab)
		selectedTab->BroadcastTo<C>(func,data);
}

template<class C> void Tab::BroadcastToAll(void (GuiRect::*func)(Tab*,void*),void* data)
{
	this->tabs.BroadcastTo<C>(func,data);
}


void Tab::SetSelection(GuiRect* iRect)
{
	this->BroadcastToSelected(&GuiRect::OnDeactivate);

	for(size_t i=0;i<this->tabs.childs.size();i++)
	{
		if(iRect==this->tabs.childs[i])
		{
			this->selected=i;
			break;
		}
	}

	this->BroadcastToSelected(&GuiRect::OnActivate);
	this->BroadcastToSelected(&GuiRect::OnSize);

	this->SetDraw();
}


void Tab::OnGuiSize(void* data)
{
	this->windowData->OnSize();

	this->tabs.rect.make(0.0f,(float)Tab::CONTAINER_HEIGHT,this->windowData->width,this->windowData->height-Tab::CONTAINER_HEIGHT);
	this->tabs.edges.x=0;
	this->tabs.edges.y=(float)Tab::CONTAINER_HEIGHT;
	this->tabs.edges.z=this->windowData->width;
	this->tabs.edges.w=this->windowData->height;

	this->BroadcastToSelected(&GuiRect::OnSize,data);

	this->resizeTarget=true;
}

void Tab::OnWindowPosChanging(void* data)
{
	this->resizeTarget=true;

	this->windowData->OnWindowPosChanging();

	this->tabs.rect.make(0,Tab::CONTAINER_HEIGHT,this->windowData->width,this->windowData->height-Tab::CONTAINER_HEIGHT);
	this->tabs.edges.x=0;
	this->tabs.edges.y=(float)Tab::CONTAINER_HEIGHT;
	this->tabs.edges.z=this->windowData->width;
	this->tabs.edges.w=this->windowData->height;

	this->BroadcastToSelected(&GuiRect::OnSize,data);
}

void Tab::OnGuiMouseMove(void* data)
{
	splitterContainer->currentTabContainer=this;

	/*if(mouseDown && tmx!=mousex && tmy!=mousey)
		splitterContainer->CreateFloatingTab(this);

	mousex=tmx;
	mousey=tmy;*/

	//if(mousey>TabContainer::CONTAINER_HEIGHT)
	this->BroadcastToSelected(&GuiRect::OnMouseMove,vec2(this->mousex,this->mousey));
}

void Tab::OnGuiLMouseUp(void* data)
{
	mouseDown=false;

	this->BroadcastToSelected(&GuiRect::OnLMouseUp,vec2(this->mousex,this->mousey));
}

void Tab::OnGuiMouseWheel(void* data)
{

}

void Tab::OnGuiLMouseDown(void* data)
{
	//this->OnGuiMouseMove();


	float &x=this->mousex;
	float &y=this->mousey;


	if(y<=CONTAINER_HEIGHT)
	{
		int tPreviousTabSelected=selected;

		for(int i=0;i<(int)tabs.childs.size();i++)
		{
			bool tMouseContained=x>(i*TAB_WIDTH) && x< (i*TAB_WIDTH+TAB_WIDTH) && y > (CONTAINER_HEIGHT-TAB_HEIGHT) &&  y<CONTAINER_HEIGHT;

			if(tMouseContained)// && tPreviousTabSelected!=i)
			{

				mouseDown=true;

				this->SetSelection(tabs.childs[i]);

				break;
			}
		}
	}
	else
	{
		this->BroadcastToSelected(&GuiRect::OnLMouseDown,vec2(this->mousex,this->mousey));
	}
}

void Tab::OnGuiDLMouseDown(void* data)
{
	if(this->mousey>CONTAINER_HEIGHT)
		this->BroadcastToSelected(&GuiRect::OnDLMouseDown,vec2(this->mousex,this->mousey));
}


void Tab::OnGuiUpdate(void* data)
{
	this->BroadcastToSelected(&GuiRect::OnUpdate,data);
}

void Tab::OnGuiRMouseUp(void* data)
{
	this->BroadcastToSelected(&GuiRect::OnRMouseUp,data);
}

void Tab::OnGuiRender(void* data)
{
	this->BroadcastToSelected(&GuiRect::OnRender,data);
}

void Tab::DrawFrame()
{

}

void Tab::OnGuiPaint(void* data)
{

}

void Tab::OnResizeContainer(void* data)
{

}

void Tab::OnEntitiesChange(void* data)
{
	this->BroadcastToSelected(&GuiRect::OnEntitiesChange,data);
}
void Tab::OnGuiActivate(void* data)
{
	this->BroadcastToSelected(&GuiRect::OnActivate,data);


}
void Tab::OnGuiDeactivate(void* data)
{
	this->BroadcastToSelected(&GuiRect::OnDeactivate,data);
}
void Tab::OnGuiEntitySelected(void* data)
{
	this->BroadcastToSelected(&GuiRect::OnEntitySelected,data);
}

void Tab::OnGuiKeyDown(void* data)
{
	this->BroadcastToSelected(&GuiRect::OnKeyDown,data);
}

void Tab::OnGuiKeyUp(void* data)
{
	this->BroadcastToSelected(&GuiRect::OnKeyUp,data);
}

void Tab::OnGuiRecreateTarget(void* data)
{
	this->BroadcastToSelected(&GuiRect::OnRecreateTarget,data);
}

void Tab::SetFocus(GuiRect* iFocusedRect)
{
	if(this->GetFocus() && this->GetFocus()!=iFocusedRect)
		this->GetFocus()->OnExitFocus(this,this->GetFocus());

	this->focusedGlobal=this->focused=iFocusedRect;

	if(this->focusedGlobal)
		this->focusedGlobal->OnEnterFocus(this,this->focusedGlobal);
}

GuiRect* Tab::GetFocus()
{
	return this->focusedGlobal;
}


///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////SplitterContainer///////////////
///////////////////////////////////////////////
///////////////////////////////////////////////
Splitter::Splitter():
splitterSize(4)
{
	floatingTabRef=0;
	floatingTab=0;
	floatingTabTarget=0;
	floatingTabRefTabIdx=-1;
	floatingTabRefTabCount=-1;
	floatingTabTargetAnchorPos=-1;
	floatingTabTargetAnchorTabIndex=-1;

	splitterCursor="IDC_ARROW";
}
Splitter::~Splitter()
{
}

///////////////////////////////////////////////
///////////////////////////////////////////////
//////////////////GuiCaret///////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

StringEditor::Cursor::Cursor():cursor(0){}

StringEditor::StringEditor():
	string(0),
	tab(0),
	lastBlinkTime(0),
	blinking(false),
	enabled(false),
	blinkingRate(BLINKRATE),
	recalcBackground(false)
{}

void StringEditor::Bind(GuiString* iString,Cursor* iCursor)
{
	this->string=iString;
	this->tab=iString->GetRootRect()->tabContainer;
	this->cursor=iCursor;

	if(!this->cursor)
		this->cursor=new Cursor;

	if(!this->cursor->cursor)
		this->cursor->cursor=(char*)iString->text.c_str();

	this->EditText(CARET_RECALC,0);
}

void StringEditor::Enable(bool iEnable)
{
	this->enabled=iEnable;
}


bool StringEditor::EditText(unsigned int iCaretOp,void* iParam)
{
	float tFontHeight=tab->renderer2D->GetFontHeight();

	bool tMustResize=false;

	switch(iCaretOp)
	{
	case CARET_RECALC:
		{
			char*	pText=(char*)this->string->text.c_str();

			bool tCarriageReturn=false;
			int tCharWidth=0;

			this->cursor->caret=vec4(this->string->textEdges.x,this->string->textEdges.y,0,tFontHeight);

			while(*pText)
			{
				if(tCarriageReturn)
				{
					this->cursor->caret.x=0;
					this->cursor->caret.y+=tFontHeight;
					
					this->cursor->rowcol.x+=1;
					this->cursor->rowcol.y=0;

					tCarriageReturn=false;
				}

				tCharWidth=tab->renderer2D->GetCharWidth(*pText);

				if(*pText=='\n' ||  *pText=='\r')
					tCarriageReturn=true;

				this->cursor->caret.z=tCharWidth;

				if(pText==this->cursor->cursor)
					break;

				this->cursor->caret.x+=tCharWidth;
				this->cursor->rowcol.y+=1;

				pText++;
			}

			break;
		}
		case CARET_CANCEL:
		{
			if(this->string->text.empty() || this->cursor->cursor==(char*)this->string->text.back())
				return false;

			std::string::iterator sIt=this->string->text.begin()+this->cursor->rowcol.y;

			if(sIt!=this->string->text.end())
				this->string->text.erase(sIt);

			break;
		}
		case CARET_BACKSPACE:
		{
			if(this->cursor->cursor==this->string->text.c_str())
				return false;

			char tCharCode=*(--this->cursor->cursor);

			if(tCharCode=='\n' ||  tCharCode=='\r')
			{
				//find previous row length
				char*			pText=this->cursor->cursor-1;
				unsigned int	tRowCharsWidth=0;
				unsigned int    tRowCharCount=0;

				while(*pText!='\n' &&  *pText!='\r')
				{
					tRowCharsWidth+=tab->renderer2D->GetCharWidth(*pText);

					if(pText==(char*)this->string->text.c_str())
						break;

					pText--;
					tRowCharCount++;

				}

				this->cursor->caret.x=tRowCharsWidth;
				this->cursor->caret.y-=tFontHeight;
				this->cursor->rowcol.x--;
				this->cursor->rowcol.y=tRowCharCount;

				tMustResize=true;
			}
			else
			{
				this->cursor->caret.x-=tab->renderer2D->GetCharWidth(tCharCode);
				this->cursor->rowcol.y--;
			}

			this->string->text.erase(this->cursor->cursor-this->string->text.c_str(),1);

			break;
		}
		case CARET_ADD:
		{
			char tCharcode=*(char*)iParam;

			tCharcode=='\r' ? tCharcode='\n' : 0;

			if(tCharcode=='\n' || tCharcode=='\r')
			{
				this->cursor->caret.x=0;
				this->cursor->caret.y+=tFontHeight;
				this->cursor->rowcol.x++;
				this->cursor->rowcol.y=0;
				tMustResize=true;
			}
			else
			{
				this->cursor->caret.x+=tab->renderer2D->GetCharWidth(tCharcode);
				this->cursor->rowcol.y++;
			}

			size_t tPosition=this->cursor->cursor-this->string->text.c_str();

			this->string->text.insert(tPosition,1,tCharcode);
			this->cursor->cursor=(char*)this->string->text.c_str()+tPosition+1;

			break;
		}
		case CARET_ARROWLEFT:
		{
			if(this->cursor->cursor==this->string->text.c_str())
				return false;

			char tCharCode=*(--this->cursor->cursor);

			if(tCharCode=='\n' ||  tCharCode=='\r')
			{
				char*			pText=this->cursor->cursor;
				unsigned int	tRowLenght=0;
				unsigned int    tRowCharCount=0;

				//find previous row lengthc

				while(true)
				{
					if(this->cursor->cursor!=pText && (*pText=='\n' || *pText=='\r'))
						break;

					tRowLenght+=tab->renderer2D->GetCharWidth(*pText);

					if(pText==this->string->text.c_str())
						break;

					pText--;
					tRowCharCount++;
				}

				this->cursor->caret.x=tRowLenght;
				this->cursor->caret.y-=tFontHeight;
				this->cursor->rowcol.x--;
				this->cursor->rowcol.y=tRowCharCount;
			}
			else
			{
				this->cursor->caret.x-=tab->renderer2D->GetCharWidth(tCharCode);
				this->cursor->rowcol.y--;
			}

			break;
		}
		case CARET_ARROWRIGHT:
		{
			char tCharCode=*this->cursor->cursor;

			if(tCharCode=='\0')
				break;

			if(tCharCode=='\n' || tCharCode=='\r')
			{
				this->cursor->caret.x=0;
				this->cursor->caret.y+=tFontHeight;
				this->cursor->rowcol.x++;
				this->cursor->rowcol.y=0;
			}
			else
			{
				this->cursor->caret.x+=tab->renderer2D->GetCharWidth(tCharCode);
				this->cursor->rowcol.y++;
			}

			this->cursor->cursor++;

			break;
		}
		case CARET_ARROWUP:
		{
			unsigned int tRowCharWidth=0;
			unsigned int tColumn=0;

			//---find current rowhead

			char* pText=this->cursor->cursor;

			//skip the tail of the current row if present
			if(*pText=='\r' || *pText=='\n')
				pText--;

			//find the last upper row or the head of the current row
			while( pText!=this->string->text.c_str() && *pText!='\r' &&  *pText!='\n' )
				pText--;

			//return if no previous row exists
			if(pText==this->string->text.c_str())
				return false;

			//go to the upper row pre-carriage char
			pText--;

			//find the last upper superior row or the head of the upper row
			while( pText!=this->string->text.c_str() && *pText!='\r' &&  *pText!='\n' )
				pText--;

			//go to the upper superior row pre-carriage char
			if(pText!=this->string->text.c_str())
				pText++;

			//finally found the upper matching position
			while( tColumn!=this->cursor->rowcol.y && *pText!='\0' && *pText!='\r' && *pText!='\n' )
			{
				tRowCharWidth+=tab->renderer2D->GetCharWidth(*pText);

				pText++;
				tColumn++;
			}

			this->cursor->cursor=pText;
			this->cursor->caret.x=tRowCharWidth;
			this->cursor->caret.y-=tFontHeight;
			this->cursor->rowcol.y=tColumn;
			this->cursor->rowcol.x--;

			break;
		}
		case CARET_ARROWDOWN:
		{
			unsigned int tRowCharWidth=0;
			unsigned int tColumn=0;

			//find current rowtail

			char* pText=this->cursor->cursor;

			while( *pText!='\0' && *pText!='\r' && *pText!='\n' )
			{
				this->cursor->cursor++;
				pText++;
			}

			if(*pText=='\0')
				return false; //no previous row exists

			pText++;
			this->cursor->cursor++;

			//finally found the lower matching position

			while( tColumn!=this->cursor->rowcol.y && *pText!='\0' && *pText!='\r' && *pText!='\n' )
			{
				tRowCharWidth+=tab->renderer2D->GetCharWidth(*pText);

				pText++;
				this->cursor->cursor++;
				tColumn++;
			}

			/*if(tColumn!=this->cursor->rowcol.y)//string is shorter of the lower matching position
				tRowCharWidth*/

			this->cursor->caret.x=tRowCharWidth;
			this->cursor->caret.y+=tFontHeight;
			this->cursor->rowcol.y=tColumn;
			this->cursor->rowcol.x++;

			break;
		}
	}

	if(tMustResize)
		this->string->OnSize(this->tab);

	this->recalcBackground=true;

	//printf("cursor: %d,col: %d\n",this->cursor->cursor-this->string->text.c_str(),this->cursor->rowcol.y);
}

///////////////////////////////////////////////
///////////////////////////////////////////////
//////////////////Renderer2D///////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

Renderer2D::Renderer2D(Tab* iTabContainer):
	tabContainer(iTabContainer),
	tabSpaces(4)
{}


///////////////////////////////////////////////
///////////////////////////////////////////////
/////////////Renderer3DInterface///////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

Renderer3D::Renderer3D(Tab* iTabContainer):
	tabContainer(iTabContainer)
{

}

bool Renderer3D::Block()
{
	this->tabContainer->taskDraw->pause=true;

	while(this->tabContainer->taskDraw->executing);

	return true;
}
bool Renderer3D::Release()
{
	this->tabContainer->taskDraw->pause=false;
	return true;
}

void Renderer3D::Register(GuiViewport* iViewport)
{
	if(this->viewports.end()==std::find(this->viewports.begin(),this->viewports.end(),iViewport))
		this->viewports.push_back(iViewport);
}
void Renderer3D::Unregister(GuiViewport* iViewport)
{
	this->viewports.remove(iViewport);
}

Shader* Renderer3D::FindShader(const char* name,bool exact)
{
	for(size_t i=0;i<this->shaders.size();i++)
	{
		Shader* element=this->shaders[i];

		const char* programName=element->GetName();

		if(element && programName)
			if(exact ? 0==strcmp(programName,name) :  0!=strstr(programName,name))
				return this->shaders[i];
	}

	return 0;
}

void Renderer3D::SetMatrices(const float* view,const float* mdl)
{
	for(size_t i=0;i<this->shaders.size();i++)
	{
		this->shaders[i]->Use();

		if(view)
			this->shaders[i]->SetProjectionMatrix((float*)view);
		if(mdl)
			this->shaders[i]->SetModelviewMatrix((float*)mdl);
	}
}

bool Renderer3D::LoadTexture(String iFilename,Texture* iTexture)
{
    FILE *tFile=fopen(iFilename.Buffer(),"rb");

	if(tFile)
	{
		short int bmp_signature=0x4d42;
		int jpg_signature1=0xe0ffd8ff;
		int jpg_signature2=0xdbffd8ff;
		int jpg_signature3=0xe1ffd8ff;
		int png_signature1=0x474e5089;
		int png_signature2=0x0a1a0a0d;

		int sign1;
		int sign2;

		fread(&sign1,4,1,tFile);
		fread(&sign2,4,1,tFile);

		if(bmp_signature==(short int)sign1)
		{

            //@mic only for bitmap
            fseek(tFile,0x12,SEEK_SET);
            fread(&iTexture->m_width,2,1,tFile);
            fseek(tFile,0x16,SEEK_SET);
            fread(&iTexture->m_height,2,1,tFile);
            fseek(tFile,0x1c,SEEK_SET);
            fread(&iTexture->m_bpp,2,1,tFile);

            rewind(tFile);


            fseek(tFile,0,SEEK_END);
            iTexture->m_bufsize=ftell(tFile)-54;
            rewind(tFile);
            fseek(tFile,54,SEEK_SET);

            iTexture->m_buf=new unsigned char[iTexture->m_bufsize];

            fread(iTexture->m_buf,1,iTexture->m_bufsize,tFile);

            fclose(tFile);

            return true;

		}
		else if(jpg_signature1==sign1 || jpg_signature3==sign1 || jpg_signature2==sign2  || jpg_signature3==sign2 )
		{
			fclose(tFile);

            {
                int ncomp;

                iTexture->m_buf=jpgd::decompress_jpeg_image_from_file(iFilename.Buffer(),&iTexture->m_width,&iTexture->m_height,&ncomp,4);

                return iTexture->m_buf ? true : false;
            }

		}
		else if(png_signature1==sign1 && png_signature2==sign2)
		{
			fclose(tFile);

			{
			    std::vector<unsigned char> image;
                unsigned long w, h;
                int error=-1;

                {
                    std::string filename=iFilename.Buffer();
                    std::vector<unsigned char> buffer;
                    loadFile(buffer, filename);

                    error = decodePNG(image, w, h, buffer.empty() ? 0 : &buffer[0], (unsigned long)buffer.size());
                }

                if(!error)
                {
                    iTexture->m_bufsize=image.size();
                    iTexture->m_buf=new unsigned char[iTexture->m_bufsize];
                    memcpy(iTexture->m_buf,&image[0],iTexture->m_bufsize);
                    iTexture->m_width=w;
                    iTexture->m_height=h;

                    return true;
                }

                return false;
			}
		}
		else if(655360==sign1 && 0==sign2)
		{
			fclose(tFile);
			return LoadTGA(iFilename.Buffer(),iTexture->m_buf,iTexture->m_bufsize,iTexture->m_width,iTexture->m_height,iTexture->m_bpp);
		}

		fclose(tFile);
	}

	return false;

}


///////////////////////////////////////////////
///////////////////////////////////////////////
////////////////////GuiRect////////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

GuiRect::GuiRect(GuiRect* iParent,float ix, float iy, float iw,float ih,vec2 _alignPos,vec2 _alignRect):
	colorBackground(Renderer2D::COLOR_GUI_BACKGROUND),
	colorForeground(Renderer2D::COLOR_TEXT),
	colorHovering(colorBackground),
	colorPressing(colorBackground),
	colorChecked(colorBackground),
	pressing(false),
	hovering(false),
	checked(false),
	active(false),
	clip(0),
	scalars(1,1,1,1),
	minimums(0,0)
{
	this->SetEdges();
	this->SetParent(iParent);
	this->fixed.make(ix,iy,iw,ih);
}

GuiRect::~GuiRect()
{

}

void GuiRect::SetParent(GuiRect* iParent)
{
	GuiRect* oldParent=this->parent;
	this->parent=iParent;

	if(oldParent)
		oldParent->childs.erase(std::find(oldParent->childs.begin(),oldParent->childs.end(),this));

	if(this->parent)
	{
		/*
		std::vector<GuiRect*>::reverse_iterator tLastRectIterator=iParent->childs.rbegin();

		int tIterTries=0;
		while(tIterTries++<2 && tLastRectIterator!=iParent->childs.rend() && dynamic_cast<GuiScrollBar*>(*tLastRectIterator))
			tLastRectIterator++;

		this->parent->childs.insert(tLastRectIterator.base(),this);
		*/

		this->parent->childs.push_back(this);

		if(this->parent->clip)
			this->SetClip(this->parent->clip);
	}

	this->active=iParent ? iParent->active : 0;
}

void GuiRect::CalcRect()
{
	if(this->parent)
	{
		Edges &re=this->refedges;
		vec4  &o=this->offsets;
		vec4  &s=this->scalars;
		vec4  &e=this->edges;
		vec4  &r=this->rect;
		vec4  &f=this->fixed;
		vec2  &m=this->minimums;

		Edges &pre=this->parent->refedges;
		vec4  &po=this->parent->offsets;
		vec4  &ps=this->parent->scalars;
		vec4  &pe=this->parent->edges;
		vec4  &pf=this->parent->fixed;

		float tLeft= (re.left ? *re.left : (f.x ? f.x : pe.x)) + (o.x);
		float tTop= (re.top ? *re.top : (f.y ? f.y : pe.y)) + (o.y);
		float tRight= (re.right ? *re.right : (f.z ? tLeft+f.z : pe.z)) + (o.z);
		float tBottom= (re.bottom ? *re.bottom : (f.w ? tTop+f.w : pe.w)) + (o.w);

		tLeft += s.x!=1 ? (tRight-tLeft)*s.x : 0;
		tTop += s.y!=1 ? (tBottom-tTop)*s.y : 0;

		float tWidth=tRight-tLeft;
		float tHeight=tBottom-tTop;

		tWidth=(tWidth<m.x) ? m.x : tWidth;
		tHeight=(tHeight<m.y) ? m.y : tHeight;

		e.make(tLeft,tTop,tLeft+tWidth,tTop+tHeight);
		r.make(tLeft,tTop,tWidth,tHeight);
	}
}



void GuiRect::SetEdges(float* iLeft,float* iTop,float* iRight,float* iBottom)
{
	this->refedges.left=iLeft;
	this->refedges.top=iTop;
	this->refedges.right=iRight;
	this->refedges.bottom=iBottom;
}

bool GuiRect::_contains(vec4& quad,vec2 point)
{
	return (point.x>quad.x && point.x<(quad.x+quad.z) && point.y>quad.y && point.y<(quad.y+quad.w));
}

void GuiRect::BroadcastToChilds(void (GuiRect::*func)(Tab*,void*),Tab* tabContainer,void* data)
{
	for(std::vector<GuiRect*>::iterator tRect=this->childs.begin();tRect!=this->childs.end();tRect++)
		((*tRect)->*func)(tabContainer,data);
}

void GuiRect::BroadcastToRoot(void (GuiRect::*func)(Tab*,void*),void* data)
{
	GuiRootRect* root=dynamic_cast<GuiRootRect*>(this->GetRoot());

	if(root)
		(root->*func)(root->tabContainer,data);
}




void GuiRect::OnEntitiesChange(Tab* tabContainer,void* data)
{
	this->BroadcastToChilds(&GuiRect::OnEntitiesChange,tabContainer,data);
}

void GuiRect::DrawBackground(Tab* tabContainer)
{
	unsigned int tCurrentColor=this->pressing ? this->colorPressing : (this->hovering ? this->colorHovering : this->colorBackground);

	tabContainer->renderer2D->DrawRectangle(this->rect.x,this->rect.y,this->rect.x+this->rect.z,this->rect.y+this->rect.w,tCurrentColor);
}


void GuiRect::OnPaint(Tab* tabContainer,void* data)
{
	bool selfClip=this->BeginSelfClip(tabContainer);

	this->DrawBackground(tabContainer);

	this->BroadcastToChilds(&GuiRect::OnPaint,tabContainer,data);

	this->EndSelfClip(tabContainer,selfClip);
}


void GuiRect::OnSize(Tab* tabContainer,void* data)
{
	this->CalcRect();
	this->BroadcastToChilds(&GuiRect::OnSize,tabContainer,data);
}

void GuiRect::OnLMouseDown(Tab* tabContainer,void* data)
{
	bool wasPressing=this->pressing;
	
	this->pressing=this->hovering;

	if(this->hovering)
	{
		this->checked=!this->checked;

		tabContainer->SetFocus(this);

		if(wasPressing!=this->pressing && this->colorPressing!=this->colorBackground)
			tabContainer->SetDraw(2,0,this);
	}

	this->BroadcastToChilds(&GuiRect::OnLMouseDown,tabContainer,data);

	if(wasPressing!=this->pressing && this->colorPressing!=this->colorBackground)
		tabContainer->SetDraw(2,0,this);
}

void GuiRect::OnDLMouseDown(Tab* tabContainer,void* data)
{
	this->BroadcastToChilds(&GuiRect::OnDLMouseDown,tabContainer,data);
}

void GuiRect::OnLMouseUp(Tab* tabContainer,void* data)
{
	bool wasPressing=this->pressing;

	this->pressing = false;

	this->BroadcastToChilds(&GuiRect::OnLMouseUp,tabContainer,data);

	if(wasPressing!=this->pressing && this->colorPressing!=this->colorBackground)
		tabContainer->SetDraw(2,0,this);
}

void GuiRect::OnRMouseUp(Tab* tabContainer,void* data)
{
	this->BroadcastToChilds(&GuiRect::OnRMouseUp,tabContainer,data);
}

void GuiRect::OnMouseMove(Tab* tabContainer,void* data)
{
	vec2 mpos=*(vec2*)data;

	mpos.y=!this->clip ? mpos.y : mpos.y+this->clip->vScrollbar.scrollerPosition*this->clip->contentHeight;

	bool _oldHover=this->hovering;
	bool _curHover=_contains(this->rect,mpos);

	if(parent && _curHover)
		parent->hovering=false;

	this->hovering=_curHover;

	this->BroadcastToChilds(&GuiRect::OnMouseMove,tabContainer,data);

	if(_oldHover!=this->hovering && this->colorBackground!=this->colorHovering)
		tabContainer->SetDraw(2,0,this);
}

void GuiRect::OnUpdate(Tab* tabContainer,void* data)
{
	this->BroadcastToChilds(&GuiRect::OnUpdate,tabContainer,data);
}

void GuiRect::OnReparent(Tab* tabContainer,void* data)
{
	this->BroadcastToChilds(&GuiRect::OnReparent,tabContainer,data);
}

void GuiRect::OnSelected(Tab* tabContainer,void* data)
{
	this->BroadcastToChilds(&GuiRect::OnSelected,tabContainer,data);
}

void GuiRect::OnRender(Tab* tabContainer,void* data)
{
	this->BroadcastToChilds(&GuiRect::OnRender,tabContainer);
}

void GuiRect::OnMouseWheel(Tab* tabContainer,void* data)
{
	if(this->clip && this->_contains(this->rect,vec2(tabContainer->mousex,tabContainer->mousey)))
	{
		this->clip->vScrollbar.Scroll(tabContainer,*(float*)data);
		//tabContainer->SetDraw(2,0,this->clip->parent);
	}

	this->BroadcastToChilds(&GuiRect::OnMouseWheel,tabContainer,data);
}

void GuiRect::OnActivate(Tab* tabContainer,void* data)
{
	this->active=true;
	this->BroadcastToChilds(&GuiRect::OnActivate,tabContainer);
}
void GuiRect::OnDeactivate(Tab* tabContainer,void* data)
{
	this->active=false;
	this->BroadcastToChilds(&GuiRect::OnDeactivate,tabContainer,data);
}
void GuiRect::OnEntitySelected(Tab* tabContainer,void* data)
{
	this->BroadcastToChilds(&GuiRect::OnEntitySelected,tabContainer,data);
}

void GuiRect::OnExpandos(Tab* tabContainer,void* data)
{
	if(this->parent)
		this->parent->OnExpandos(tabContainer,data);
}

void GuiRect::OnKeyDown(Tab* tabContainer,void* data)
{
	this->BroadcastToChilds(&GuiRect::OnKeyDown,tabContainer,data);
}

void GuiRect::OnKeyUp(Tab* tabContainer,void* data)
{
	this->BroadcastToChilds(&GuiRect::OnKeyDown,tabContainer,data);
}

void GuiRect::OnMouseEnter(Tab* tabContainer,void* data)
{
	this->BroadcastToChilds(&GuiRect::OnMouseEnter,tabContainer,data);
}
void GuiRect::OnMouseExit(Tab* tabContainer,void* data)
{
	this->BroadcastToChilds(&GuiRect::OnMouseExit,tabContainer,data);
}

void GuiRect::OnEnterFocus(Tab* tabContainer,void* data)
{
	this->BroadcastToChilds(&GuiRect::OnEnterFocus,tabContainer,data);
}

void GuiRect::OnExitFocus(Tab* tabContainer,void* data)
{
	this->BroadcastToChilds(&GuiRect::OnExitFocus,tabContainer,data);
}

void GuiRect::SetClip(GuiScrollRect* scrollRect)
{
	this->clip=scrollRect;

	for(std::vector<GuiRect*>::iterator tRect=this->childs.begin();tRect!=this->childs.end();tRect++)
		(*tRect)->SetClip(scrollRect);
}

void GuiRect::SelfRenderEnd(Tab* tabContainer,bool& isSelfRender)
{
	if(isSelfRender)
		tabContainer->EndDraw();
}

bool GuiRect::BeginSelfClip(Tab* tabContainer)
{
	bool clipped=false;

	if(this->clip && !this->clip->isClipped)
	{
		tabContainer->renderer2D->PushScissor(this->clip->rect.x,this->clip->rect.y,this->clip->rect.x+this->clip->rect.z,this->clip->rect.y+this->clip->rect.w);
		tabContainer->renderer2D->Translate(0,-this->clip->vScrollbar.scrollerPosition*this->clip->contentHeight);

		clipped=this->clip->isClipped=true;
	}

	return clipped;
}

void GuiRect::EndSelfClip(Tab* tabContainer,bool& isSelfClip)
{
	tabContainer->renderer2D->DrawRectangle(this->rect.x+1,this->rect.y+1,this->rect.x+this->rect.z-1,this->rect.y+this->rect.w-1,0xffffff,false);

	if(isSelfClip)
	{
		tabContainer->renderer2D->Identity();
		tabContainer->renderer2D->PopScissor();
		this->clip->isClipped=false;
	}
}

GuiRect* GuiRect::GetRoot()
{
	return this->parent ? this->parent->GetRoot() : this;
}

GuiRootRect* GuiRect::GetRootRect()
{
	return (GuiRootRect*)this->GetRoot();
}

GuiString* GuiRect::Text(String str)
{
	GuiString* label=new GuiString;
	label->parent=this;
	label->text=str.Buffer();
	this->childs.push_back(label);
	return label;
}

void GuiRect::AppendAsProperty(GuiRect* iProperty)
{
	GuiRect* tGuiRect=	(
							this->childs.size() ?
							this->childs.back() :
							this
						);

	iProperty->refedges.top=	tGuiRect->parent ? 
								&tGuiRect->edges.w :
								0;

	iProperty->SetParent(this);
}
	

GuiContainer* GuiRect::Container(const char* iText)
{
	GuiContainer* tContainer=new GuiContainer;

	tContainer->text=iText;
	tContainer->textAlign.make(0,0.5f);

	this->AppendAsProperty(tContainer);

	return tContainer;
}

GuiPropertyString* GuiRect::Property(const char* iDescription,void* iValuePointer1,unsigned int iValueType,void* iValuePointer2,unsigned int iValueParameter1,unsigned int iValueParameter2)
{
	GuiPropertyString* tPropertyString=new GuiPropertyString(iDescription,iValuePointer1,iValueType,iValuePointer2,iValueParameter1,iValueParameter2);
	this->AppendAsProperty(tPropertyString);
	return tPropertyString;
}



GuiPropertySlider* GuiRect::SliderProperty(const char* iDescription,float& ref,float& imin,float& imax)
{
	GuiPropertySlider* tGuiPropertySlider=new GuiPropertySlider(iDescription,ref,imin,imax);
	this->AppendAsProperty(tGuiPropertySlider);
	return tGuiPropertySlider;
}


GuiPropertyAnimationController* GuiRect::AnimationControllerProperty(AnimationController& ac)
{
	GuiPropertyAnimationController* tGuiPropertyAnimationController=new GuiPropertyAnimationController(ac);
	this->AppendAsProperty(tGuiPropertyAnimationController);
	return tGuiPropertyAnimationController;
}

GuiViewport* GuiRect::Viewport(vec3 pos,vec3 target,vec3 up,bool perspective)
{
	GuiViewport* tGuiViewport=new GuiViewport;

	tGuiViewport->SetParent(this);
	tGuiViewport->projection= !perspective ? tGuiViewport->projection : tGuiViewport->projection.perspective(90,16/9,1,1000);
	tGuiViewport->view.move(pos);
	tGuiViewport->view.lookat(target,up);

	return tGuiViewport;
}

GuiSceneViewer* GuiRect::SceneViewer()
{
	GuiSceneViewer* tGuiSceneViewer=new GuiSceneViewer;
	tGuiSceneViewer->SetParent(this);
	return tGuiSceneViewer;
}

GuiEntityViewer* GuiRect::EntityViewer()
{
	GuiEntityViewer* tGuiEntityViewer=new GuiEntityViewer;
	tGuiEntityViewer->SetParent(this);
	return tGuiEntityViewer;
}
GuiProjectViewer* GuiRect::ProjectViewer()
{
	GuiProjectViewer* tGuiProjectViewer=new GuiProjectViewer;
	tGuiProjectViewer->SetParent(this);
	return tGuiProjectViewer;
}

GuiScriptViewer* GuiRect::ScriptViewer()
{
	GuiScriptViewer* tGuiScriptViewer=new GuiScriptViewer();
	tGuiScriptViewer->SetParent(this);
	return tGuiScriptViewer;
}

GuiCompilerViewer* GuiRect::CompilerViewer()
{
	GuiCompilerViewer* tGuiCompilerViewer=new GuiCompilerViewer();
	tGuiCompilerViewer->SetParent(this);
	return tGuiCompilerViewer;
}

void GuiRect::DestroyChilds()
{
	for(size_t i=0;i<this->childs.size();i++)
	{
		this->childs[i]->DestroyChilds();
		SAFEDELETE(this->childs[i]);
	}

	this->childs.clear();
}

template<class GuiRectDerived> GuiRectDerived* GuiRect::Create(int sibIdx,int container,float ix, float iy, float iw,float ih,float iAlignPosX,float iAlignPosY,float iAlignRectX,float iAlignRectY)
{
	GuiRectDerived* guirectderived=new GuiRectDerived;

	if(!guirectderived)
		DEBUG_BREAK();

	guirectderived->SetParent(this);//,sibIdx>=0 ? this : 0,sibIdx<0 ? 0 : sibIdx,container,ix,iy,iw,ih,iAlignPosX,iAlignPosY,iAlignRectX,iAlignRectY);
	guirectderived->fixed.make(ix,iy,iw,ih);

	return guirectderived;
}

///////////////////////////////////////////////
///////////////////////////////////////////////
//////////////////Compiler/////////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

Compiler::Compiler():
	SAFESTLIMPL(std::vector<COMPILER>,compilers)
{
	ideSrcPath=Ide::instance->pathExecutable.PathUp(5) + "\\src";
	ideLibPath=Ide::instance->pathExecutable.Path();

	COMPILER msCompiler={"ms",
						 "vc2010",
						 "cl.exe ",
						 "linker.exe ",
						 " /nologo /MDd /ZI /EHsc ",
						 " /link /MANIFEST:NO /DLL /NOENTRY ",
						 " /OUT:",
						 "enginelibMS",
						 ".lib ",
						 " /I"
						};

	COMPILER mingwCompiler={"mingw",
							"i686-w64-mingw32",
							"c:\\sdk\\mingw32\\bin\\i686-w64-mingw32-g++.exe ",
							"c:\\sdk\\mingw32\\bin\\i686-w64-mingw32-ld.exe ",
							" -O0 -g -shared ",
							"",
							" -o ",
							"enginelibMingW",
							".dll ",
							" -I"
						   };

	COMPILER llvmCompiler={"llvm",
						   "5.0.0 32bit",
						   "c:\\sdk\\llvm32\\bin\\clang-cl.exe ",
						   "c:\\sdk\\llvm32\\bin\\lld-link.exe ",
						   " /nologo /MDd /ZI /EHsc ",
						   " /link /MANIFEST:NO /DLL /NOENTRY ",
						   " /OUT:",
						   "enginelibLLVM",
						   ".lib ",
						   " /I"
						  };

	compilers.push_back(msCompiler);
	compilers.push_back(mingwCompiler);
	compilers.push_back(llvmCompiler);
}


Compiler::~Compiler()
{
	SAFESTLDEST(compilers);
}

///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////EditorProperties////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

EditorProperties::EditorProperties():container(0)
{
}

///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////////EditorEntity////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

EditorEntity::EditorEntity():
	selected(false),
	expanded(false),
	level(0)
{
	this->properties.name="EntityRootProperties";
}

void EditorEntity::SetParent(Entity* iParent)
{
	Entity::SetParent(iParent);

	this->SetLevel(this);
}

void EditorEntity::SetLevel(EditorEntity* iEntity)
{
	EditorEntity* eeParent=(EditorEntity*)iEntity->parent;

	iEntity->level=eeParent ? eeParent->level+1 : iEntity->level;
	iEntity->expanded=!iEntity->level ? true : false;

	for(std::list<Entity*>::iterator i=iEntity->childs.begin();i!=iEntity->childs.end();i++)
		((EditorEntity*)*i)->SetLevel((EditorEntity*)*i);
}

///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////////GuiRootRect/////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

GuiRootRect::GuiRootRect(Tab* t):tabContainer(t)
{
	this->name="RootRect";
	//this->Set(0,0,0,-1,0,0,0,0,0,0,1,1);

}

GuiRootRect::~GuiRootRect()
{
}

void GuiRootRect::OnSize(Tab* tab)
{
	DEBUG_BREAK();
}

///////////////////////////////////////////////
///////////////////////////////////////////////
/////////////////GuiContainer//////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

GuiContainer::GuiContainer():state(false)
{
	this->name="GuiContainer";
	this->fixed.make(0,0,0,20);
	this->textOffsets.make(20,0,0,0);
}

void GuiContainer::CalcContainerRect()
{
	if(this->state && !this->childs.empty())
	{
		GuiRect* tLastChild=this->childs.back();

		this->rect.w=tLastChild->rect.y+tLastChild->rect.w-this->rect.y;
		this->edges.w=tLastChild->edges.w;
	}
}

void GuiContainer::AppendAsProperty(GuiRect* iProperty)
{
	iProperty->offsets.x=GuiRect::ROW_ADVANCE;

	GuiString::AppendAsProperty(iProperty);
}

void GuiContainer::BroadcastToChilds(void (GuiRect::*iFunction)(Tab*,void*),Tab* iTabContainer,void* iData)
{
	if(this->state)
		GuiString::BroadcastToChilds(iFunction,iTabContainer,iData);
}

void GuiContainer::OnSize(Tab* iTabContainer,void* iData)
{
	GuiString::OnSize(iTabContainer,iData);
	this->CalcContainerRect();
}

void GuiContainer::OnPaint(Tab* iTabContainer,void* data)
{
	bool selfClip=this->BeginSelfClip(iTabContainer);

	this->DrawBackground(iTabContainer);

	iTabContainer->renderer2D->DrawBitmap(
											this->state ?
											iTabContainer->iconDown :
											iTabContainer->iconRight,
											this->rect.x,
											this->rect.y,
											this->rect.x+Tab::CONTAINER_ICON_WH,
											this->rect.y+Tab::CONTAINER_ICON_WH
										);

	this->DrawTheText(iTabContainer);

	this->BroadcastToChilds(&GuiRect::OnPaint,iTabContainer,data);

	this->EndSelfClip(iTabContainer,selfClip);
}

void GuiContainer::OnLMouseDown(Tab* iTabContainer,void* iData)
{
	vec2 tMousePosition=*(vec2*)iData;
	bool tContainerButtonPressed=0;

	tMousePosition.y=!this->clip ? tMousePosition.y : tMousePosition.y+this->clip->vScrollbar.scrollerPosition*this->clip->contentHeight;

	tContainerButtonPressed=(	
								tMousePosition.x > this->rect.x && 
								tMousePosition.x < this->rect.x+Tab::CONTAINER_ICON_WH &&
								tMousePosition.y > this->rect.y && 
								tMousePosition.y <this->rect.y+Tab::CONTAINER_ICON_WH
							);

	if(tContainerButtonPressed)
		this->state=!this->state;

	if(tContainerButtonPressed)
	{
		iTabContainer->BroadcastToSelected(&GuiRect::OnSize);
		this->OnExpandos(iTabContainer,this);
		iTabContainer->SetDraw(1,false);
	}

	GuiString::OnLMouseDown(iTabContainer,iData);
}

///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////////GuiString///////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

GuiString::GuiString():
	textAlign(0.0f,0.5f),
	textSpot(0.0f,0.5f)
{
	this->fixed.make(0,0,0,20);
	this->name="GuiString";
}

void GuiString::CalcTextRect(Tab* iTabContainer)
{
	vec4 tEdges(
					this->edges.x + this->textOffsets.x,
					this->edges.y + this->textOffsets.y,
					this->edges.z + this->textOffsets.z,
					this->edges.w + this->textOffsets.w
				);

	vec4 tRect(
					tEdges.x,
					tEdges.y,
					tEdges.z-tEdges.x,
					tEdges.w-tEdges.y
			);

	vec2 tTextSize;

	if(!this->text.empty())
		tTextSize=iTabContainer->renderer2D->MeasureText(this->text.c_str());

	if(!this->wText.empty())
		tTextSize=iTabContainer->renderer2D->MeasureText(this->wText.c_str());

	float tLeft=tEdges.x + (tRect.z*this->textAlign.x) - (tTextSize.x * this->textSpot.x);
	float tTop=tEdges.y + (tRect.w*this->textAlign.y) - (tTextSize.y * this->textSpot.y);

	this->textEdges.make(
							tLeft,
							tTop,
							tLeft + tTextSize.x,
							tTop + tTextSize.y
						);

	this->textRect.make(
							tLeft,
							tTop,
							tTextSize.x,
							tTextSize.y
						);
}

void GuiString::OnSize(Tab* iTabContainer,void* data)
{
	this->CalcRect();
	this->CalcTextRect(iTabContainer);
	this->BroadcastToChilds(&GuiRect::OnSize,iTabContainer,data);
}

void GuiString::DrawTheText(Tab* tabContainer)
{
	if(!this->text.empty())
		tabContainer->renderer2D->DrawText(
												this->text.c_str(),
												this->textEdges.x,
												this->textEdges.y,
												this->textEdges.z,
												this->textEdges.w,
												Renderer2D::COLOR_TEXT
											);

	if(!this->wText.empty())
		tabContainer->renderer2D->DrawText(
												this->wText.c_str(),
												this->textEdges.x,
												this->textEdges.y,
												this->textEdges.z,
												this->textEdges.w,
												Renderer2D::COLOR_TEXT
											);
}

void GuiString::OnPaint(Tab* tabContainer,void* data)
{
	bool selfClip=this->BeginSelfClip(tabContainer);

	this->DrawBackground(tabContainer);

	this->DrawTheText(tabContainer);

	this->BroadcastToChilds(&GuiRect::OnPaint,tabContainer,data);

	this->EndSelfClip(tabContainer,selfClip);
}

bool GuiString::ParseKeyInput(Tab* iTab,void* iData)
{
	StringEditor&	stringEditor=*Ide::instance->stringEditor;

	bool			tRedraw=false;

	if(stringEditor.string==this && stringEditor.enabled)
	{
		unsigned int	tCaretOperation=stringEditor.CARET_DONTCARE;
		void*			tCaretParameter=0;
		char			tCharcode;

		if(iData)
		{
			tCharcode=*(int*)iData;

			switch(tCharcode)
			{
				case 0x08:/*VK_BACK*/tCaretOperation=stringEditor.CARET_BACKSPACE; break;
				default:
					tCaretOperation=stringEditor.CARET_ADD;
					tCaretParameter=&tCharcode;
			}
		}
		else
		{
			if(InputManager::keyboardInput.IsPressed(0x25/*VK_LEFT*/))
				tCaretOperation=stringEditor.CARET_ARROWLEFT;
			if(InputManager::keyboardInput.IsPressed(0x27/*VK_RIGHT*/))
				tCaretOperation=stringEditor.CARET_ARROWRIGHT;
			if(InputManager::keyboardInput.IsPressed(0x26/*VK_UP*/))
				tCaretOperation=stringEditor.CARET_ARROWUP;
			if(InputManager::keyboardInput.IsPressed(0x28/*VK_DOWN*/))
				tCaretOperation=stringEditor.CARET_ARROWDOWN;
			if(InputManager::keyboardInput.IsPressed(0x03/*VK_CANCEL*/))
				tCaretOperation=stringEditor.CARET_CANCEL;
			if(InputManager::keyboardInput.IsPressed(0x2E/*VK_DELETE*/))
				tCaretOperation=stringEditor.CARET_CANCEL;
			if(InputManager::keyboardInput.IsPressed(0x1B/*VK_ESCAPE*/)) 
			{
				stringEditor.Enable(false);
				return false;
			}
		}

		tRedraw=true;

		bool tMustResize=stringEditor.EditText(tCaretOperation,tCaretParameter);
	}
	else if(InputManager::keyboardInput.IsPressed(0x71/*VK_F2*/))
	{
		stringEditor.Bind(this);
		stringEditor.Enable(true);
	}

	return tRedraw;
}

void GuiString::OnKeyDown(Tab* iTabContainer,void* iData)
{
	if(this==iTabContainer->focused)
	{
		bool tRedraw=this->ParseKeyInput(iTabContainer,iData);

		if(tRedraw)
			iTabContainer->SetDraw(2,0,this);
	}

	GuiRect::OnKeyDown(iTabContainer,iData);
}


void GuiString::OnLMouseDown(Tab* iTabContainer,void* iData)
{
	if(this->hovering)
		iTabContainer->SetFocus(this);

	GuiRect::OnLMouseDown(iTabContainer,iData);
}

///////////////////////////////////////////////
///////////////////////////////////////////////
////////////////////GuiButton//////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

GuiButton::GuiButton()
{
	this->textAlign.make(0.5f,0.5f);
	this->textSpot.make(0.5f,0.5f);
}
void GuiButton::OnLMouseUp(Tab* tab,void* data)
{
	GuiString::OnLMouseUp(tab);

	if(this->hovering)
	{
		if(this->parent)
			this->parent->OnButtonPressed(tab,this);
	}
}

void GuiButton::OnPaint(Tab* tab,void* data)
{
	GuiString::OnPaint(tab);
}

///////////////////////////////////////////////
///////////////////////////////////////////////
////////////////GuiButtonFunc//////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

GuiButtonFunc::GuiButtonFunc(void (*iFunc)(void*),void* iParam):func(iFunc),param(iParam)
{

}

void GuiButtonFunc::OnLMouseUp(Tab* tab,void* data)
{
	GuiString::OnLMouseUp(tab);

	if(this->hovering)
	{
		if(this->func)
			this->func(this->param);
	}
}

///////////////////////////////////////////////
///////////////////////////////////////////////
////////////////GuiButtonBool//////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

GuiButtonBool::GuiButtonBool(bool& iBool):referenceValue(iBool),updateMode(-1)
{
	this->name="Button";
}

void GuiButtonBool::OnLMouseUp(Tab* tab,void* data)
{
	GuiString::OnLMouseUp(tab);

	if(this->hovering)
	{
		switch(this->updateMode)
		{
		case -1:	referenceValue=!referenceValue; break;
		case 0:		referenceValue=false;			break;
		case 1:		referenceValue=true;			break;
		}

		if(this->parent)
			this->parent->OnButtonPressed(tab,this);
	}
}

///////////////////////////////////////////////
///////////////////////////////////////////////
////////////////GuiScrollRect//////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

GuiScrollRect::GuiScrollRect():
contentHeight(0),
contentWidth(0),
isClipped(false),
hScrollbar(GuiScrollBar::SCROLLBAR_HORIZONTAL),
vScrollbar(GuiScrollBar::SCROLLBAR_VERTICAL)
{
	this->vScrollbar.guiRect=this;
	this->vScrollbar.SetParent(this);
	this->vScrollbar.SetEdges(&this->edges.z);

	this->hScrollbar.guiRect=this;
	this->hScrollbar.SetParent(this);
	this->hScrollbar.SetEdges(0,&this->edges.w);
}

GuiScrollRect::~GuiScrollRect()
{
}


void GuiScrollRect::OnSize(Tab* tabContainer,void* data)
{
	this->CalcRect();

	this->vScrollbar.SetScrollerRatio(this->contentHeight,this->rect.w);
	this->hScrollbar.SetScrollerRatio(this->contentWidth,this->rect.z);

	if(this->vScrollbar.IsVisible())
	{
		this->rect.z-=GuiScrollBar::SCROLLBAR_TICK;
		this->edges.z-=GuiScrollBar::SCROLLBAR_TICK;
	}

	if(this->hScrollbar.IsVisible())
	{
		this->rect.w-=GuiScrollBar::SCROLLBAR_TICK;
		this->edges.w-=GuiScrollBar::SCROLLBAR_TICK;
	}

	this->BroadcastToChilds(&GuiRect::OnSize,tabContainer,data);
}


///////////////////////////////////////////////
///////////////////////////////////////////////
////////////////GuiProperty*///////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

GuiProperty::GuiProperty()
{
}

GuiPropertyString::GuiPropertyString(const char* iDescription,void* iValuePointer1,unsigned int iValueType,void* iValuePointer2,unsigned int iValueParameter1,unsigned int iValueParameter2):
	valuePointer1(iValuePointer1),
	valuePointer2(iValuePointer2),
	valueType(iValueType),
	valueParameter1(iValueParameter1),
	valueParameter2(iValueParameter2)
{

	this->name="PropertyString";
	this->description=iDescription;
	this->fixed.make(0,0,0,20);
	this->value.SetParent(this);
	this->value.scalars.make(0.5f,0,0,0);

	switch(this->valueType)
	{
		case STRING: this->name+="STRING"; break;
		case BOOL: this->name+="BOOL"; break;
		case BOOLPTR: this->name+="BOOLPTR"; break;
		case INT: this->name+="INT"; break;
		case FLOAT: this->name+="FLOAT"; break;
		case VEC2: this->name+="VEC2"; break;
		case VEC3: this->name+="VEC3"; break;
		case VEC4: this->name+="VEC4"; break;
		case PTR: this->name+="PTR"; break;
		case MAT4POS: this->name+="MAT4POS"; break;
		case ENTITYVECSIZE: this->name+="ENTITYVECSIZE"; break;
		case ANIMATIONVECSIZE: this->name+="ANIMATIONVECSIZE"; break;
		case ISBONECOMPONENT: this->name+="ISBONECOMPONENT"; break;
		case FLOAT2MINUSFLOAT1: this->name+="FLOAT2MINUSFLOAT1"; break;
		case VEC32MINUSVEC31: this->name+="VEC32MINUSVEC31"; break;
	}
}

void GuiPropertyString::RefreshReference(Tab* iTabContainer)
{
	const unsigned int ctMaxTmpArraySize=256;

	switch(this->valueType)
	{
	case GuiPropertyString::STRING:
		{
			String& tString=*(String*)this->valuePointer1;

			this->value.text=tString.Buffer();
		}
		break;
	case GuiPropertyString::BOOL:
		{
			bool& tBool=*(bool*)this->valuePointer1;

			this->value.text=tBool ? "True" : "False";
		}
		break;
	case GuiPropertyString::BOOLPTR:
		{
			void* pRef=*(void**)this->valuePointer1;

			this->value.text=pRef ? "True" : "False";
		}
		break;
	case GuiPropertyString::INT:
		{
			int& tInt=*(int*)this->valuePointer1;

			char tCharInt[ctMaxTmpArraySize];
			sprintf(tCharInt,"%d",tInt);

			this->value.text=tCharInt;
		}
		break;
	case GuiPropertyString::FLOAT:
		{
			float& tFloat=*(float*)this->valuePointer1;

			//https://stackoverflow.com/questions/16413609/printf-variable-number-of-decimals-in-float

			char tCharFloat[ctMaxTmpArraySize];
			sprintf(tCharFloat,"%*.*f",this->valueParameter1,this->valueParameter2,tFloat);

			this->value.text=tCharFloat;
		}
		break;
	case GuiPropertyString::VEC2:
		{
			vec2& tVec2=*(vec2*)this->valuePointer1;

			char tCharVec2[ctMaxTmpArraySize];
			sprintf(tCharVec2,"%*.*f , %*.*f",this->valueParameter1,this->valueParameter2,tVec2.x,this->valueParameter1,this->valueParameter2,tVec2.y);

			this->value.text=tCharVec2;
		}
		break;
	case GuiPropertyString::VEC3:
		{
			vec3& tVec3=*(vec3*)this->valuePointer1;

			char tCharVec3[ctMaxTmpArraySize];
			sprintf(tCharVec3,"%*.*f , %*.*f , %*.*f",	this->valueParameter1,this->valueParameter2,tVec3.x,
				this->valueParameter1,this->valueParameter2,tVec3.y,
				this->valueParameter1,this->valueParameter2,tVec3.z);

			this->value.text=tCharVec3;
		}
		break;
	case GuiPropertyString::VEC4:
		{
			vec4& tVec4=*(vec4*)this->valuePointer1;

			char tCharVec4[ctMaxTmpArraySize];
			sprintf(tCharVec4,"%*.*f , %*.*f , %*.*f , %*.*f",	this->valueParameter1,this->valueParameter2,tVec4.x,
				this->valueParameter1,this->valueParameter2,tVec4.y,
				this->valueParameter1,this->valueParameter2,tVec4.z,
				this->valueParameter1,this->valueParameter2,tVec4.w);

			this->value.text=tCharVec4;
		}
		break;
	case GuiPropertyString::PTR:
		{
			char tCharPointer[ctMaxTmpArraySize];
			sprintf(tCharPointer,"0x%p",this->valuePointer1);

			this->value.text=tCharPointer;
		}
		break;
	case GuiPropertyString::MAT4POS:
		{
			mat4& tMat4=*(mat4*)this->valuePointer1;

			vec3 tPosition=tMat4.position();

			char tCharVec3[ctMaxTmpArraySize];
			sprintf(tCharVec3,"%*.*f , %*.*f , %*.*f",	this->valueParameter1,this->valueParameter2,tPosition.x,
				this->valueParameter1,this->valueParameter2,tPosition.y,
				this->valueParameter1,this->valueParameter2,tPosition.z);

			this->value.text=tCharVec3;
		}
		break;
	case GuiPropertyString::ENTITYVECSIZE:
		{
			std::vector<Entity*>& tEntityVec=*(std::vector<Entity*>*)this->valuePointer1;

			size_t tCount=tEntityVec.size();

			char tCharVecSize[10];
			sprintf(tCharVecSize,"%d",tCount);

			this->value.text=tCharVecSize;
		}
		break;
	case GuiPropertyString::ANIMATIONVECSIZE:
		{
			std::vector<Animation*>& tAnimationVec=*(std::vector<Animation*>*)this->valuePointer1;

			size_t tCount=tAnimationVec.size();

			char tCharVecSize[10];
			sprintf(tCharVecSize,"%d",tCharVecSize);

			this->value.text=tCharVecSize;
		}
		break;
	case GuiPropertyString::ISBONECOMPONENT:
		{
			Entity* tEntity=(Entity*)this->valueParameter1;

			this->value.text="Error";
		}
		break;
	case GuiPropertyString::FLOAT2MINUSFLOAT1:
		{
			float& a=*(float*)this->valueParameter1;
			float& b=*(float*)this->valueParameter2;

			char tCharFloatMinusOp[20];
			sprintf(tCharFloatMinusOp,"%*.*d",this->valueParameter1,this->valueParameter2,b-a);

			this->value.text=tCharFloatMinusOp;
		}
		break;
	case GuiPropertyString::VEC32MINUSVEC31:
		{
			vec3& a=*(vec3*)this->valueParameter1;
			vec3& b=*(vec3*)this->valueParameter2;

			vec3 tVecResult=b-a;

			char tCharVec3[ctMaxTmpArraySize];
			sprintf(tCharVec3,"%*.*f , %*.*f , %*.*f",	this->valueParameter1,this->valueParameter2,tVecResult.x,
				this->valueParameter1,this->valueParameter2,tVecResult.y,
				this->valueParameter1,this->valueParameter2,tVecResult.z);

			this->value.text=tCharVec3;
		}
		break;
	default:
		iTabContainer->renderer2D->DrawText("valueType error",this->rect.x+this->rect.z/2.0f,this->rect.y,this->rect.x+this->rect.z,this->rect.y+this->rect.w);
	}
}

void GuiPropertyString::OnSize(Tab* iTabContainer,void* iData)
{
	this->RefreshReference(iTabContainer);

	GuiProperty::OnSize(iTabContainer,iData);
}

void GuiPropertyString::OnPaint(Tab* tabContainer,void* data)
{
	bool selfClip=this->BeginSelfClip(tabContainer);

	this->DrawBackground(tabContainer);

	if(description.Buffer())
		tabContainer->renderer2D->DrawText(description.Buffer(),this->rect.x,this->rect.y,this->rect.x+this->rect.z/2.0f,this->rect.y+this->rect.w);

	this->BroadcastToChilds(&GuiRect::OnPaint,tabContainer,data);

	this->EndSelfClip(tabContainer,selfClip);

}

///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////////GuiSlider///////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////



void GuiSlider::DrawSliderTip(Tab* tabContainer,void* data)
{

	bool selfClip=this->BeginSelfClip(tabContainer);

	float tip=(this->rect.x+10) + ((referenceValue)/(maximum-minimum))*(this->rect.z-20);
	tabContainer->renderer2D->DrawRectangle(tip-5,this->rect.y+this->rect.w/4.0f-5,tip+5,this->rect.y+this->rect.w/4.0f+5,Renderer2D::COLOR_TEXT);

	this->EndSelfClip(tabContainer,selfClip);

}


void GuiSlider::OnPaint(Tab* tabContainer,void* data)
{
	bool selfClip=this->BeginSelfClip(tabContainer);

	this->DrawBackground(tabContainer);

	tabContainer->renderer2D->DrawRectangle(this->rect.x+10,this->rect.y+this->rect.w/4.0f-2,this->rect.x+this->rect.z-10,this->rect.y+this->rect.w/4.0f+2,0x000000);

	String smin(this->minimum);
	String smax(this->maximum);
	String value(this->referenceValue);

	tabContainer->renderer2D->DrawText(smin.Buffer(),this->rect.x+10,this->rect.y,this->rect.x+this->rect.z-10,this->rect.y+this->rect.w,Renderer2D::COLOR_TEXT,0,0.75);
	tabContainer->renderer2D->DrawText(smax.Buffer(),this->rect.x+10,this->rect.y,this->rect.x+this->rect.z-10,this->rect.y+this->rect.w,Renderer2D::COLOR_TEXT,1,0.75);
	tabContainer->renderer2D->DrawText(value.Buffer(),this->rect.x+10,this->rect.y,this->rect.x+this->rect.z-10,this->rect.y+this->rect.w,Renderer2D::COLOR_TEXT,0.5f,0.75);

	float tip=(this->rect.x+10) + ((referenceValue)/(maximum-minimum))*(this->rect.z-20);

	tabContainer->renderer2D->DrawRectangle(tip-5,this->rect.y+this->rect.w/4.0f-5,tip+5,this->rect.y+this->rect.w/4.0f+5,Renderer2D::COLOR_TEXT);

	this->BroadcastToChilds(&GuiRect::OnPaint,tabContainer,data);

	this->EndSelfClip(tabContainer,selfClip);

}

void GuiSlider::OnMouseMove(Tab* tabContainer,void* data)
{
	GuiRect::OnMouseMove(tabContainer,data);

	if(this->pressing)
	{
		vec2& mpos=*(vec2*)data;

		if(mpos.x > this->rect.x && mpos.x < this->rect.x+this->rect.z)
		{
			float f1=(mpos.x-(this->rect.x+10))/(this->rect.z-20);
			float f2=maximum-minimum;
			float cursor=f1*f2;

			cursor = cursor<minimum ? minimum : (cursor>maximum ? maximum : cursor);

			if(referenceValue!=cursor)
			{
				referenceValue=cursor;
				tabContainer->SetDraw(2,0,this);
			}
		}
	}
}

void GuiSlider::OnSize(Tab* tabContainer,void* data)
{
	/*float oldRatio=maximum/minimum;
	float value=this->referenceValue ? *this->referenceValue : 0;*/

	GuiRect::OnSize(tabContainer);
}

///////////////////////////////////////////////
///////////////////////////////////////////////
///////////GuiPropertySlider///////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

GuiPropertySlider::GuiPropertySlider(const char* iDescription,float& iRefVal,float& iMin,float& iMax):slider(iRefVal,iMin,iMax)
{
	this->description=iDescription;
	this->name="PropertySlider";
	this->fixed.make(0,0,0,25);//Set(0,0,0,-1,0,0,0,25,0,0,1,-1);
	//this->slider.Set(this,0,0,-1,0,0,0,0,0.5f,0,0.5f,1);
	this->slider.SetParent(this);
	this->slider.scalars.make(0.5f,1,0.5f,1);
}

void GuiPropertySlider::OnPaint(Tab* tabContainer,void* data)
{
	bool selfClip=this->BeginSelfClip(tabContainer);

	this->DrawBackground(tabContainer);

	if(description.Buffer())
	{
		String s=description + " " + String(this->slider.referenceValue);
		tabContainer->renderer2D->DrawText(s.Buffer(),this->rect.x,this->rect.y,this->rect.x+rect.z/2.0f,this->rect.y+this->rect.w);
	}

	this->BroadcastToChilds(&GuiRect::OnPaint,tabContainer,data);

	this->EndSelfClip(tabContainer,selfClip);

}

///////////////////////////////////////////////
///////////////////////////////////////////////
///////////GuiAnimationController//////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

GuiAnimationController::GuiAnimationController(AnimationController& iAnimationController)
	:animationController(iAnimationController),
	slider(animationController.cursor,this->animationController.start,this->animationController.end),
	play(this->animationController.play),
	stop(this->animationController.play)
{
	this->name="GuiAnimationController";

	this->fixed.make(0,0,0,41);//Set(0,0,0,-1,0,0,0,41,0,0,1,-1);

	//this->slider.Set(this,0,0,-1,0,0,0,26,0.5f,0,1,-1);
	this->slider.SetParent(this);
	this->slider.fixed.make(0,0,0,26);

	//this->play.Set(this,0,0,-1,0,0,15,15,0.5f,0.75f,-1,-1);
	this->play.SetParent(this);
	this->play.fixed.make(0,0,15,15);

	//this->stop.Set(this,&this->play,2,-1,20,0,15,15,-1,0.75f,-1,-1);
	this->stop.SetParent(this);
	this->stop.SetEdges(&this->play.edges.z);
	this->stop.fixed.make(20,0,15,15);

	this->stop.colorBackground=this->play.colorBackground=0x000000;
	this->stop.colorPressing=this->play.colorPressing=0xffffff;
	this->stop.colorHovering=this->play.colorHovering=0x88888888;

	this->play.updateMode=1;
	this->stop.updateMode=0;//set 0 onlyif 1
}

void GuiAnimationController::OnMouseMove(Tab* tab,void* data)
{
	float value=this->slider.referenceValue;

	GuiRect::OnMouseMove(tab,data);

	if(value!=this->slider.referenceValue && this->slider.pressing)
	{
		this->animationController.SetFrame(this->slider.referenceValue);
		tab->SetDraw(2,0,this);
	}
}

void GuiAnimationController::OnButtonPressed(Tab* tabContainer,GuiButtonBool* iButton)
{
	if(iButton==&this->play)
		this->animationController.Play();

	if(iButton==&this->stop)
		this->animationController.Stop();
}

///////////////////////////////////////////////
///////////////////////////////////////////////
///////GuiPropertyAnimationController//////////
///////////////////////////////////////////////
///////////////////////////////////////////////

GuiPropertyAnimationController::GuiPropertyAnimationController(AnimationController& iAnimationController)
	:guiAnimationController(iAnimationController)
{
	this->name="GuiPropertyAnimationController";
	this->fixed.w=this->guiAnimationController.rect.w;//Set(0,0,0,-1,0,0,0,this->guiAnimationController.rect.w,0,0,1,-1);
	this->description="Controller";
	this->guiAnimationController.SetParent(this);
	/*this->guiAnimationController.alignPos.x=0.5f;
	this->guiAnimationController.alignRect.x=0.5f;*/
}

///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////////GuiViewport/////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

void launchStopGuiViewportCallback(void* iData)
{
	GuiViewport* guiViewport=(GuiViewport*)iData;

	bool executedWithSuccess=Ide::instance->compiler->CreateAndroidTarget();

	if(!executedWithSuccess)
		DEBUG_BREAK();

}

GuiViewport::GuiViewport():
	renderBuffer(0),
	renderBitmap(0),
	rootEntity(0),
	needsPicking(0),
	pickedEntity(0),
	playStopButton(0)
{
	this->name="ViewportViewer";

	this->playStopButton=new GuiButtonFunc;

	this->playStopButton->func=launchStopGuiViewportCallback;
	this->playStopButton->param=this;
	this->playStopButton->colorHovering=Renderer2D::COLOR_GUI_BACKGROUND+30;
	this->playStopButton->colorPressing=Renderer2D::COLOR_GUI_BACKGROUND+90;
	this->playStopButton->text="Run";
	this->playStopButton->SetEdges(0,&this->edges.y);
	this->playStopButton->fixed.make(0,0,0,20);
	//this->playStopButton->alignRect.make(1,-1);

	this->playStopButton->SetParent(this);

}
GuiViewport::~GuiViewport()
{
	SAFEDELETEARRAY(this->renderBuffer);
}

void GuiViewport::OnSize(Tab* tabContainer,void* data)
{
	GuiRect::OnSize(tabContainer,data);
}

void GuiViewport::OnPaint(Tab* tabContainer,void* data)
{
	bool selfClip=this->BeginSelfClip(tabContainer);

	tabContainer->renderer3D->Render(this,false);

	this->BroadcastToChilds(&GuiRect::OnPaint,tabContainer);

	this->EndSelfClip(tabContainer,selfClip);

}

void GuiViewport::OnMouseWheel(Tab* tabContainer,void* data)
{
	GuiRect::OnMouseWheel(tabContainer);

	float factor=*(float*)data;

	this->view*=mat4().translate(0,0,factor*10);
}

void GuiViewport::OnLMouseUp(Tab* tabContainer,void* data)
{
	if(this->hovering/* && this->pickedEntity*/)
		Tab::BroadcastToPool(&Tab::OnGuiEntitySelected,(void*)this->pickedEntity);

	GuiRect::OnLMouseUp(tabContainer,data);
}

void GuiViewport::OnMouseMove(Tab* tabContainer,void* data)
{
	GuiRect::OnMouseMove(tabContainer,data);

	if(this->hovering)
	{
		vec2 &mpos=*(vec2*)data;

		if(InputManager::keyboardInput.IsPressed(0x01/*VK_LBUTTON*/))
		{
			float dX=(mpos.x-this->mouseold.x);
			float dY=(mpos.y-this->mouseold.y);

			if(InputManager::keyboardInput.IsPressed(0x011/*VK_CONTROL*/))
			{
				mat4 mview;
				vec3 vx,vy,vz;
				vec3 pos;
				mat4 rot;

				mview=this->view;

				mview.traspose();
				mview.inverse();

				mview.axes(vx,vy,vz);

				pos=this->model.position();

				this->model.move(vec3());

				if(dY)
					rot.rotate(dY,vx);
				this->model.rotate(dX,0,0,1);

				this->model*=rot;

				this->model.move(pos);
			}
			else
			{
				this->view*=mat4().translate(dX,dY,0);
			}
		}

		this->needsPicking=true;

		mouseold=mpos;
	}
}


void GuiViewport::OnActivate(Tab* tabContainer,void* data)
{
	GuiRect::OnActivate(tabContainer);
	tabContainer->renderer3D->Register(this);
}
void GuiViewport::OnDeactivate(Tab* tabContainer,void* data)
{
	GuiRect::OnDeactivate(tabContainer);
	tabContainer->renderer3D->Unregister(this);
}

void GuiViewport::OnReparent(Tab* tabContainer,void* data)
{
	GuiRect::OnReparent(tabContainer);
}

///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////////GuiScrollBar////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

GuiScrollBar::GuiScrollBar(unsigned int iScrollbarType):
	scrollbarType(iScrollbarType),
	guiRect(0),
	scrollerPressed(-1),
	scrollerPosition(0),
	scrollerRatio(1)
{
	this->fixed.make(0,0,this->scrollbarType==SCROLLBAR_VERTICAL ? GuiScrollBar::SCROLLBAR_TICK : 0,this->scrollbarType==SCROLLBAR_HORIZONTAL ? GuiScrollBar::SCROLLBAR_TICK : 0);
	this->name="ScrollBar";
}
GuiScrollBar::~GuiScrollBar()
{

}

void GuiScrollBar::SetType(unsigned int iScrollbarType)
{
	this->scrollbarType=iScrollbarType;

	this->fixed.make(0,0,this->scrollbarType==SCROLLBAR_VERTICAL ? GuiScrollBar::SCROLLBAR_TICK : 0,this->scrollbarType==SCROLLBAR_HORIZONTAL ? GuiScrollBar::SCROLLBAR_TICK : 0);
}


void GuiScrollBar::SetScrollerRatio(float contentLength,float containerLength)
{
	float oldScrollerRatio=this->scrollerRatio;

	this->scrollerRatio = (contentLength<containerLength) ? 1.0f : containerLength/contentLength;

	if(oldScrollerRatio!=this->scrollerRatio)
		SetScrollerPosition(this->scrollerPosition);
}

void GuiScrollBar::SetScrollerPosition(float positionPercent)
{
	float oldScrollerPosition=this->scrollerPosition;

	float scrollerContainerLength=this->GetContainerLength();
	float scrollerLength=this->GetScrollerLength();

	if(positionPercent+scrollerRatio>1)
		this->scrollerPosition=(scrollerContainerLength-scrollerLength)/scrollerContainerLength;
	else
		this->scrollerPosition = positionPercent < 0 ? 0 : positionPercent;
}

void GuiScrollBar::Scroll(Tab* tabContainer,float upOrDown)
{
	float rowHeightRatio=this->scrollerRatio/GuiSceneViewer::ROW_HEIGHT;

	float amount=this->scrollerPosition + (upOrDown<0 ? rowHeightRatio : -rowHeightRatio);

	this->SetScrollerPosition(amount);

	tabContainer->SetDraw(2,0,this->guiRect);
}

void GuiScrollBar::SetRect(GuiRect* iRect)
{

}

bool GuiScrollBar::IsVisible()
{
	return this->scrollerRatio<1.0f;
}

float GuiScrollBar::GetContainerLength()
{
	return	this->scrollbarType==SCROLLBAR_VERTICAL ? 
			this->rect.w-2.0f*SCROLLBAR_TIP_SIZE :
			this->rect.z-2.0f*SCROLLBAR_TIP_SIZE;
}
float GuiScrollBar::GetScrollerBegin()
{
	return this->GetContainerBegin()+this->scrollerPosition*this->GetContainerLength();
}
float GuiScrollBar::GetScrollerEnd()
{
	return this->GetScrollerBegin()+this->scrollerRatio*this->GetContainerLength();
}
float GuiScrollBar::GetScrollerLength()
{
	return this->GetScrollerEnd()-this->GetScrollerBegin();
}
float GuiScrollBar::GetContainerBegin()
{
	return	this->scrollbarType==SCROLLBAR_VERTICAL ? 
			this->rect.y+SCROLLBAR_TIP_SIZE :
			this->rect.x+SCROLLBAR_TIP_SIZE;
}
float GuiScrollBar::GetContainerEnd()
{
	return	this->scrollbarType==SCROLLBAR_VERTICAL ? 
			this->edges.w-SCROLLBAR_TIP_SIZE :
			this->edges.z-SCROLLBAR_TIP_SIZE;
}

void GuiScrollBar::OnLMouseUp(Tab* tabContainer,void* data)
{
	GuiRect::OnLMouseUp(tabContainer);

	this->scrollerPressed=-1;
}

void GuiScrollBar::OnLMouseDown(Tab* tabContainer,void* data)
{
	GuiRect::OnLMouseDown(tabContainer,data);

	if(!this->hovering || scrollerRatio==1.0f)
		return;

	vec2& mpos=*(vec2*)data;

	float& tTreshold=this->scrollbarType==SCROLLBAR_VERTICAL ? mpos.y : mpos.x;

	if(tTreshold<this->GetContainerBegin())
	{
		this->Scroll(tabContainer,1);
	}
	else if(tTreshold<this->GetContainerEnd())
	{
		this->scrollerPressed=0;

		if(tTreshold>=this->GetScrollerBegin() && tTreshold<=this->GetScrollerEnd())
			this->scrollerPressed=((tTreshold-this->GetScrollerBegin())/this->GetScrollerLength())*this->scrollerRatio;
		else
			SetScrollerPosition((tTreshold-this->GetContainerBegin())/this->GetContainerLength());
	}
	else
	{
		this->Scroll(tabContainer,-1);
	}

	if(this->parent)
		tabContainer->SetDraw(2,0,this->parent);
}

void GuiScrollBar::OnMouseMove(Tab* tabContainer,void* data)
{
	GuiRect::OnMouseMove(tabContainer,data);

	if(this->hovering)
	{
		if(this->scrollerRatio==1.0f || this->scrollerPressed<0)
			return;

		vec2& mpos=*(vec2*)data;

		float& tTreshold=this->scrollbarType==SCROLLBAR_VERTICAL ? mpos.y : mpos.x;

		if(tTreshold>this->GetContainerBegin() && tTreshold<this->GetContainerEnd())
		{
			float mouseContainerTreshold=(tTreshold-this->GetContainerBegin())/this->GetContainerLength();

			this->SetScrollerPosition(mouseContainerTreshold-this->scrollerPressed);

			if(this->parent)
				tabContainer->SetDraw(2,0,this->parent);
		}
	}
}


void GuiScrollBar::OnPaint(Tab* tabContainer,void* data)
{
	if(this->scrollerRatio==1.0f)
		return;

	bool selfClip=this->BeginSelfClip(tabContainer);

	if(this->scrollbarType==SCROLLBAR_VERTICAL)
	{
		tabContainer->renderer2D->DrawRectangle(this->rect.x,this->rect.y,this->rect.x+SCROLLBAR_TICK,this->rect.y+SCROLLBAR_TIP_SIZE,Renderer2D::COLOR_GUI_BACKGROUND);
		tabContainer->renderer2D->DrawRectangle(this->rect.x,this->edges.w-SCROLLBAR_TIP_SIZE,this->rect.x+SCROLLBAR_TICK,this->edges.w,Renderer2D::COLOR_GUI_BACKGROUND);

		tabContainer->renderer2D->DrawBitmap(tabContainer->iconUp,this->rect.x,this->rect.y,this->rect.x+SCROLLBAR_TICK,this->rect.y+SCROLLBAR_TIP_SIZE);
		tabContainer->renderer2D->DrawBitmap(tabContainer->iconDown,this->rect.x,this->edges.w-SCROLLBAR_TIP_SIZE,this->rect.x+SCROLLBAR_TICK,this->edges.w);

		tabContainer->renderer2D->DrawRectangle(this->rect.x,this->GetContainerBegin(),this->rect.x+SCROLLBAR_TICK,this->GetContainerEnd(),Renderer2D::COLOR_GUI_BACKGROUND);

		tabContainer->renderer2D->DrawRectangle(this->rect.x,this->GetScrollerBegin(),this->rect.x+SCROLLBAR_TICK,this->GetScrollerEnd(),0x00000000);
	}
	else
	{
		tabContainer->renderer2D->DrawRectangle(this->rect.x,this->rect.y,this->rect.x+SCROLLBAR_TICK,this->rect.y+SCROLLBAR_TIP_SIZE,Renderer2D::COLOR_GUI_BACKGROUND);
		tabContainer->renderer2D->DrawRectangle(this->edges.z-SCROLLBAR_TIP_SIZE,this->rect.y,this->edges.z,this->edges.w,Renderer2D::COLOR_GUI_BACKGROUND);

		tabContainer->renderer2D->DrawBitmap(tabContainer->iconLeft,this->rect.x,this->rect.y,this->rect.x+SCROLLBAR_TICK,this->rect.y+SCROLLBAR_TIP_SIZE);
		tabContainer->renderer2D->DrawBitmap(tabContainer->iconRight,this->edges.z-SCROLLBAR_TIP_SIZE,this->rect.y,this->edges.z,this->rect.y+this->rect.w);

		tabContainer->renderer2D->DrawRectangle(this->GetContainerBegin(),this->rect.y,this->GetContainerEnd(),this->rect.y+SCROLLBAR_TICK,Renderer2D::COLOR_GUI_BACKGROUND);

		tabContainer->renderer2D->DrawRectangle(this->GetScrollerBegin(),this->rect.y,this->GetScrollerEnd(),this->rect.y+SCROLLBAR_TICK,0x00000000);
	}

	this->BroadcastToChilds(&GuiRect::OnPaint,tabContainer,data);

	this->EndSelfClip(tabContainer,selfClip);

}

///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////GuiSceneViewer/////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

GuiSceneViewer::GuiSceneViewer():entityRoot((EditorEntity*&)scene.entityRoot)
{
	this->entityRoot=new EditorEntity;
	this->entityRoot->name="SceneRootEntity";
	this->entityRoot->expanded=true;

	this->name="SceneViewer";
	this->scene.name="Scene";
}

GuiSceneViewer::~GuiSceneViewer()
{
	printf("destroying treeview %p\n",this);
}

void GuiSceneViewer::OnMouseWheel(Tab* tabContainer,void* data)
{
	GuiRect::OnMouseWheel(tabContainer,data);

	if(this->hovering)
	{
		float wheelFactor=*(float*)data;

		this->vScrollbar.Scroll(tabContainer,wheelFactor);

		//tabContainer->SetDraw(2,0,this);
	}
}

void GuiSceneViewer::OnRMouseUp(Tab* tabContainer,void* data)
{
	GuiRect::OnRMouseUp(tabContainer,data);

	vec2& mpos=*(vec2*)data;

	vec2 tDrawCanvas(-GuiRect::ROW_ADVANCE,-GuiRect::ROW_HEIGHT);

	bool tEntityExpanded=false;
	EditorEntity* tEditorEntity = this->GetHoveredRow(this->entityRoot,mpos,tDrawCanvas,tEntityExpanded);

	int tChosedMenuIndex=tabContainer->TrackGuiSceneViewerPopup(tEditorEntity ? true : false);

	switch(tChosedMenuIndex)
	{
	case 1:
		{
			EditorEntity* tNewEntity=new EditorEntity;

			tNewEntity->name="EntityPippo";

			tNewEntity->SetParent(tEditorEntity ? tEditorEntity : this->entityRoot);
			tNewEntity->bbox.a.make(-1,-1,-1);
			tNewEntity->bbox.b.make(1,1,1);

			tNewEntity->OnPropertiesCreate();

			this->UpdateNodes(this->entityRoot);
		}
		break;
	case 2:tEditorEntity->parent->childs.erase(std::find(tEditorEntity->parent->childs.begin(),tEditorEntity->parent->childs.end(),tEditorEntity));break;
	case 3:tEditorEntity->CreateComponent<EditorLight>();break;
	case 4:tEditorEntity->CreateComponent<EditorMesh>();break;
	case 5:tEditorEntity->CreateComponent<EditorCamera>();break;
	case 14:tEditorEntity->CreateComponent<EditorScript>();break;
	}

	this->OnSize(tabContainer);
	tabContainer->SetDraw(2,0,this);
}

void GuiSceneViewer::OnRecreateTarget(Tab* tabContainer,void* data)
{
	GuiRect::OnRecreateTarget(tabContainer);
}

void GuiSceneViewer::OnEntitiesChange(Tab* tabContainer,void* data)
{
	EditorEntity* entity=(EditorEntity*)data;

	if(entity)
		entity->SetParent(this->entityRoot);

	this->contentHeight=-(float)ROW_HEIGHT+this->UpdateNodes(this->entityRoot);

	vScrollbar.SetScrollerRatio(this->contentHeight,this->rect.w);

	if(this->active)
	{
		this->OnSize(tabContainer);
		tabContainer->SetDraw(2,0,this);
	}

	GuiRect::OnEntitiesChange(tabContainer,data);
}

void GuiSceneViewer::OnEntitySelected(Tab* tabContainer,void* data)
{
	GuiRect::OnEntitySelected(tabContainer,data);

	EditorEntity* entity=(EditorEntity*)data;

	if(entity)
	{
		if(this->selection.end()==std::find(this->selection.begin(),this->selection.end(),entity))
		{
			this->UnselectNodes(this->entityRoot);
			this->ExpandUntil(entity);
			this->selection.clear();
			this->selection.push_back(entity);

			this->UpdateNodes(this->entityRoot);
			this->OnSize(tabContainer);

			entity->selected=true;

			entity->CreateComponent<EditorGizmo>();

			tabContainer->SetDraw(2,0,this);
		}
	}
}

void GuiSceneViewer::ExpandUntil(EditorEntity* iTarget)
{
	iTarget->expanded=true;

	if(iTarget->parent)
		GuiSceneViewer::ExpandUntil((EditorEntity*)iTarget->parent);
}

void GuiSceneViewer::UnselectNodes(EditorEntity* node)
{
	node->selected=false;

	for(std::vector<EntityComponent*>::iterator i=node->components.begin();i!=node->components.end();)
		(*i)->is<EditorGizmo>() ? i=node->components.erase(i) : i++ ;

	for(std::list<Entity*>::iterator nCh=node->childs.begin();nCh!=node->childs.end();nCh++)
		this->UnselectNodes((EditorEntity*)*nCh);
}

EditorEntity* GuiSceneViewer::GetHoveredRow(EditorEntity* iEntityNode,vec2& iMousePos,vec2& iFramePos,bool& oExpandos)
{
	float tDrawFromHeight=this->vScrollbar.scrollerPosition*this->contentHeight;

	if(iFramePos.y+ROW_HEIGHT>=tDrawFromHeight && iFramePos.y<=tDrawFromHeight+this->rect.w)
	{
		float tRelativeY=this->rect.y+iFramePos.y-tDrawFromHeight;

		float tCursor=this->rect.x+iFramePos.x+ROW_ADVANCE*iEntityNode->level;

		oExpandos= iEntityNode->childs.size() && (iMousePos.x>tCursor && iMousePos.x<tCursor+ROW_ADVANCE);

		if(iMousePos.y>tRelativeY && iMousePos.y<tRelativeY+GuiSceneViewer::ROW_HEIGHT)
			return iEntityNode;
	}

	iFramePos.y+=ROW_HEIGHT;

	if(iEntityNode->expanded)
	{
		for(std::list<Entity*>::iterator nCh=iEntityNode->childs.begin();nCh!=iEntityNode->childs.end();nCh++)
		{
			EditorEntity* tHoveredEntity=this->GetHoveredRow((EditorEntity*)*nCh,iMousePos,iFramePos,oExpandos);
			if(tHoveredEntity)
				return tHoveredEntity;
		}
	}

	return 0;
}

void GuiSceneViewer::OnLMouseDown(Tab* tabContainer,void* iData)
{
	if(this->hovering)
	{
		vec2& tMousePos=*(vec2*)iData;

		if(!InputManager::keyboardInput.IsPressed(0x11/*VK_CONTROL*/))
			this->selection.clear();

		vec2 tShiftedDrawCanvas(-ROW_ADVANCE,-ROW_HEIGHT);

		bool tEntityExpandosPressed=false;
		EditorEntity* tEditorEntity=this->GetHoveredRow(this->entityRoot,tMousePos,tShiftedDrawCanvas,tEntityExpandosPressed);

		if(tEditorEntity)
		{
			if(!tEntityExpandosPressed)
			{
				this->UnselectNodes(this->entityRoot);

				if(!tEditorEntity->selected)
					tEditorEntity->selected=true;
			}
			else
			{
				tEditorEntity->expanded=!tEditorEntity->expanded;

				this->UpdateNodes(this->entityRoot);
				this->OnSize(tabContainer);
			}

			this->selection.push_back(tEditorEntity);

			Tab::BroadcastToPool(&Tab::OnGuiEntitySelected,tEditorEntity);
		}
		else
			this->UnselectNodes(this->entityRoot);

		

		tabContainer->SetDraw(2,0,this);
	}

	GuiRect::OnLMouseDown(tabContainer,iData);
}


int GuiSceneViewer::UpdateNodes(EditorEntity* node)
{
	if(!node)
		return 0;

	if(node==this->entityRoot)
		this->contentHeight=0;
	else
		this->contentHeight += ROW_HEIGHT;

	if(node->expanded)
	{
		for(std::list<Entity*>::iterator nCh=node->childs.begin();nCh!=node->childs.end();nCh++)
			this->UpdateNodes((EditorEntity*)*nCh);
	}

	return this->contentHeight;
}

void GuiSceneViewer::DrawNodes(Tab* tabContainer,EditorEntity* node,vec2& iFromPosition)
{
	if(!node)
		return;

	float drawFromY=this->vScrollbar.scrollerPosition*this->contentHeight;

	if(iFromPosition.y+ROW_HEIGHT>=drawFromY && iFromPosition.y<=drawFromY+this->rect.w)
	{
		float relativeY=this->rect.y+iFromPosition.y-drawFromY;

		if(node->selected)
			tabContainer->renderer2D->DrawRectangle(0,(float)relativeY,(float)this->rect.z,(float)relativeY+GuiSceneViewer::ROW_HEIGHT,Renderer2D::COLOR_TAB_SELECTED);

		float xCursor=this->rect.x+iFromPosition.x+ROW_ADVANCE*node->level;

		if(node->childs.size())
		{
			tabContainer->renderer2D->DrawBitmap(node->expanded ? tabContainer->iconDown : tabContainer->iconRight,xCursor,relativeY,xCursor+Tab::CONTAINER_ICON_WH,relativeY+GuiSceneViewer::ROW_HEIGHT);
			xCursor+=ROW_ADVANCE;
		}

		tabContainer->renderer2D->DrawText(node->name.Buffer(),xCursor,relativeY,xCursor+this->rect.z,relativeY+GuiSceneViewer::ROW_HEIGHT,Renderer2D::COLOR_TEXT,-1,0.5);
	}
	else if(iFromPosition.y>drawFromY)
		return;

	iFromPosition.y+=ROW_HEIGHT;

	if(node->expanded)
	{
		for(std::list<Entity*>::iterator nCh=node->childs.begin();nCh!=node->childs.end();nCh++)
			this->DrawNodes(tabContainer,(EditorEntity*)*nCh,iFromPosition);
	}

}


void GuiSceneViewer::OnPaint(Tab* tabContainer,void* data)
{
	bool selfClip=this->BeginSelfClip(tabContainer);

	this->DrawBackground(tabContainer);

	tabContainer->renderer2D->PushScissor(this->rect.x,this->rect.y,this->rect.x+this->rect.z,this->rect.y+this->rect.w);

	vec2 tDrawCanvas(-ROW_ADVANCE,-ROW_HEIGHT);

	this->DrawNodes(tabContainer,this->entityRoot,tDrawCanvas);

	tabContainer->renderer2D->PopScissor();

	this->BroadcastToChilds(&GuiRect::OnPaint,tabContainer,data);

	this->EndSelfClip(tabContainer,selfClip);
}

void GuiSceneViewer::OnKeyDown(Tab* tabContainer,void* data)
{
	if(this==tabContainer->GetFocus())
	{
		if(InputManager::keyboardInput.IsPressed(0x11/*VK_CONTROL*/) && !InputManager::keyboardInput.IsPressed(0x12/*VK_ALT*/))
		{
			if(InputManager::keyboardInput.IsPressed('S'))
			{
				String tSaveFile=Ide::instance->folderProject + "\\" + this->scene.name + Ide::instance->GetSceneExtension();
				this->Save(tSaveFile.Buffer());
			}
		}
	}

	GuiScrollRect::OnKeyDown(tabContainer,data);
}





void saveEntityRecursively(Entity* iEntity,FILE* iFile)
{
	int childsSize=iEntity->childs.size();
	int componentsSize=iEntity->components.size();
	int nameCount=iEntity->name.Count();

	fwrite(&childsSize,sizeof(int),1,iFile);//4

	fwrite(iEntity->local,sizeof(float),16,iFile);//64
	fwrite(iEntity->world,sizeof(float),16,iFile);//64

	fwrite(&nameCount,sizeof(int),1,iFile);//4
	fwrite(iEntity->name.Buffer(),iEntity->name.Count(),1,iFile);//variadic

	fwrite(iEntity->bbox.a,sizeof(float),3,iFile);//12
	fwrite(iEntity->bbox.b,sizeof(float),3,iFile);//12

	fwrite(&componentsSize,sizeof(int),1,iFile);//4

	for(std::vector<EntityComponent*>::iterator cIter=iEntity->components.begin();cIter!=iEntity->components.end();cIter++)
	{
		if((*cIter)->is<Script>())
		{
			Script* tScript=(Script*)(*cIter);

			fwrite(&Serialization::Script,sizeof(unsigned char),1,iFile);//1

			nameCount=tScript->script.path.Count();

			fwrite(&nameCount,sizeof(int),1,iFile);//4
			fwrite(tScript->script.path.Buffer(),tScript->script.path.Count(),1,iFile);//variadic
		}
		else
			fwrite(&Serialization::Unknown,sizeof(unsigned char),1,iFile);//1
	}

	if(childsSize)
	{
		for(std::list<Entity*>::iterator eIter=iEntity->childs.begin();eIter!=iEntity->childs.end();eIter++)
			saveEntityRecursively(*eIter,iFile);
	}
}

EditorEntity* loadEntityRecursively(EditorEntity* iEditorEntityParent,FILE* iFile)
{
	int nameCount;
	int componentsSize;
	int childsSize;
	unsigned char componentCode;

	EditorEntity* tEditorEntity=new EditorEntity;

	tEditorEntity->SetParent(iEditorEntityParent);

	fread(&childsSize,sizeof(int),1,iFile);//4

	fread(tEditorEntity->local,sizeof(float),16,iFile);//64
	fread(tEditorEntity->world,sizeof(float),16,iFile);//64

	fread(&nameCount,sizeof(int),1,iFile);//4

	{
		char *tNameBuf=new char[nameCount+1];
		fread(tNameBuf,nameCount,1,iFile);//variadic
		tNameBuf[nameCount]='\0';

		tEditorEntity->name=tNameBuf;

		SAFEDELETEARRAY(tNameBuf);
	}

	fread(tEditorEntity->bbox.a,sizeof(float),3,iFile);//12
	fread(tEditorEntity->bbox.b,sizeof(float),3,iFile);//12

	tEditorEntity->OnResourcesCreate();
	tEditorEntity->OnPropertiesCreate();

	fread(&componentsSize,sizeof(int),1,iFile);//4

	for(int i=0;i<componentsSize;i++)
	{
		fread(&componentCode,sizeof(unsigned char),1,iFile);//1

		if(componentCode==Serialization::Script)
		{
			EditorScript* tScript=tEditorEntity->CreateComponent<EditorScript>();

			fread(&nameCount,sizeof(int),1,iFile);//4

			{
				char *tNameBuf=new char[nameCount+1];
				fread(tNameBuf,nameCount,1,iFile);//variadic
				tNameBuf[nameCount]='\0';

				tScript->script.path=tNameBuf;

				SAFEDELETEARRAY(tNameBuf);
			}
		}
	}

	if(childsSize)
	{
		for(int i=0;i<childsSize;i++)
			loadEntityRecursively(tEditorEntity,iFile);
	}

	return tEditorEntity;
}

void GuiSceneViewer::Save(const char* iFilename)
{
	FILE* file=fopen(iFilename,"wb");
	if(!file)
		return;

	saveEntityRecursively(this->entityRoot,file);

	fclose(file);
}

void GuiSceneViewer::Load(const char* iFilename)
{
	FILE* file=fopen(iFilename,"rb");
	if(!file)
		return;

	for(std::list<Entity*>::iterator i=this->entityRoot->childs.begin();i!=this->entityRoot->childs.end();)
		i=this->entityRoot->childs.erase(i);

	EditorEntity* tEntity=loadEntityRecursively(0,file);

	std::list<Entity*> tChildsCopy=tEntity->childs;

	for(std::list<Entity*>::iterator i=tChildsCopy.begin();i!=tChildsCopy.end();i++)
		(*i)->SetParent(this->entityRoot);

	SAFEDELETE(tEntity);

	if(this->active)
	{
		Tab* tab=this->GetRootRect()->tabContainer;

		this->UpdateNodes(this->entityRoot);
		this->OnSize(tab);
		tab->SetDraw(2,0,this);
	}

	fclose(file);
}

///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////GuiEntityViewer/////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

GuiEntityViewer::GuiEntityViewer():
entity(0),tabContainer(0)
{
	this->name="EntityViewer";
};

GuiEntityViewer::~GuiEntityViewer()
{
	printf("destroying properties %p\n",this);
}

void GuiEntityViewer::OnEntitySelected(Tab* iTabContainer,void* iData)
{
	EditorEntity* iEntity=(EditorEntity*)iData;

	if(this->entity!=iEntity)
	{
		if(this->entity)
		{
			this->BroadcastToChilds(&GuiRect::OnDeactivate,iTabContainer);
			this->entity->properties.SetParent(0);
			this->entity->properties.SetClip(0);
			this->entity=0;
			this->vScrollbar.SetParent(0);
			this->hScrollbar.SetParent(0);
		}

		if(iEntity)
		{
			this->entity=iEntity;
			this->entity->properties.SetParent(this);

			this->vScrollbar.SetParent(this);
			this->hScrollbar.SetParent(this);
			this->entity->properties.SetClip(this);

			this->CalcNodesHeight(&iEntity->properties);
			this->vScrollbar.SetScrollerPosition(0);
			this->hScrollbar.SetScrollerPosition(0);

			this->OnSize(iTabContainer);
			this->entity->properties.OnActivate(iTabContainer);
		}
		else
		{
			this->CalcNodesHeight(&iEntity->properties);
			this->OnSize(iTabContainer);
		}

		iTabContainer->SetDraw(2,0,this);
	}
	else
	{
		this->CalcNodesHeight(&iEntity->properties);
		this->OnSize(iTabContainer);

		iTabContainer->SetDraw(2,0,this);
	}

	GuiRect::OnEntitySelected(iTabContainer);
}

void GuiEntityViewer::OnExpandos(Tab* iTabContainer,void* data)
{
	this->CalcNodesHeight(&this->entity->properties);
	this->OnSize(iTabContainer);
}

void GuiEntityViewer::OnPaint(Tab* iTabContainer,void* data)
{
	bool selfClip=this->BeginSelfClip(iTabContainer);

	iTabContainer->renderer2D->DrawRectangle(this->rect.x,this->rect.y,this->rect.x+this->rect.z,this->rect.y+this->rect.w,Renderer2D::COLOR_GUI_BACKGROUND);

	if(this->entity)
		this->entity->properties.OnPaint(iTabContainer);

	this->vScrollbar.OnPaint(iTabContainer);
	this->hScrollbar.OnPaint(iTabContainer);

	this->EndSelfClip(iTabContainer,selfClip);
}

void GuiEntityViewer::OnActivate(Tab* iTabContainer,void* data)
{
	tabContainer=iTabContainer;

	GuiRect::OnActivate(tabContainer);
}


void GuiEntityViewer::OnMouseWheel(Tab* tabContainer,void* data)
{
	GuiScrollRect::OnMouseWheel(tabContainer,data);
}

bool GuiEntityViewer::ProcessMouseInput(vec2&,vec2&,GuiRect* node)
{
	return false;
}
void GuiEntityViewer::DrawNodes(Tab*,GuiRect* node,vec2&)
{

}
int GuiEntityViewer::CalcNodesHeight(GuiRect* node)
{
	if(!node || !this->entity)
		return 0;

	this->contentHeight=0;

	for(std::vector<GuiRect*>::iterator nCh=this->entity->properties.childs.begin();nCh!=this->entity->properties.childs.end();nCh++)
	{
		GuiRect* prop=(*nCh);
		this->contentHeight+=prop->rect.w;
	}

	return this->contentHeight;
}

///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////GuiProjectViewer////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

extern ResourceNodeDir rootProjectDirectory;

GuiProjectViewer::GuiProjectViewer():
	projectDirectory(&rootProjectDirectory),
	splitterLeftActive(false),
	splitterRightActive(false),
	splitterLeft(0),
	splitterRight(0)
{
	this->name="ProjectViewer";

	this->dirViewer.projectViewer=this;
	this->fileViewer.projectViewer=this;
	this->resViewer.projectViewer=this;

	const float tHalfSplit=2;

	this->dirViewer.SetParent(this);
	this->dirViewer.SetEdges(0,0,&this->splitterLeft);
	this->dirViewer.offsets.make(0,0,-tHalfSplit,0);

	this->fileViewer.SetParent(this);
	this->fileViewer.SetEdges(&this->splitterLeft,0,&this->splitterRight);
	this->fileViewer.offsets.make(tHalfSplit,0,-tHalfSplit,0);

	this->resViewer.SetParent(this);
	this->resViewer.SetEdges(&this->splitterRight);
	this->resViewer.offsets.make(tHalfSplit,0,0,0);

	this->projectDirectory->fileName=Ide::instance->folderProject;
	this->projectDirectory->expanded=true;
	this->projectDirectory->isDir=true;

	dirViewer.rootResource=this->projectDirectory;
	fileViewer.rootResource=this->projectDirectory;

	dirViewer.selectedDirs.push_back(this->projectDirectory);
}

GuiProjectViewer::~GuiProjectViewer()
{
	printf("destroying resources %p\n",this);
}



void GuiProjectViewer::OnActivate(Tab* tabContainer,void* data)
{
	if(!this->active)
	{
		Ide::instance->ScanDir(this->projectDirectory->fileName,this->projectDirectory);

		this->dirViewer.CalcNodesHeight(this->projectDirectory);
		this->fileViewer.CalcNodesHeight(this->projectDirectory);

		this->OnSize(tabContainer,data);
	}

	GuiRect::OnActivate(tabContainer);
}

void GuiProjectViewer::OnDeactivate(Tab* tabContainer,void* data)
{
	if(this->active)
	{
		this->projectDirectory->files.erase(this->projectDirectory->files.begin(),this->projectDirectory->files.end());
		this->projectDirectory->dirs.erase(this->projectDirectory->dirs.begin(),this->projectDirectory->dirs.end());
	}

	GuiRect::OnDeactivate(tabContainer);
}


void GuiProjectViewer::OnLMouseDown(Tab* tabContainer,void* data)
{
	GuiRect::OnLMouseDown(tabContainer,data);

	if(this->hovering)
	{
		vec2& mpos=*(vec2*)data;

		if(mpos.x>this->dirViewer.edges.z && mpos.x<this->fileViewer.edges.x)
		{
			this->splitterLeftActive=true;
		}
		else if(mpos.x>this->fileViewer.edges.z && mpos.x<this->resViewer.edges.x)
		{
			this->splitterRightActive=true;
		}
	}
}

void GuiProjectViewer::OnLMouseUp(Tab* tabContainer,void* data)
{
	GuiRect::OnLMouseUp(tabContainer);

	if(this->pressing || this->splitterLeftActive || this->splitterRightActive)
	{
		this->splitterLeftActive=false;
		this->splitterRightActive=false;
	}
}

void GuiProjectViewer::OnMouseMove(Tab* tabContainer,void* data)
{
	GuiRect::OnMouseMove(tabContainer,data);

	if(this->hovering || this->splitterLeftActive || this->splitterRightActive)
	{
		tabContainer->SetCursor(1);

		if(this->pressing)
		{
			vec2& mpos=*(vec2*)data;

			if(this->splitterLeftActive)
			{
				this->splitterLeft=mpos.x;

				this->dirViewer.OnSize(tabContainer);
				this->fileViewer.OnSize(tabContainer);
			}
			if(this->splitterRightActive)
			{
				this->splitterRight=mpos.x;

				this->fileViewer.OnSize(tabContainer);
				this->resViewer.OnSize(tabContainer);
			}

			tabContainer->SetDraw(1,0,0);
		}
	}
}

void GuiProjectViewer::OnReparent(Tab* tabContainer,void* data)
{
	GuiRect::OnReparent(tabContainer);

	tabContainer->OnGuiSize();
	tabContainer->OnGuiRecreateTarget();
}


void GuiProjectViewer::OnPaint(Tab* tabContainer,void* data)
{
	bool selfClip=this->BeginSelfClip(tabContainer);

	tabContainer->renderer2D->DrawRectangle(this->rect,Renderer2D::COLOR_MAIN_BACKGROUND,true);

	this->BroadcastToChilds(&GuiRect::OnPaint,tabContainer,data);

	this->EndSelfClip(tabContainer,selfClip);

}

void GuiProjectViewer::OnSize(Tab* tabContainer,void* data)
{
	GuiRect::OnSize(tabContainer);

	float tPanelsSizeWidth=this->rect.z/3.0f - 2*4;

	this->splitterLeft=tPanelsSizeWidth;
	this->splitterRight=tPanelsSizeWidth*2;

	this->dirViewer.OnSize(tabContainer);
	this->fileViewer.OnSize(tabContainer);
	this->resViewer.OnSize(tabContainer);
}


/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
///////////////GuiProjectViewer::GuiProjectDirViewer/////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////


void GuiProjectViewer::DirViewer::DrawNodes(Tab* tabContainer,ResourceNodeDir* node,vec2& pos,bool& terminated)
{
	if(terminated)
		return;

	float drawFromHeight=this->vScrollbar.scrollerPosition*this->contentHeight;

	if(pos.y+ROW_HEIGHT>=drawFromHeight && pos.y<=drawFromHeight+this->rect.w)
	{
		float relativeY=this->rect.y+pos.y-drawFromHeight;

		if(node->selectedLeft)
			tabContainer->renderer2D->DrawRectangle(this->rect.x,relativeY,this->rect.x+this->rect.z,(float)relativeY+GuiSceneViewer::ROW_HEIGHT,Renderer2D::COLOR_TAB_SELECTED);

		float xCursor=this->rect.x+ROW_ADVANCE*node->level;

		if(node->dirs.size())
		{
			tabContainer->renderer2D->DrawBitmap(node->expanded ? tabContainer->iconDown : tabContainer->iconRight,xCursor,relativeY,xCursor+Tab::CONTAINER_ICON_WH,relativeY+GuiSceneViewer::ROW_HEIGHT);
			xCursor+=ROW_ADVANCE;
		}

		tabContainer->renderer2D->DrawBitmap(tabContainer->iconFolder,xCursor,relativeY,xCursor+Tab::CONTAINER_ICON_WH,relativeY+GuiSceneViewer::ROW_HEIGHT);

		xCursor+=ROW_ADVANCE;

		tabContainer->renderer2D->DrawText(node->fileName.Buffer(),xCursor,relativeY,this->rect.z,relativeY+GuiSceneViewer::ROW_HEIGHT,Renderer2D::COLOR_TEXT,-1,0.5f);


	}

	pos.y+=ROW_HEIGHT;

	if(pos.y>drawFromHeight+this->rect.w)
	{
		terminated=true;
		return;
	}

	if(node->expanded)
	{
		for(std::list<ResourceNodeDir*>::iterator nCh=node->dirs.begin();nCh!=node->dirs.end();nCh++)
			this->DrawNodes(tabContainer,*nCh,pos,terminated);
	}

	return;
}

int GuiProjectViewer::DirViewer::CalcNodesHeight(ResourceNodeDir* node)
{
	if(!node)
		return 0;

	if(node==this->rootResource)
		this->contentHeight=0;

	this->contentHeight += node->isDir  ? ROW_HEIGHT : 0;

	if(node->expanded)
	{
		for(std::list<ResourceNodeDir*>::iterator nCh=node->dirs.begin();nCh!=node->dirs.end();nCh++)
			this->CalcNodesHeight(*nCh);
	}

	return this->contentHeight;
}

void GuiProjectViewer::DirViewer::UnselectNodes(ResourceNodeDir* node)
{
	if(!node)
		return;

	node->selectedLeft=false;

	for(std::list<ResourceNode*>::iterator nCh=node->files.begin();nCh!=node->files.end();nCh++)
		(*nCh)->selectedLeft=0;

	for(std::list<ResourceNodeDir*>::iterator nCh=node->dirs.begin();nCh!=node->dirs.end();nCh++)
		this->UnselectNodes(*nCh);
}

ResourceNodeDir* GuiProjectViewer::DirViewer::GetHoveredRow(ResourceNodeDir* iResourceNodeDirNode,vec2& iMousePos,vec2& iFramePos,bool& oExpandos)
{
	float tDrawFromHeight=this->vScrollbar.scrollerPosition*this->contentHeight;

	if(iFramePos.y+ROW_HEIGHT>=tDrawFromHeight && iFramePos.y<=tDrawFromHeight+this->rect.w)
	{
		float tRelativeY=this->rect.y+iFramePos.y-tDrawFromHeight;

		float tCursor=this->rect.x+iFramePos.x+ROW_ADVANCE*iResourceNodeDirNode->level;

		oExpandos= iResourceNodeDirNode->dirs.size() && (iMousePos.x>tCursor && iMousePos.x<tCursor+ROW_ADVANCE);

		if(iMousePos.y>tRelativeY && iMousePos.y<tRelativeY+GuiSceneViewer::ROW_HEIGHT)
			return iResourceNodeDirNode;
	}

	iFramePos.y+=ROW_HEIGHT;

	if(iResourceNodeDirNode->expanded)
	{
		for(std::list<ResourceNodeDir*>::iterator nCh=iResourceNodeDirNode->dirs.begin();nCh!=iResourceNodeDirNode->dirs.end();nCh++)
		{
			ResourceNodeDir* tHoveredEntity=this->GetHoveredRow((ResourceNodeDir*)*nCh,iMousePos,iFramePos,oExpandos);
			if(tHoveredEntity)
				return tHoveredEntity;
		}
	}

	return 0;
}

void GuiProjectViewer::DirViewer::OnLMouseDown(Tab* iTabContainer,void* iData)
{
	GuiRect::OnLMouseDown(iTabContainer,iData);

	if(!this->hovering)
		return;

	vec2& tMousePos=*(vec2*)iData;

	vec2 tDrawCanvas(0,0);

	bool tResourceNodeDirExpanded=false;

	ResourceNodeDir* tResourceNodeDir=this->GetHoveredRow(this->rootResource,tMousePos,tDrawCanvas,tResourceNodeDirExpanded);

	if(tResourceNodeDir)
	{
		if(!tResourceNodeDirExpanded)
		{
			FileViewer& tFileViewer=this->projectViewer->fileViewer;

			this->UnselectNodes(this->rootResource);

			if(!tResourceNodeDir->selectedLeft)
				tResourceNodeDir->selectedLeft=true;

			this->CalcNodesHeight(this->rootResource);
			this->OnSize(iTabContainer);

			tFileViewer.rootResource=tResourceNodeDir;

			tFileViewer.CalcNodesHeight(tFileViewer.rootResource);
			tFileViewer.OnSize(iTabContainer);

			iTabContainer->SetDraw(2,0,&tFileViewer);
		}
		else
			tResourceNodeDir->expanded=!tResourceNodeDir->expanded;

		if(!InputManager::keyboardInput.IsPressed(0x11/*VK_CONTROL*/))
			this->selectedDirs.clear();

		this->selectedDirs.push_back(tResourceNodeDir);

		iTabContainer->SetDraw(2,0,this);
	}
}

void GuiProjectViewer::DirViewer::OnPaint(Tab* tabContainer,void* data)
{
	bool selfClip=this->BeginSelfClip(tabContainer);

	this->DrawBackground(tabContainer);

	tabContainer->renderer2D->PushScissor(this->rect.x,this->rect.y,this->rect.x+this->rect.z,this->rect.y+this->rect.w);

	vec2 tDrawCanvas(0,0);

	bool terminated=false;
	this->DrawNodes(tabContainer,this->rootResource,tDrawCanvas,terminated);

	tabContainer->renderer2D->PopScissor();

	this->BroadcastToChilds(&GuiRect::OnPaint,tabContainer,data);

	this->EndSelfClip(tabContainer,selfClip);

}


/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
///////////////GuiProjectViewer::GuiProjectDirViewer/////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////

void GuiProjectViewer::FileViewer::DrawNodes(Tab* tabContainer,ResourceNodeDir* _node,vec2& pos)
{
	float drawFromHeight=this->vScrollbar.scrollerPosition*this->contentHeight;

	for(std::list<ResourceNodeDir*>::iterator nCh=_node->dirs.begin();nCh!=_node->dirs.end();nCh++)
	{
		if(pos.y+ROW_HEIGHT>=drawFromHeight && pos.y<=drawFromHeight+this->rect.w)
		{
			float relativeY=this->rect.y+pos.y-drawFromHeight;

			ResourceNodeDir* node=(*nCh);

			if(node->selectedRight)
				tabContainer->renderer2D->DrawRectangle(this->rect.x,relativeY,this->rect.x+this->rect.z,(float)relativeY+GuiSceneViewer::ROW_HEIGHT,Renderer2D::COLOR_TAB_SELECTED);

			float xCursor=this->rect.x;

			tabContainer->renderer2D->DrawBitmap(tabContainer->iconFolder,xCursor,relativeY,xCursor+Tab::CONTAINER_ICON_WH,relativeY+GuiSceneViewer::ROW_HEIGHT);

			xCursor+=ROW_ADVANCE;

			tabContainer->renderer2D->DrawText(node->fileName.Buffer(),xCursor,relativeY,xCursor+this->rect.z,relativeY+GuiSceneViewer::ROW_HEIGHT,Renderer2D::COLOR_TEXT,-1,0.5f);
		}
		else if(pos.y>drawFromHeight)
			return;

		pos.y+=ROW_HEIGHT;
	}

	for(std::list<ResourceNode*>::iterator nCh=_node->files.begin();nCh!=_node->files.end();nCh++)
	{
		if(pos.y+ROW_HEIGHT>=drawFromHeight && pos.y<=drawFromHeight+this->rect.w)
		{
			float relativeY=this->rect.y+pos.y-drawFromHeight;

			ResourceNode* node=(*nCh);

			if(node->selectedRight)
				tabContainer->renderer2D->DrawRectangle(this->rect.x,relativeY,this->rect.x+this->rect.z,relativeY+GuiSceneViewer::ROW_HEIGHT,Renderer2D::COLOR_TAB_SELECTED);

			float xCursor=this->rect.x;
			tabContainer->renderer2D->DrawBitmap(tabContainer->iconFile,xCursor,relativeY,xCursor+Tab::CONTAINER_ICON_WH,relativeY+GuiSceneViewer::ROW_HEIGHT);

			xCursor+=ROW_ADVANCE;

			tabContainer->renderer2D->DrawText(node->fileName.Buffer(),xCursor,relativeY,xCursor+rect.z,relativeY+GuiSceneViewer::ROW_HEIGHT,Renderer2D::COLOR_TEXT,-1,0.5f);
		}
		else if(pos.y>drawFromHeight)
			return;

		pos.y+=ROW_HEIGHT;
	}

	return;
}

int GuiProjectViewer::FileViewer::CalcNodesHeight(ResourceNodeDir* node)
{
	if(!node)
		return 0;

	return this->contentHeight=(node->dirs.size() + node->files.size())*ROW_HEIGHT;
}

void GuiProjectViewer::FileViewer::UnselectNodes(ResourceNodeDir* node)
{
	if(!node)
		return;

	node->selectedRight=false;

	for(std::list<ResourceNode*>::iterator nCh=node->files.begin();nCh!=node->files.end();nCh++)
		(*nCh)->selectedRight=0;

	for(std::list<ResourceNodeDir*>::iterator nCh=node->dirs.begin();nCh!=node->dirs.end();nCh++)
		this->UnselectNodes(*nCh);
}




ResourceNode* GuiProjectViewer::FileViewer::GetHoveredRow(ResourceNodeDir* iResourceNodeDirNode,vec2& iMousePos,vec2& iFramePos,bool& oExpandos)
{
	float drawFromHeight=this->vScrollbar.scrollerPosition*this->contentHeight;

	for(std::list<ResourceNodeDir*>::iterator dir=iResourceNodeDirNode->dirs.begin();dir!=iResourceNodeDirNode->dirs.end();dir++)
	{
		if(iFramePos.y+ROW_HEIGHT>=drawFromHeight && iFramePos.y<=drawFromHeight+this->rect.w)
		{
			float relativeY=this->rect.y+iFramePos.y-drawFromHeight;

			ResourceNodeDir* node=(*dir);

			float xCursor=this->rect.x+ROW_ADVANCE*node->level;

			if(iMousePos.y>relativeY && iMousePos.y<relativeY+GuiSceneViewer::ROW_HEIGHT)
				return node;
		}

		iFramePos.y+=ROW_HEIGHT;
	}

	for(std::list<ResourceNode*>::iterator file=iResourceNodeDirNode->files.begin();file!=iResourceNodeDirNode->files.end();file++)
	{
		if(iFramePos.y+ROW_HEIGHT>=drawFromHeight && iFramePos.y<=drawFromHeight+this->rect.w)
		{
			float relativeY=this->rect.y+iFramePos.y-drawFromHeight;

			ResourceNode* node=(*file);

			float xCursor=this->rect.x+ROW_ADVANCE*node->level;

			if(iMousePos.y>relativeY && iMousePos.y<relativeY+GuiSceneViewer::ROW_HEIGHT)
				return node;

		}

		iFramePos.y+=ROW_HEIGHT;
	}

	return 0;
}
void GuiProjectViewer::FileViewer::OnLMouseDown(Tab* tabContainer,void* data)
{
	if(this->hovering)
	{
		vec2& mpos=*(vec2*)data;

		if(!InputManager::keyboardInput.IsPressed(0x11/*VK_CONTROL*/))
			this->selectedFiles.clear();

		vec2 tDrawCanvas(0,0);

		bool exp=false;
		ResourceNode* node=this->GetHoveredRow(this->rootResource,mpos,tDrawCanvas,exp);

		if(node)
		{
			this->UnselectNodes(this->rootResource);

			if(!node->selectedRight)
				node->selectedRight=true;

			if(exp)
			{
				this->CalcNodesHeight(this->rootResource);
				this->OnSize(tabContainer);
			}

			this->selectedFiles.push_back(node);

			//TabContainer::BroadcastToPool(&TabContainer::OnGuiEntitySelected,this->selection[0]);
		}
		else
		{
			this->UnselectNodes(this->rootResource);
		}

		tabContainer->SetDraw(2,0,this);
	}

	GuiRect::OnLMouseDown(tabContainer,data);
}
void GuiProjectViewer::FileViewer::OnRMouseUp(Tab* tabContainer,void* data)
{
	GuiRect::OnRMouseUp(tabContainer,data);

	vec2& mpos=*(vec2*)data;

	vec2 tDrawCanvas(0,0);

	bool tHoveredResourceNodeExpandedPressed=false;
	ResourceNode* tHoveredResourceNode=this->GetHoveredRow(this->rootResource,mpos,tDrawCanvas,tHoveredResourceNodeExpandedPressed);

	int menuResult=tabContainer->TrackProjectFileViewerPopup(tHoveredResourceNode);

	switch(menuResult)
	{
		case 1:
			if(tHoveredResourceNode && tHoveredResourceNode->parent)
			{
				ResourceNodeDir* parentDirectory=(ResourceNodeDir*)tHoveredResourceNode->parent;

				String tFileNameBase=tHoveredResourceNode->parent->fileName + "\\" + tHoveredResourceNode->fileName;
                String tFileNameBaseExtended=tFileNameBase + Ide::instance->GetEntityExtension();

				//first remove from the list

				if(tHoveredResourceNode->isDir)
                {
                    parentDirectory->dirs.remove((ResourceNodeDir*)tHoveredResourceNode);

                    Ide::instance->subsystem->Execute(parentDirectory->fileName.Buffer(),"rd /S /Q " + tHoveredResourceNode->fileName);
                }
				else
                {
                    parentDirectory->files.remove(tHoveredResourceNode);

                    File::Delete(tFileNameBase.Buffer());
                    File::Delete(tFileNameBaseExtended.Buffer());
                }

				SAFEDELETE(tHoveredResourceNode);
			}
		break;
		case 3://load
			if(tHoveredResourceNode->fileName.Extension() == &Ide::instance->GetSceneExtension()[1])
			{
				GuiSceneViewer* tGuiSceneViewer=GuiSceneViewer::GetPool().front();

				if(tGuiSceneViewer)
				{
					String tHoveredNodeFilename=tHoveredResourceNode->parent->fileName + "\\" + tHoveredResourceNode->fileName;

					tGuiSceneViewer->Load(tHoveredNodeFilename.Buffer());
					tGuiSceneViewer->GetRootRect()->tabContainer->SetDraw(2,0,tGuiSceneViewer);
				}
			}
		break;
	}

	this->OnSize(tabContainer);
	tabContainer->SetDraw(2,0,this);
}



void GuiProjectViewer::FileViewer::OnPaint(Tab* tabContainer,void* data)
{
	bool selfClip=this->BeginSelfClip(tabContainer);

	this->DrawBackground(tabContainer);

	tabContainer->renderer2D->PushScissor(this->rect.x,this->rect.y,this->rect.x+this->rect.z,this->rect.y+this->rect.w);

	vec2 tDrawCanvas(0,0);

	this->DrawNodes(tabContainer,this->rootResource,tDrawCanvas);

	tabContainer->renderer2D->PopScissor();

	this->BroadcastToChilds(&GuiRect::OnPaint,tabContainer,data);

	this->EndSelfClip(tabContainer,selfClip);
}

void GuiProjectViewer::FileViewer::OnDLMouseDown(Tab* iTabContainer,void* data)
{
	if(this==iTabContainer->GetFocus())
	{
		vec2& mpos=*(vec2*)data;

		vec2 tDrawCanvas(0,0);

		bool tHoveredResourceNodeExpandedPressed=false;
		ResourceNode* tHoveredResourceNode=this->GetHoveredRow(this->rootResource,mpos,tDrawCanvas,tHoveredResourceNodeExpandedPressed);

		if(tHoveredResourceNode)
		{
			if(!tHoveredResourceNode->isDir)
			{
				String tExtension=tHoveredResourceNode->fileName.Extension();
				String tFilename=tHoveredResourceNode->parent->fileName + "\\" + tHoveredResourceNode->fileName;

				if(tExtension == &Ide::instance->GetSceneExtension()[1])
				{
					Thread* renderThread=GuiViewport::GetPool()[0]->GetRootRect()->tabContainer->threadRender;
					Task* drawTask=GuiViewport::GetPool()[0]->GetRootRect()->tabContainer->taskDraw;

					drawTask->Block(true);

					GuiSceneViewer* guiSceneViewer=iTabContainer->parentWindowContainer->SpawnViewer<GuiSceneViewer>();
					guiSceneViewer->Load(tFilename.Buffer());

					drawTask->Block(false);

					//guiSceneViewer->GetRootRect()->tabContainer->SetDraw(2,0,guiSceneViewer);
				}
				else if(tExtension=="cpp")
				{
					/*GuiScriptViewer* guiScriptViewer=tabContainer->parentWindowContainer->SpawnViewer<GuiScriptViewer>();
					guiScriptViewer->Open(tFilename);
					guiScriptViewer->GetRootRect()->tabContainer->SetDraw(2,0,guiScriptViewer);*/
				}
			}
			else
			{
				ResourceNodeDir* tResourceNodeDir=(ResourceNodeDir*)tHoveredResourceNode;

				DirViewer& tDirViewer=this->projectViewer->dirViewer;

				tDirViewer.UnselectNodes(tDirViewer.rootResource);

				if(!tResourceNodeDir->selectedLeft)
					tResourceNodeDir->selectedLeft=true;

				tDirViewer.CalcNodesHeight(tDirViewer.rootResource);
				tDirViewer.OnSize(iTabContainer);

				this->rootResource=tResourceNodeDir;

				this->CalcNodesHeight(this->rootResource);
				this->OnSize(iTabContainer);

				iTabContainer->SetDraw(2,0,&tDirViewer);
				iTabContainer->SetDraw(2,0,this);
			}
		}
	}

	GuiRect::OnDLMouseDown(iTabContainer,data);
}

///////////////////////////////////////////////
///////////////////////////////////////////////
//////////////////////GuiImage/////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////
GuiImage::GuiImage():
width(0),
height(0),
bpp(0)
{}

GuiImage::~GuiImage()
{
	this->width=-1;
	this->height=-1;
	this->bpp=-1;
}

///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////DrawInstance/////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////


DrawInstance::DrawInstance(int iNoneAllRect,bool iFrame,GuiRect* iRect,const char* iName,bool iRemove):code(iNoneAllRect),frame(iFrame),rect(iRect),name(iName),remove(iRemove){}

///////////////////////////////////////////////
///////////////////////////////////////////////
////////////////////GuiPaper///////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

GuiPaper::GuiPaper():lineCount(0),lineNumbers(true)
{
	this->textSpot.make(0,0);
	this->textAlign.make(0,0);
}

void GuiPaper::DrawLineNumbers(Tab* tabContainer)
{
	float tTextHeight=tabContainer->renderer2D->GetFontHeight();
	float tRowY=this->rect.y;

	for(int i=0;i<this->lineCount;i++)
	{
		tabContainer->renderer2D->DrawText(String(i+1).Buffer(),this->rect.x,tRowY,this->rect.x + this->rect.z,tRowY + tTextHeight);
		tRowY+=tTextHeight;
	}
}

void GuiPaper::DrawBreakpoints(Tab* tabContainer)
{
	float tFontHeight=tabContainer->renderer2D->GetFontHeight();

	std::vector<Debugger::Breakpoint>& breakpoints=Ide::instance->debugger->breakpointSet;

	for(size_t i=0;i<breakpoints.size();i++)
	{
		if(breakpoints[i].script==this->scriptViewer->script)
		{
			unsigned int tLineInsertion=this->rect.y + (breakpoints[i].line - 1) * tFontHeight;

			unsigned int tBreakColor = breakpoints[i].breaked ? 0xff0000 : 0xffff00 ;

			tabContainer->renderer2D->DrawRectangle(this->rect.x + 1,tLineInsertion + 1,this->rect.x+this->textOffsets.x -1,tLineInsertion + tFontHeight - 1,tBreakColor,true);
		}
	}
}

void GuiPaper::OnPaint(Tab* tabContainer,void* data)
{
	bool selfClip=this->BeginSelfClip(tabContainer);

	this->DrawBackground(tabContainer);

	this->DrawBreakpoints(tabContainer);

	if(this->lineNumbers)
		this->DrawLineNumbers(tabContainer);

	this->DrawTheText(tabContainer);

	this->BroadcastToChilds(&GuiRect::OnPaint,tabContainer,data);

	this->EndSelfClip(tabContainer,selfClip);
}

void GuiPaper::OnLMouseDown(Tab* tabContainer,void* iData)
{
	GuiString::OnLMouseDown(tabContainer,iData);

	vec2 tMpos=*(vec2*)iData;

	tMpos.y=!this->clip ? tMpos.y : tMpos.y+this->clip->vScrollbar.scrollerPosition*this->clip->contentHeight;

	if(tMpos.x < this->textOffsets.x)
	{
		unsigned int tBreakOnLine=(tMpos.y-this->rect.y)/tabContainer->renderer2D->GetFontHeight() + 1;

		EditorScript* tEditorScript=(EditorScript*)this->scriptViewer->script;

		std::vector<Debugger::Breakpoint>& tAvailableBreakpoints=Ide::instance->debugger->allAvailableBreakpoints;
		std::vector<Debugger::Breakpoint>& tBreakpoints=Ide::instance->debugger->breakpointSet;

		for(size_t i=0;i<tAvailableBreakpoints.size();i++)
		{
			if(tAvailableBreakpoints[i].script==this->scriptViewer->script && tAvailableBreakpoints[i].line==tBreakOnLine)
			{
				std::vector<Debugger::Breakpoint>::iterator tFoundedBreakpointIterator=std::find(tBreakpoints.begin(),tBreakpoints.end(),tAvailableBreakpoints[i]);

				bool tAdd=tBreakpoints.end()==tFoundedBreakpointIterator;

				if(tAdd)
					tBreakpoints.push_back(tAvailableBreakpoints[i]);
				else
					tBreakpoints.erase(tFoundedBreakpointIterator);

				Ide::instance->debugger->SetBreakpoint(tAvailableBreakpoints[i],tAdd);

				tabContainer->SetDraw(2,false,this->scriptViewer);

				break;
			}
		}
	}
}

///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////GuiScriptViewer/////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

GuiScriptViewer::GuiScriptViewer():
	script(0),
	lineNumbers(true)
{
	this->name="ScriptViewer";

	this->paper=this->Create<GuiPaper>();
	this->paper->scriptViewer=this;
	this->paper->name="ScriptSource";
	this->paper->SetClip(this);
	this->paper->textOffsets.make(20,0,0,0);
}

void GuiScriptViewer::Open(Script* iScript)
{
	this->script=(EditorScript*)iScript;
	this->paper->cursor=StringEditor::Cursor();

	if(!iScript->script.IsOpen())
	{
		if(iScript->script.Open())
		{
			int size=iScript->script.Size();

			if(size>0)
			{
				char* buf=new char[size+1];
				iScript->script.Read(buf,size);
				buf[size]='\0';
				this->paper->text=buf;
				delete [] buf;
			}

			iScript->script.Close();
		}

		this->paper->cursor.cursor=(char*)this->paper->text.c_str();
		this->paper->cursor.rowcol.make(0,0);

		Ide::instance->stringEditor->Bind(this->paper,&this->paper->cursor);
	}

	this->script->scriptViewer=this;
}

bool GuiScriptViewer::Save()
{
	if(this->script)
	{
		if(!File::Exist(this->script->script.path.Buffer()))
			File::Create(this->script->script.path.Buffer());

		if(this->script->script.Open("wb"))
		{
			this->script->script.Write((void*)this->paper->text.c_str(),this->paper->text.size(),1);

			this->script->script.Close();

			return true;
		}
		else
			DEBUG_BREAK();
	}

	return false;
}


bool GuiScriptViewer::Compile()
{
	bool exited=false;
	bool compiled=false;
	bool runned=false;

	if(this->script)
	{
		exited=Ide::instance->compiler->UnloadScript(this->script);

		compiled=Ide::instance->compiler->Compile(this->script);

		runned=Ide::instance->compiler->LoadScript(this->script);
	}

	return exited && compiled && runned;
}



void GuiScriptViewer::OnKeyDown(Tab* tabContainer,void* iData)
{
	if(this->script)
	{
		if(InputManager::keyboardInput.IsPressed(0x11/*VK_CONTROL*/) && !InputManager::keyboardInput.IsPressed(0x12/*VK_ALT*/))
		{
			if(InputManager::keyboardInput.IsPressed('S'))
				this->Save();
		}
		else
		{
			bool tRedraw=this->paper->ParseKeyInput(tabContainer,iData);

			if(tRedraw)
				tabContainer->SetDraw(2,0,this);
		}
	}

	GuiRect::OnKeyDown(tabContainer,iData);
}

void GuiScriptViewer::OnKeyUp(Tab* tabContainer,void* data)
{
	GuiRect::OnKeyUp(tabContainer,data);
}

void GuiScriptViewer::OnLMouseDown(Tab* tabContainer,void* iData)
{
	GuiRect::OnLMouseDown(tabContainer,iData);

	vec2 tMpos=*(vec2*)iData;

	tabContainer->SetFocus(this->paper);

	Ide::instance->stringEditor->Bind(this->paper,&this->paper->cursor);
	Ide::instance->stringEditor->Enable(true);
}

void GuiScriptViewer::OnDeactivate(Tab* tabContainer,void* data)
{
	tabContainer->SetFocus(0);
	Ide::instance->stringEditor->Enable(false);

	GuiRect::OnDeactivate(tabContainer,data);
}

void GuiScriptViewer::OnMouseMove(Tab* tabContainer,void* data)
{
	GuiRect::OnMouseMove(tabContainer,data);

	if(this->hovering)
	{
		vec2 tMpos=*(vec2*)data;

		if(tMpos.x < this->paper->textOffsets.x)
		{

		}
		else
		{

		}
	}
}

void GuiScriptViewer::OnSize(Tab* tabContainer,void* data)
{
	if(!this->paper->text.empty())
	{
		this->paper->lineCount=this->CountScriptLines()-1;

		float tFontHeight=tabContainer->renderer2D->GetFontHeight();

		this->contentHeight=this->paper->lineCount * tFontHeight;
	}

	GuiScrollRect::OnSize(tabContainer,data);
}


int GuiScriptViewer::CountScriptLines()
{
	char* t=(char*)this->paper->text.c_str();

	int tLinesCount=!(*t) ? 0 : 1;

	while(*t)
	{
		if(*t=='\n' || *t=='\r')
			tLinesCount++;

		t++;
	}

	return tLinesCount;
}

///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////GuiCompilerViewer///////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

GuiCompilerViewer::GuiCompilerViewer(){this->name="Compiler";}

wchar_t* nthOccurrenceInLine(wchar_t* iStr,char iChar,int iNth)
{
	wchar_t* str=iStr;
	int occurr=0;

	char c=*str;

	while(c!='\0' || c!='\n')
	{
		if(c==iChar)
		{
			if(++occurr==iNth)
				return str;
		}

		c=*(++str);
	}

	return 0;
}


bool GuiCompilerViewer::ParseCompilerOutputFile(wchar_t* fileBuffer)
{
	bool bReturnValue=true;

	this->vScrollbar.SetParent(0);

	this->DestroyChilds();

	GuiRect* messagesGlue=this->Create<GuiRect>();

	const int MESSAHE_ROW_HEIGHT=20;

	if(fileBuffer)
	{
		wchar_t* LineBegin=fileBuffer;
		wchar_t* FileEnd=LineBegin;
		while(*FileEnd++);

		while(LineBegin!=FileEnd-1)
		{
			wchar_t* LineEnd=wcschr(LineBegin,'\n');

			wchar_t* compileError=wcsstr(LineBegin,L"error C");
			wchar_t* linkError=wcsstr(LineBegin,L"error LNK");

			compileError!=0 && LineEnd < compileError ? compileError=0 : 0;
			linkError!=0 && LineEnd < linkError ? linkError=0 : 0;

			bool simpleMessage=!compileError && !linkError;

			GuiString* tCompilerMessageRow=new GuiString;

			{
				/*tCompilerMessageRow->fixed.w=MESSAHE_ROW_HEIGHT;
				tCompilerMessageRow->alignRect.y=-1;
				tCompilerMessageRow->alignText.make(-1,0.5f);*/
			}

			if(simpleMessage)
			{
				tCompilerMessageRow->wText=std::wstring(LineBegin,LineEnd-LineBegin);
			}
			else
			{
				bReturnValue=false;

				wchar_t* FileEnd=nthOccurrenceInLine(LineBegin,':', compileError ? 2 : 1);//the first : should be the volume drive

				if(FileEnd)
					FileEnd+=2;

				wchar_t* ErrorEnd=nthOccurrenceInLine(FileEnd,':',1);

				if(ErrorEnd)
					ErrorEnd+=2;

				tCompilerMessageRow->wText=/*std::wstring(LineBegin,FileEnd-LineBegin)*/std::wstring(FileEnd,ErrorEnd-FileEnd).append(std::wstring(ErrorEnd,LineEnd-ErrorEnd));
				tCompilerMessageRow->colorBackground=0xff0000;
			}

			tCompilerMessageRow->SetEdges(0,&messagesGlue->edges.w);

			tCompilerMessageRow->SetParent(this);

			LineBegin=++LineEnd;
		}

		this->vScrollbar.SetParent(this);

		this->contentHeight=messagesGlue->childs.size()*MESSAHE_ROW_HEIGHT;

		messagesGlue->SetClip(this);

	}

	return bReturnValue;
}


void GuiCompilerViewer::OnSize(Tab* tabContainer,void* data)
{
	this->vScrollbar.SetScrollerRatio(this->contentHeight,this->rect.w);

	if(this->childs.size()==2)
		//we don't need the GuiScrollRect::width cause the newly GuiRect::offset
		this->vScrollbar.IsVisible() ? this->childs[0]->offsets.z=-GuiScrollBar::SCROLLBAR_TICK : this->childs[0]->offsets.z=0;

	GuiRect::OnSize(tabContainer,data);

	this->rect.z=this->rect.z;
}


///////////////////////////////////////////////
///////////////////////////////////////////////
/////////////////Properties////////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////



void EditorEntity::OnPropertiesCreate()
{
	std::vector<GuiRect*> lvl(2);

	this->container=this->properties.Container("Entity");

	lvl[0]=this->container;
	lvl[0]->Property("Name",&this->name,GuiPropertyString::STRING);
	lvl[0]->Property("Ptr",this,GuiPropertyString::PTR);
	lvl[0]->Property("Position",&this->world,GuiPropertyString::MAT4POS);
	lvl[1]=lvl[0]->Container("AABB");
	lvl[1]->Property("Min",this->bbox.a,GuiPropertyString::VEC3);
	lvl[1]->Property("Max",this->bbox.b,GuiPropertyString::VEC3);
	lvl[1]->Property("Volume",this->bbox.a,GuiPropertyString::VEC3,this->bbox.b);
	lvl[0]->Property("ChildNum",&this->childs,GuiPropertyString::ENTITYVECSIZE);
}

void EditorEntity::OnPropertiesUpdate(Tab* tab)
{
	for(std::vector<EntityComponent*>::iterator it=this->components.begin();it!=this->components.end();it++)
	{
		EditorProperties* componentProperties=dynamic_cast<EditorProperties*>(*it);
		if(componentProperties)
			componentProperties->OnPropertiesUpdate(tab);
	}
}

void EditorMesh::OnPropertiesCreate()
{
	EditorEntity* tEditorEntity=(EditorEntity*)this->entity;

	this->container=tEditorEntity->properties.Container("Mesh");

	this->container->Property("Controlpoints",&this->ncontrolpoints,GuiPropertyString::INT);
	this->container->Property("Normals",&this->nnormals,GuiPropertyString::INT);
	this->container->Property("Polygons",&this->npolygons,GuiPropertyString::INT);
	this->container->Property("Texcoord",&this->ntexcoord,GuiPropertyString::INT);
	this->container->Property("Vertexindices",&this->nvertexindices,GuiPropertyString::INT);
}

void EditorMesh::OnPropertiesUpdate(Tab* tab)
{
}

void EditorSkin::OnPropertiesCreate()
{
	EditorEntity* tEditorEntity=(EditorEntity*)this->entity;

	this->container=tEditorEntity->properties.Container("Skin");

	this->container->Property("Clusters",&this->nclusters,GuiPropertyString::INT);
	this->container->Property("Textures",&this->ntextures,GuiPropertyString::INT);
}
void EditorSkin::OnPropertiesUpdate(Tab* tab)
{
}
void EditorRoot::OnPropertiesCreate()
{
	EditorEntity* tEditorEntity=(EditorEntity*)this->entity;

	this->container=tEditorEntity->properties.Container("Root");
}
void EditorRoot::OnPropertiesUpdate(Tab* tab)
{
}
void EditorSkeleton::OnPropertiesCreate()
{
	EditorEntity* tEditorEntity=(EditorEntity*)this->entity;

	this->container=tEditorEntity->properties.Container("Skeleton");
}
void EditorSkeleton::OnPropertiesUpdate(Tab* tab)
{
}
void EditorGizmo::OnPropertiesCreate()
{
	EditorEntity* tEditorEntity=(EditorEntity*)this->entity;

	this->container=tEditorEntity->properties.Container("Gizmo");
}
void EditorGizmo::OnPropertiesUpdate(Tab* tab)
{
}
void EditorAnimation::OnPropertiesCreate()
{
	EditorEntity* tEditorEntity=(EditorEntity*)this->entity;

	this->container=tEditorEntity->properties.Container("Animation");

	this->container->Property("IsBone",this,GuiPropertyString::ISBONECOMPONENT);
	this->container->Property("Duration",&this->start,GuiPropertyString::FLOAT2MINUSFLOAT1,&this->end);
	this->container->Property("Begin",&this->start,GuiPropertyString::FLOAT);
	this->container->Property("End",&this->end,GuiPropertyString::FLOAT);
}
void EditorAnimation::OnPropertiesUpdate(Tab* tab)
{
}
void EditorAnimationController::OnPropertiesCreate()
{
	EditorEntity* tEditorEntity=(EditorEntity*)this->entity;

	this->container=tEditorEntity->properties.Container("AnimationController");

	this->container->name="EditorAnimationControllerProperties";
	this->container->text="AnimationController";
	this->container->Property("Number of nodes",&this->animations,GuiPropertyString::ANIMATIONVECSIZE);
	this->container->SliderProperty("Velocity",this->speed,this->start,this->end);
	this->container->Property("Duration",&this->start,GuiPropertyString::FLOAT2MINUSFLOAT1,&this->end);
	this->container->Property("Begin",&this->start,GuiPropertyString::FLOAT);
	this->container->Property("End",&this->end,GuiPropertyString::FLOAT);
	guiPropertyAnimationController=this->container->AnimationControllerProperty(*this);
}

void EditorAnimationController::OnPropertiesUpdate(Tab* tab)
{
	if(this->oldCursor!=this->cursor)
		tab->SetDraw(2,0,&guiPropertyAnimationController->guiAnimationController.slider);

	this->oldCursor=this->cursor;
}



void EditorBone::OnPropertiesCreate()
{
	EditorEntity* tEditorEntity=(EditorEntity*)this->entity;

	this->container=tEditorEntity->properties.Container("Bone");
}
void EditorBone::OnPropertiesUpdate(Tab* tab)
{
}
void EditorLight::OnPropertiesCreate()
{
	EditorEntity* tEditorEntity=(EditorEntity*)this->entity;

	this->container=tEditorEntity->properties.Container("Light");
}
void EditorLight::OnPropertiesUpdate(Tab* tab)
{
}

void editScriptEditorCallback(void* iData)
{
	EditorScript* editorScript=(EditorScript*)iData;

	Tab* tabContainer=Ide::instance->mainAppWindow->containers[0]->tabContainers[0];

	if(!tabContainer)
		DEBUG_BREAK();

	if(GuiScriptViewer::GetPool().empty())
		tabContainer->tabs.ScriptViewer();

	GuiScriptViewer* guiScriptViewer=GuiScriptViewer::GetPool().front();

	if(guiScriptViewer)
	{
		guiScriptViewer->Open(editorScript);
		tabContainer->SetDraw(0,1);
	}
}

void compileScriptEditorCallback(void* iData)
{
	EditorScript* editorScript=(EditorScript*)iData;

    Ide::instance->compiler->Compile(editorScript);
}

void launchStopScriptEditorCallback(void* iData)
{
	EditorScript* editorScript=(EditorScript*)iData;

	if(editorScript->runtime)
	{
		if(Ide::instance->compiler->UnloadScript(editorScript))
			editorScript->buttonLaunch->text="Launch";
	}
	else
	{
		if(Ide::instance->compiler->LoadScript(editorScript))
			editorScript->buttonLaunch->text="Stop";
	}

	editorScript->container->GetRootRect()->tabContainer->SetDraw(2,0,editorScript->buttonLaunch);
}

EditorScript::EditorScript():scriptViewer(0)
{

};

void EditorScript::OnPropertiesCreate()
{
	EditorEntity* tEditorEntity=(EditorEntity*)this->entity;

	this->container=tEditorEntity->properties.Container("Script");

	GuiProperty* tFile=container->Property("File",&this->Script::script.path,GuiPropertyString::STRING);
	GuiProperty* tRunning=container->Property("Running",&this->Script::runtime,GuiPropertyString::BOOLPTR);

	GuiButtonFunc* buttonEdit=new GuiButtonFunc;
	buttonEdit->name="EditorScript Edit Button";
	buttonEdit->func=editScriptEditorCallback;
	buttonEdit->param=this;
	buttonEdit->colorHovering=Renderer2D::COLOR_GUI_BACKGROUND+30;
	buttonEdit->colorPressing=Renderer2D::COLOR_GUI_BACKGROUND+90;
	buttonEdit->text="Edit";
	buttonEdit->fixed.make(0,0,0,20);
	container->AppendAsProperty(buttonEdit);

	GuiButtonFunc* buttonCompile=new GuiButtonFunc;
	buttonCompile->func=compileScriptEditorCallback;
	buttonCompile->param=this;
	buttonCompile->colorHovering=Renderer2D::COLOR_GUI_BACKGROUND+30;
	buttonCompile->colorPressing=Renderer2D::COLOR_GUI_BACKGROUND+90;
	buttonCompile->text="Compile";
	buttonCompile->fixed.make(0,0,0,20);
	container->AppendAsProperty(buttonCompile);

	this->buttonLaunch=new GuiButtonFunc;
	this->buttonLaunch->func=launchStopScriptEditorCallback;
	this->buttonLaunch->param=this;
	this->buttonLaunch->colorHovering=Renderer2D::COLOR_GUI_BACKGROUND+30;
	this->buttonLaunch->colorPressing=Renderer2D::COLOR_GUI_BACKGROUND+90;
	this->buttonLaunch->text="Launch";
	this->buttonLaunch->fixed.make(0,0,0,20);
	container->AppendAsProperty(this->buttonLaunch);
}
void EditorScript::OnPropertiesUpdate(Tab* tab)
{
}

void EditorScript::OnResourcesCreate()
{
	String tFileNamePath=Ide::instance->folderProject + "\\" + this->entity->name;
	this->script.path=tFileNamePath + ".cpp";

	if(!File::Exist(this->script.path.Buffer()))
	{
		if(!File::Create(this->script.path.Buffer()))
			DEBUG_BREAK();

		if(this->script.Open("wb"))
		{
			String content="#include \"entities.h\"\n\nstruct " + this->entity->name + "_ : EntityScript\n{\n\t int counter;\n\tvoid init()\n\t{\n\t\tcounter=0;\n\tthis->entity->local.identity();\n\t\tprintf(\"inited\\n\");\n\t}\n\n\tvoid update()\n\t{\n\t\tthis->entity->local.translate(0.1f,0,0);\n\t//printf(\"counter: %d\\n\",counter);\n\tcounter++;\n\t}\n\n\tvoid deinit()\n\t{\n\t\tprintf(\"deinited\\n\");\n\t}\n\n};\n";
			int contantCount=content.Count();

			this->script.Write((void*)content.Buffer(),contantCount,1);
			this->script.Close();
		}
	}
}

void EditorCamera::OnPropertiesCreate()
{
	EditorEntity* tEditorEntity=(EditorEntity*)this->entity;

	this->container=tEditorEntity->properties.Container("Camera");
}
void EditorCamera::OnPropertiesUpdate(Tab* tab)
{
}


///////////////////////////////////////////////
///////////////////////////////////////////////
/////////////////FileSystem////////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

bool FileExists(const char* iFile)
{
	FILE* tFile=fopen(iFile,"rb");

	if(tFile)
	{
		return true;
		fclose(tFile);
	}

	return false;
}
