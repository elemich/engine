#include "interfaces.h"

//__declspec(dllimport) template <> TStaticInstance<EngineIDE>::TStaticInstance(){}
//template <class T> std::vector<T*> TPoolVector<T>::GetPool();

///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////////AppInterface////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

EngineIDE::EngineIDE():timerMain(0),mainAppWindow(0),compiler(0),processId(0),processThreadId(0){}

const char* EngineIDE::GetSceneExtension()
{
	return ".engineScene";	
}
const char* EngineIDE::GetEntityExtension()
{
	return ".engineEntity";
}

///////////////////////////////////////////////
///////////////////////////////////////////////
///////////EditorWindowContainer///////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

Container::Container()
{
	resizeDiffHeight=0;
	resizeDiffWidth=0;
	resizeEnumType=-1;
	resizeCheckWidth=0;
	resizeCheckHeight=0;
}

///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////////Debugger//////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////
Debugger::Debugger():breaked(false),threadSuspendend(false),runningScript(0),runningScriptFunction(0),debuggerCode(0),lastBreakedAddress(0){}


///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////////TouchInput//////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

TouchInput::TouchInput()
{
	for(int i=0;i<10;i++)
	{
		pressed[i]=0;
		released[i]=0;
		position[i].make(0,0);
	}
}

bool TouchInput::IsPressed(int i){return pressed[i];}
bool TouchInput::IsReleased(int i){return released[i];}

void TouchInput::SetPressed(bool b,int i){pressed[i]=b;}
void TouchInput::SetReleased(bool b,int i){released[i]=b;}


vec2& TouchInput::GetPosition(int i){return position[i];}
void   TouchInput::SetPosition(vec2& pos,int i){position[i]=pos;}

MouseInput::MouseInput()
{}

bool MouseInput::Left(){return this->left;}
bool MouseInput::Right(){return this->right;}
bool MouseInput::Middle(){return this->middle;}

TouchInput InputManager::touchInput;
MouseInput InputManager::mouseInput;
KeyboardInput InputManager::keyboardInput;

/*
InputInterface InputManager::voiceInput;
InputInterface InputManager::joystickInput;*/


///////////////////////////////////////////////
///////////////////////////////////////////////
//////////////////TabContainer/////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

unsigned char Tab::rawUpArrow[]={0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0xa7,0x0,0x0,0x0,0xa8,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x87,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0x88,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6a,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0x6b,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4b,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0x4c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2b,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xfe,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xfe,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0x2c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xb,0x0,0x0,0x0,0xfa,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xfb,0x0,0x0,0x0,0xc,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7,0x0,0x0,0x0,0xdc,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xdc,0x0,0x0,0x0,0x7,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc,0x0,0x0,0x0,0xe7,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xe7,0x0,0x0,0x0,0xc,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0};
unsigned char Tab::rawRightArrow[]={0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc,0x0,0x0,0x0,0x7,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe7,0x0,0x0,0x0,0xdc,0x0,0x0,0x0,0xb,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xfa,0x0,0x0,0x0,0x2b,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0x4b,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xfe,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0x6a,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0x87,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xa7,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xa8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0x88,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xfe,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0x6b,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0x4c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xfb,0x0,0x0,0x0,0x2c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe7,0x0,0x0,0x0,0xdc,0x0,0x0,0x0,0xc,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc,0x0,0x0,0x0,0x7,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0};
unsigned char Tab::rawDownArrow[]={0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc,0x0,0x0,0x0,0xe7,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xe7,0x0,0x0,0x0,0xc,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7,0x0,0x0,0x0,0xdc,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xdc,0x0,0x0,0x0,0x7,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc,0x0,0x0,0x0,0xfb,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xfa,0x0,0x0,0x0,0xb,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2c,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xfe,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xfe,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0x2b,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4c,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0x4b,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6b,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0x6a,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x88,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0x87,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0xa8,0x0,0x0,0x0,0xa7,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0};
unsigned char Tab::rawFolder[]={0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe6,0xc1,0x9b,0x12,0xe9,0xc4,0x9f,0xd8,0xe9,0xc4,0xa0,0xff,0xe9,0xc4,0xa0,0xff,0xe9,0xc4,0xa0,0xff,0xe9,0xc4,0xa0,0xff,0xe9,0xc4,0xa0,0xff,0xe6,0xc0,0x9a,0x5b,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe5,0xc1,0x9e,0x20,0xe5,0xc2,0x9e,0xef,0xe5,0xc2,0x9e,0xff,0xe5,0xc2,0x9e,0xff,0xe5,0xc2,0x9d,0xff,0xe5,0xc2,0x9d,0xff,0xe5,0xc2,0x9d,0xff,0xe4,0xc2,0x9c,0xa6,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe3,0xbe,0x98,0x21,0xdf,0xb9,0x94,0xee,0xdf,0xb9,0x93,0xff,0xdf,0xb9,0x93,0xff,0xde,0xb9,0x92,0xff,0xde,0xb9,0x93,0xff,0xde,0xb9,0x93,0xff,0xdd,0xb7,0x90,0xe4,0xda,0xb2,0x89,0xa2,0xda,0xb2,0x8a,0xa3,0xda,0xb2,0x8a,0xa3,0xda,0xb2,0x8a,0xa3,0xda,0xb2,0x8a,0x86,0xe6,0xc1,0x97,0xf,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfb,0xda,0xaf,0xd2,0xf7,0xd6,0xab,0xfd,0xf7,0xd6,0xab,0xff,0xf7,0xd6,0xab,0xff,0xf7,0xd6,0xab,0xff,0xf6,0xd6,0xab,0xff,0xf6,0xd6,0xab,0xff,0xf6,0xd6,0xab,0xff,0xf6,0xd5,0xab,0xff,0xf6,0xd5,0xab,0xff,0xf6,0xd5,0xab,0xff,0xf6,0xd5,0xab,0xff,0xf6,0xd5,0xab,0xff,0xfa,0xda,0xaf,0xd7,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf7,0xd5,0xaa,0xff,0xf7,0xd5,0xaa,0xff,0xf7,0xd5,0xaa,0xff,0xf7,0xd5,0xaa,0xff,0xf7,0xd5,0xaa,0xff,0xf7,0xd5,0xaa,0xff,0xf7,0xd5,0xaa,0xff,0xf7,0xd5,0xaa,0xff,0xf7,0xd5,0xaa,0xff,0xf7,0xd5,0xaa,0xff,0xf7,0xd5,0xaa,0xff,0xf7,0xd5,0xaa,0xff,0xf7,0xd5,0xaa,0xff,0xf7,0xd5,0xaa,0xff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf3,0xcf,0xa3,0xff,0xf3,0xcf,0xa3,0xff,0xf3,0xcf,0xa3,0xff,0xf3,0xcf,0xa3,0xff,0xf3,0xcf,0xa3,0xff,0xf3,0xcf,0xa3,0xff,0xf3,0xcf,0xa3,0xff,0xf3,0xcf,0xa3,0xff,0xf3,0xcf,0xa3,0xff,0xf3,0xcf,0xa3,0xff,0xf3,0xcf,0xa3,0xff,0xf3,0xcf,0xa3,0xff,0xf3,0xcf,0xa3,0xff,0xf3,0xcf,0xa3,0xff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xee,0xc8,0x9b,0xff,0xee,0xc8,0x9b,0xff,0xee,0xc8,0x9b,0xff,0xee,0xc8,0x9b,0xff,0xee,0xc8,0x9b,0xff,0xee,0xc8,0x9b,0xff,0xee,0xc8,0x9b,0xff,0xee,0xc8,0x9b,0xff,0xee,0xc8,0x9b,0xff,0xee,0xc8,0x9b,0xff,0xee,0xc8,0x9b,0xff,0xee,0xc8,0x9b,0xff,0xee,0xc8,0x9b,0xff,0xee,0xc8,0x9b,0xff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xea,0xc2,0x95,0xff,0xea,0xc2,0x95,0xff,0xea,0xc2,0x95,0xff,0xea,0xc2,0x95,0xff,0xea,0xc2,0x95,0xff,0xea,0xc2,0x95,0xff,0xea,0xc2,0x95,0xff,0xea,0xc2,0x95,0xff,0xea,0xc2,0x95,0xff,0xea,0xc2,0x95,0xff,0xea,0xc2,0x95,0xff,0xea,0xc2,0x95,0xff,0xea,0xc2,0x95,0xff,0xea,0xc2,0x95,0xff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe5,0xbb,0x8e,0xff,0xe5,0xbb,0x8e,0xff,0xe5,0xbb,0x8e,0xff,0xe5,0xbb,0x8e,0xff,0xe5,0xbb,0x8e,0xff,0xe5,0xbb,0x8e,0xff,0xe5,0xbb,0x8e,0xff,0xe5,0xbb,0x8e,0xff,0xe5,0xbb,0x8e,0xff,0xe5,0xbb,0x8e,0xff,0xe5,0xbb,0x8e,0xff,0xe5,0xbb,0x8e,0xff,0xe5,0xbb,0x8e,0xff,0xe5,0xbb,0x8e,0xff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe1,0xb6,0x87,0xff,0xe1,0xb6,0x87,0xff,0xe1,0xb6,0x87,0xff,0xe1,0xb6,0x87,0xff,0xe1,0xb6,0x87,0xff,0xe1,0xb6,0x87,0xff,0xe1,0xb6,0x87,0xff,0xe1,0xb6,0x87,0xff,0xe1,0xb6,0x87,0xff,0xe1,0xb6,0x87,0xff,0xe1,0xb6,0x87,0xff,0xe1,0xb6,0x87,0xff,0xe1,0xb6,0x87,0xff,0xe1,0xb6,0x87,0xff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xdc,0xb0,0x7f,0xff,0xdc,0xb0,0x7f,0xff,0xdc,0xb0,0x7f,0xff,0xdc,0xb0,0x7f,0xff,0xdc,0xb0,0x7f,0xff,0xdc,0xb0,0x7f,0xff,0xdc,0xb0,0x7f,0xff,0xdc,0xb0,0x7f,0xff,0xdc,0xb0,0x7f,0xff,0xdc,0xb0,0x7f,0xff,0xdc,0xb0,0x7f,0xff,0xdc,0xb0,0x7f,0xff,0xdc,0xb0,0x7f,0xff,0xdc,0xb0,0x7f,0xff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xd8,0xa9,0x78,0xff,0xd8,0xa9,0x78,0xff,0xd8,0xa9,0x78,0xff,0xd8,0xa9,0x78,0xff,0xd8,0xa9,0x78,0xff,0xd8,0xa9,0x78,0xff,0xd8,0xa9,0x78,0xff,0xd8,0xa9,0x78,0xff,0xd8,0xa9,0x78,0xff,0xd8,0xa9,0x78,0xff,0xd8,0xa9,0x78,0xff,0xd8,0xa9,0x78,0xff,0xd8,0xa9,0x78,0xff,0xd8,0xa9,0x78,0xff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xd3,0xa3,0x71,0xff,0xd3,0xa3,0x71,0xff,0xd3,0xa3,0x71,0xff,0xd3,0xa3,0x71,0xff,0xd3,0xa3,0x71,0xff,0xd3,0xa3,0x71,0xff,0xd3,0xa3,0x71,0xff,0xd3,0xa3,0x71,0xff,0xd3,0xa3,0x71,0xff,0xd3,0xa3,0x71,0xff,0xd3,0xa3,0x71,0xff,0xd3,0xa3,0x71,0xff,0xd3,0xa3,0x71,0xff,0xd3,0xa3,0x71,0xff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc9,0x96,0x64,0xe7,0xca,0x97,0x65,0xff,0xca,0x97,0x65,0xff,0xca,0x97,0x65,0xff,0xca,0x97,0x65,0xff,0xca,0x97,0x65,0xff,0xca,0x97,0x65,0xff,0xca,0x97,0x65,0xff,0xca,0x97,0x65,0xff,0xca,0x97,0x65,0xff,0xca,0x97,0x65,0xff,0xca,0x97,0x65,0xff,0xca,0x97,0x65,0xff,0xc9,0x97,0x64,0xf1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0};
unsigned char Tab::rawFile[]={0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc8,0xc8,0xc8,0x4c,0xe0,0xe0,0xe0,0xcd,0xe1,0xe1,0xe1,0xc0,0xe1,0xe1,0xe1,0xbf,0xe1,0xe1,0xe1,0xbf,0xe1,0xe1,0xe1,0xbf,0xe1,0xe1,0xe1,0xc0,0xd6,0xd6,0xd6,0xc4,0xbd,0xbd,0xbd,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc5,0xc5,0xc5,0x70,0xec,0xec,0xec,0xff,0xed,0xed,0xed,0xff,0xed,0xed,0xed,0xff,0xed,0xed,0xed,0xff,0xed,0xed,0xed,0xff,0xee,0xee,0xee,0xff,0xeb,0xeb,0xeb,0xff,0xce,0xce,0xce,0xff,0xbd,0xbd,0xbd,0xa6,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xbe,0xbe,0xbe,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc5,0xc5,0xc5,0x6c,0xec,0xec,0xec,0xff,0xed,0xed,0xed,0xff,0xed,0xed,0xed,0xff,0xed,0xed,0xed,0xff,0xed,0xed,0xed,0xff,0xed,0xed,0xed,0xff,0xef,0xef,0xef,0xff,0xd3,0xd3,0xd3,0xfd,0xe1,0xe1,0xe1,0xff,0xde,0xde,0xde,0xae,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc8,0xc8,0xc8,0x6c,0xee,0xee,0xee,0xff,0xef,0xef,0xef,0xff,0xef,0xef,0xef,0xff,0xef,0xef,0xef,0xff,0xef,0xef,0xef,0xff,0xef,0xef,0xef,0xff,0xf0,0xf0,0xf0,0xff,0xdb,0xdb,0xdb,0xff,0xc0,0xc0,0xc0,0xfe,0xc9,0xc9,0xc9,0xff,0xb9,0xb9,0xb9,0xbd,0x0,0x0,0x0,0x0,0xff,0xff,0xff,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc9,0xc9,0xc9,0x6b,0xf0,0xf0,0xf0,0xff,0xf1,0xf1,0xf1,0xff,0xf1,0xf1,0xf1,0xff,0xf1,0xf1,0xf1,0xff,0xf1,0xf1,0xf1,0xff,0xf1,0xf1,0xf1,0xff,0xf1,0xf1,0xf1,0xff,0xe7,0xe7,0xe7,0xff,0xc3,0xc3,0xc3,0xff,0xb6,0xb6,0xb6,0xfc,0xc2,0xc2,0xc2,0xff,0xbd,0xbd,0xbd,0x95,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xcb,0xcb,0xcb,0x6b,0xf2,0xf2,0xf2,0xff,0xf3,0xf3,0xf3,0xff,0xf3,0xf3,0xf3,0xff,0xf3,0xf3,0xf3,0xff,0xf3,0xf3,0xf3,0xff,0xf3,0xf3,0xf3,0xff,0xf3,0xf3,0xf3,0xff,0xf2,0xf2,0xf2,0xff,0xf2,0xf2,0xf2,0xff,0xf4,0xf4,0xf4,0xff,0xf2,0xf2,0xf2,0xff,0xd5,0xd5,0xd5,0xc0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xcd,0xcd,0xcd,0x6b,0xf4,0xf4,0xf4,0xff,0xf5,0xf5,0xf5,0xff,0xf5,0xf5,0xf5,0xff,0xf5,0xf5,0xf5,0xff,0xf5,0xf5,0xf5,0xff,0xf5,0xf5,0xf5,0xff,0xf5,0xf5,0xf5,0xff,0xf5,0xf5,0xf5,0xff,0xf6,0xf6,0xf6,0xff,0xf6,0xf6,0xf6,0xff,0xf8,0xf8,0xf8,0xff,0xe4,0xe4,0xe4,0xbc,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xcf,0xcf,0xcf,0x6b,0xf6,0xf6,0xf6,0xff,0xf7,0xf7,0xf7,0xff,0xf7,0xf7,0xf7,0xff,0xf7,0xf7,0xf7,0xff,0xf7,0xf7,0xf7,0xff,0xf7,0xf7,0xf7,0xff,0xf7,0xf7,0xf7,0xff,0xf7,0xf7,0xf7,0xff,0xf7,0xf7,0xf7,0xff,0xf7,0xf7,0xf7,0xff,0xf9,0xf9,0xf9,0xff,0xe5,0xe5,0xe5,0xbc,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xd0,0xd0,0xd0,0x6b,0xf8,0xf8,0xf8,0xff,0xf9,0xf9,0xf9,0xff,0xf9,0xf9,0xf9,0xff,0xf9,0xf9,0xf9,0xff,0xf9,0xf9,0xf9,0xff,0xf9,0xf9,0xf9,0xff,0xf9,0xf9,0xf9,0xff,0xf9,0xf9,0xf9,0xff,0xf9,0xf9,0xf9,0xff,0xf9,0xf9,0xf9,0xff,0xfb,0xfb,0xfb,0xff,0xe8,0xe8,0xe8,0xbc,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xd2,0xd2,0xd2,0x6b,0xf9,0xf9,0xf9,0xff,0xfa,0xfa,0xfa,0xff,0xfa,0xfa,0xfa,0xff,0xfa,0xfa,0xfa,0xff,0xfa,0xfa,0xfa,0xff,0xfa,0xfa,0xfa,0xff,0xfa,0xfa,0xfa,0xff,0xfa,0xfa,0xfa,0xff,0xfa,0xfa,0xfa,0xff,0xfa,0xfa,0xfa,0xff,0xfc,0xfc,0xfc,0xff,0xe9,0xe9,0xe9,0xbb,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xd3,0xd3,0xd3,0x6b,0xfb,0xfb,0xfb,0xff,0xfc,0xfc,0xfc,0xff,0xfc,0xfc,0xfc,0xff,0xfc,0xfc,0xfc,0xff,0xfc,0xfc,0xfc,0xff,0xfc,0xfc,0xfc,0xff,0xfc,0xfc,0xfc,0xff,0xfc,0xfc,0xfc,0xff,0xfc,0xfc,0xfc,0xff,0xfc,0xfc,0xfc,0xff,0xfe,0xfe,0xfe,0xff,0xeb,0xeb,0xeb,0xbb,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xd4,0xd4,0xd4,0x6b,0xfc,0xfc,0xfc,0xff,0xfd,0xfd,0xfd,0xff,0xfd,0xfd,0xfd,0xff,0xfd,0xfd,0xfd,0xff,0xfd,0xfd,0xfd,0xff,0xfd,0xfd,0xfd,0xff,0xfd,0xfd,0xfd,0xff,0xfd,0xfd,0xfd,0xff,0xfd,0xfd,0xfd,0xff,0xfd,0xfd,0xfd,0xff,0xff,0xff,0xff,0xff,0xec,0xec,0xec,0xbb,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xd4,0xd4,0xd4,0x6b,0xfd,0xfd,0xfd,0xff,0xfe,0xfe,0xfe,0xff,0xfe,0xfe,0xfe,0xff,0xfe,0xfe,0xfe,0xff,0xfe,0xfe,0xfe,0xff,0xfe,0xfe,0xfe,0xff,0xfe,0xfe,0xfe,0xff,0xfe,0xfe,0xfe,0xff,0xfe,0xfe,0xfe,0xff,0xfe,0xfe,0xfe,0xff,0xff,0xff,0xff,0xff,0xec,0xec,0xec,0xbb,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xd5,0xd5,0xd5,0x6a,0xfd,0xfd,0xfd,0xff,0xfe,0xfe,0xfe,0xff,0xfe,0xfe,0xfe,0xff,0xfe,0xfe,0xfe,0xff,0xfe,0xfe,0xfe,0xff,0xfe,0xfe,0xfe,0xff,0xfe,0xfe,0xfe,0xff,0xfe,0xfe,0xfe,0xff,0xfe,0xfe,0xfe,0xff,0xfe,0xfe,0xfe,0xff,0xff,0xff,0xff,0xff,0xed,0xed,0xed,0xbb,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xdb,0xdb,0xdb,0x70,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf1,0xf1,0xf1,0xc5,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa4,0xa4,0xa4,0x41,0xbc,0xbc,0xbc,0xab,0xbb,0xbb,0xbb,0xa2,0xbb,0xbb,0xbb,0xa1,0xbb,0xbb,0xbb,0xa1,0xbb,0xbb,0xbb,0xa1,0xbb,0xbb,0xbb,0xa1,0xbb,0xbb,0xbb,0xa1,0xbb,0xbb,0xbb,0xa1,0xbb,0xbb,0xbb,0xa2,0xbb,0xbb,0xbb,0xa2,0xbd,0xbd,0xbd,0xaa,0xb4,0xb4,0xb4,0x73,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x4,0x0,0x0,0x0,0x5,0x0,0x0,0x0,0x5,0x0,0x0,0x0,0x5,0x0,0x0,0x0,0x5,0x0,0x0,0x0,0x5,0x0,0x0,0x0,0x5,0x0,0x0,0x0,0x5,0x0,0x0,0x0,0x5,0x0,0x0,0x0,0x5,0x0,0x0,0x0,0x5,0x0,0x0,0x0,0x5,0x0,0x0,0x0,0x5,0x0,0x0,0x0,0x4,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0};

GuiRect* Tab::focusedGlobal=0;

Tab::Tab(float x,float y,float w,float h):
tabs(this),
	windowData(0),
	parentWindowContainer(0),
	selected(0),
	mouseDown(false),
	isRender(false),
	splitterContainer(0),
	renderer3D(0),
	renderer2D(0),
	recreateTarget(true),
	resizeTarget(true),
	lastFrameTime(0),
	iconUp(0),
	iconRight(0),
	iconDown(0),
	iconFolder(0),
	iconFile(0),
	threadRender(0),
	focused(0)
{}

Tab::~Tab()
{
	printf("deleting TabContainer %p\n",this);
}

GuiRect* Tab::GetSelected()
{
	return selected<tabs.childs.size() ? tabs.childs[selected] : 0;
}

void Tab::Draw()
{
	if(this->taskDraw->pause)
		DEBUG_BREAK();

	if(!this->drawInstances.empty())
	{
		DrawInstance*& tDrawInstance=this->drawInstances.front();

		if(!tDrawInstance)
			DEBUG_BREAK();

		if(tDrawInstance->code || tDrawInstance->frame)
		{
			if(this->BeginDraw())
			{
				if(tDrawInstance->frame)
					this->DrawFrame();

				switch(tDrawInstance->code)
				{
				case 1:this->OnGuiPaint();break;
				case 2:tDrawInstance->rect->OnPaint(this);break;
				}

				this->EndDraw();
			}
		}

		if(tDrawInstance->remove)
		{
			SAFEDELETE(tDrawInstance);
			this->drawInstances.pop_front();
		}
	}
	else
	{
		if(Timer::instance->GetTime()-this->lastFrameTime>(1000.0f/Timer::instance->renderFps))
		{
			this->lastFrameTime=Timer::instance->GetTime();
			this->renderer3D->Render();
		}
		
		this->renderer2D->caret->draw();
	}
}

DrawInstance* Tab::SetDraw(int iNoneAllRect,bool iFrame,GuiRect* iRect,const char* iName,bool iRemove)
{
	DrawInstance* newInstance=new DrawInstance(iNoneAllRect,iFrame,iRect,iName,iRemove);
	this->drawInstances.push_back(newInstance);
	return newInstance;
}

void Tab::BroadcastToSelected(void (GuiRect::*func)(Tab*,void*),void* data)
{
	GuiRect* selectedTab=this->GetSelected();

	if(selectedTab)
		(selectedTab->*func)(this,data);
}

void Tab::BroadcastToAll(void (GuiRect::*func)(Tab*,void*),void* data)
{
	(this->tabs.*func)(this,data);
}


template<class C> void Tab::BroadcastToSelected(void (GuiRect::*func)(Tab*,void*),void* data)
{
	GuiRect* selectedTab=this->GetSelected();

	if(selectedTab)
		selectedTab->BroadcastTo<C>(func,data);
}

template<class C> void Tab::BroadcastToAll(void (GuiRect::*func)(Tab*,void*),void* data)
{
	this->tabs.BroadcastTo<C>(func,data);
}


void Tab::SetSelection(GuiRect* iRect)
{
	this->BroadcastToSelected(&GuiRect::OnDeactivate);

	for(size_t i=0;i<this->tabs.childs.size();i++)
	{
		if(iRect==this->tabs.childs[i])
		{
			this->selected=i;
			break;
		}
	}

	this->BroadcastToSelected(&GuiRect::OnActivate);
	this->BroadcastToSelected(&GuiRect::OnSize);

	this->SetDraw();
}


void Tab::OnGuiSize(void* data)
{
	this->windowData->OnSize();

	this->tabs.rect.make(0.0f,(float)Tab::CONTAINER_HEIGHT,this->windowData->width,this->windowData->height-Tab::CONTAINER_HEIGHT);

	this->BroadcastToSelected(&GuiRect::OnSize,data);

	this->resizeTarget=true;
	//this->OnGuiPaint();

}

void Tab::OnWindowPosChanging(void* data)
{
	this->windowData->OnWindowPosChanging();

	this->tabs.rect.make(0,Tab::CONTAINER_HEIGHT,this->windowData->width,this->windowData->height-Tab::CONTAINER_HEIGHT);

	this->BroadcastToSelected(&GuiRect::OnSize,data);
	this->resizeTarget=true;
}

void Tab::OnGuiMouseMove(void* data)
{
	splitterContainer->currentTabContainer=this;

	/*if(mouseDown && tmx!=mousex && tmy!=mousey)
		splitterContainer->CreateFloatingTab(this);

	mousex=tmx;
	mousey=tmy;*/

	//if(mousey>TabContainer::CONTAINER_HEIGHT)
	this->BroadcastToSelected(&GuiRect::OnMouseMove,vec2(this->mousex,this->mousey));
}

void Tab::OnGuiLMouseUp(void* data)
{
	mouseDown=false;

	this->BroadcastToSelected(&GuiRect::OnLMouseUp,vec2(this->mousex,this->mousey));
}

void Tab::OnGuiMouseWheel(void* data)
{

}

void Tab::OnGuiLMouseDown(void* data)
{
	//this->OnGuiMouseMove();


	float &x=this->mousex;
	float &y=this->mousey;


	if(y<=CONTAINER_HEIGHT)
	{
		int tPreviousTabSelected=selected;

		for(int i=0;i<(int)tabs.childs.size();i++)
		{
			bool tMouseContained=x>(i*TAB_WIDTH) && x< (i*TAB_WIDTH+TAB_WIDTH) && y > (CONTAINER_HEIGHT-TAB_HEIGHT) &&  y<CONTAINER_HEIGHT;

			if(tMouseContained)// && tPreviousTabSelected!=i)
			{
				
				mouseDown=true;

				this->SetSelection(tabs.childs[i]);

				break;
			}
		}
	}
	else
	{
		this->BroadcastToSelected(&GuiRect::OnLMouseDown,vec2(this->mousex,this->mousey));
	}
}

void Tab::OnGuiDLMouseDown(void* data)
{
	if(this->mousey>CONTAINER_HEIGHT)
		this->BroadcastToSelected(&GuiRect::OnDLMouseDown,vec2(this->mousex,this->mousey));
}


void Tab::OnGuiUpdate(void* data)
{
	this->BroadcastToSelected(&GuiRect::OnUpdate,data);
}

void Tab::OnGuiRMouseUp(void* data)
{
	this->BroadcastToSelected(&GuiRect::OnRMouseUp,data);
}

void Tab::OnGuiRender(void* data)
{
	this->BroadcastToSelected(&GuiRect::OnRender,data);
}

void Tab::DrawFrame()
{

}

void Tab::OnGuiPaint(void* data)
{

}

void Tab::OnResizeContainer(void* data)
{

}

void Tab::OnEntitiesChange(void* data)
{
	this->BroadcastToSelected(&GuiRect::OnEntitiesChange,data);
}
void Tab::OnGuiActivate(void* data)
{
	this->BroadcastToSelected(&GuiRect::OnActivate,data);


}
void Tab::OnGuiDeactivate(void* data)
{
	this->BroadcastToSelected(&GuiRect::OnDeactivate,data);
}
void Tab::OnGuiEntitySelected(void* data)
{
	this->BroadcastToSelected(&GuiRect::OnEntitySelected,data);
}

void Tab::OnGuiKeyDown(void* data)
{
	this->BroadcastToSelected(&GuiRect::OnKeyDown,data);
}

void Tab::OnGuiKeyUp(void* data)
{
	this->BroadcastToSelected(&GuiRect::OnKeyUp,data);
}

void Tab::OnGuiRecreateTarget(void* data)
{
	this->BroadcastToSelected(&GuiRect::OnRecreateTarget,data);
}

void Tab::SetFocus(GuiRect* iFocusedRect)
{
	if(this->GetFocus() && this->GetFocus()!=iFocusedRect)
		this->GetFocus()->OnExitFocus(this,this->GetFocus());

	this->focusedGlobal=this->focused=iFocusedRect;

	if(this->focusedGlobal)
		this->focusedGlobal->OnEnterFocus(this,this->focusedGlobal);
}

GuiRect* Tab::GetFocus()
{
	return this->focusedGlobal;
}


///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////SplitterContainer///////////////
///////////////////////////////////////////////
///////////////////////////////////////////////
Splitter::Splitter():
splitterSize(4)
{
	floatingTabRef=0;
	floatingTab=0;
	floatingTabTarget=0;
	floatingTabRefTabIdx=-1;
	floatingTabRefTabCount=-1;
	floatingTabTargetAnchorPos=-1;
	floatingTabTargetAnchorTabIndex=-1;

	splitterCursor="IDC_ARROW";
}
Splitter::~Splitter()
{
}

///////////////////////////////////////////////
///////////////////////////////////////////////
//////////////////Renderer2D///////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

Renderer2D::Caret* Renderer2D::caretGlobal=0;

Renderer2D::Renderer2D(Tab* iTabContainer):
	tabContainer(iTabContainer),
	tabSpaces(4),
	caret(0)
{}

Renderer2D::Caret::Caret(Renderer2D* iRenderer2D):
	renderer2D(iRenderer2D),
	guiRect(0),
	lastBlinkTime(0),
	blinking(false),
	enabled(false),
	blinkingRate(BLINKRATE)
{}

///////////////////////////////////////////////
///////////////////////////////////////////////
/////////////Renderer3DInterface///////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

Renderer3D::Renderer3D(Tab* iTabContainer):
	tabContainer(iTabContainer)
{

}

bool Renderer3D::Block()
{
	this->tabContainer->taskDraw->pause=true;

	while(this->tabContainer->taskDraw->executing);

	return true;
}
bool Renderer3D::Release()
{
	this->tabContainer->taskDraw->pause=false;
	return true;
}

void Renderer3D::Register(GuiViewport* iViewport)
{
	if(this->viewports.end()==std::find(this->viewports.begin(),this->viewports.end(),iViewport))
		this->viewports.push_back(iViewport);
}
void Renderer3D::Unregister(GuiViewport* iViewport)
{
	this->viewports.remove(iViewport);
}

Shader* Renderer3D::FindShader(const char* name,bool exact)
{
	for(size_t i=0;i<this->shaders.size();i++)
	{
		Shader* element=this->shaders[i];

		const char* programName=element->GetName();

		if(element && programName)
			if(exact ? 0==strcmp(programName,name) :  0!=strstr(programName,name))
				return this->shaders[i];
	}

	return 0;
}

void Renderer3D::SetMatrices(const float* view,const float* mdl)
{
	for(size_t i=0;i<this->shaders.size();i++)
	{
		this->shaders[i]->Use();

		if(view)
			this->shaders[i]->SetProjectionMatrix((float*)view);
		if(mdl)
			this->shaders[i]->SetModelviewMatrix((float*)mdl);
	}
}

///////////////////////////////////////////////
///////////////////////////////////////////////
////////////////////GuiRect////////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

GuiRect::GuiRect(GuiRect* iParent,float ix, float iy, float iw,float ih,vec2 _alignPos,vec2 _alignRect):
	colorBackground(Renderer2D::COLOR_GUI_BACKGROUND),
	colorForeground(Renderer2D::COLOR_TEXT),
	colorHovering(colorBackground),
	colorPressing(colorBackground),
	colorChecked(colorBackground),
	pressing(false),
	hovering(false),
	checked(false),
	active(false),
	clip(0)
{
	this->Set(iParent,0,0,-1,ix,iy,iw,ih,_alignPos.x,_alignPos.y,_alignRect.x,_alignRect.y);

	for(size_t i=0;i<4;i++)
		this->sibling[i]=0;
}

GuiRect::~GuiRect()
{
	
}

void GuiRect::SetParent(GuiRect* iParent)
{
	GuiRect* oldParent=this->parent;
	this->parent=iParent;

	if(oldParent)
		oldParent->childs.erase(std::find(oldParent->childs.begin(),oldParent->childs.end(),this));

	if(this->parent)
	{
		this->parent->childs.push_back(this);

		if(this->parent->clip)
			this->SetClip(this->parent->clip);
	}

	this->active=iParent ? iParent->active : 0;
}

void GuiRect::Set(GuiRect* iParent,GuiRect* iSibling,int iSiblingIdx,int iContainer,float iX, float iY, float iW,float iH,float iAlignPosX,float iAlignPosY,float iAlignRectX,float iAlignRectY)
{
	this->sibling[iSiblingIdx]=iSibling;
	this->container=iContainer;
	this->fixed.make(iX,iY,iW,iH);
	this->rect.make(iX,iY,iW,iH);
	this->alignPos.make(iAlignPosX,iAlignPosY);
	this->alignRect.make(iAlignRectX,iAlignRectY);
	this->SetParent(iParent);
}

bool GuiRect::_contains(vec4& quad,vec2 point)
{
	return (point.x>quad.x && point.x<(quad.x+quad.z) && point.y>quad.y && point.y<(quad.y+quad.w));
}
	
void GuiRect::BroadcastToChilds(void (GuiRect::*func)(Tab*,void*),Tab* tabContainer,void* data)
{
	for(std::vector<GuiRect*>::iterator tRect=this->childs.begin();tRect!=this->childs.end();tRect++)
		((*tRect)->*func)(tabContainer,data);
}

void GuiRect::BroadcastToRoot(void (GuiRect::*func)(Tab*,void*),void* data)
{
	GuiRootRect* root=dynamic_cast<GuiRootRect*>(this->GetRoot());

	if(root)
		(root->*func)(root->tabContainer,data);
}




void GuiRect::OnEntitiesChange(Tab* tabContainer,void* data)
{
	this->BroadcastToChilds(&GuiRect::OnEntitiesChange,tabContainer,data);
}

void GuiRect::DrawBackground(Tab* tabContainer)
{
	unsigned int tCurrentColor=this->pressing ? this->colorPressing : (this->hovering ? this->colorHovering : this->colorBackground);

	tabContainer->renderer2D->DrawRectangle(this->rect.x,this->rect.y,this->rect.x+this->rect.z,this->rect.y+this->rect.w,tCurrentColor);
}


void GuiRect::OnPaint(Tab* tabContainer,void* data)
{
	bool selfClip=this->BeginSelfClip(tabContainer);

	this->DrawBackground(tabContainer);

	if(this->container!=0)
		this->BroadcastToChilds(&GuiRect::OnPaint,tabContainer,data);

	this->EndSelfClip(tabContainer,selfClip);
}


void GuiRect::OnSize(Tab* tabContainer,void* data)
{
	if(parent)
	{
		vec4 &pRect=this->parent->rect;

		this->rect=this->fixed;

		this->rect.z = (this->alignRect.x>=0 ? this->alignRect.x * pRect.z : this->rect.z);
		this->rect.w = (this->alignRect.y>=0 ? this->alignRect.y * pRect.w : this->rect.w);

		if(this->alignPos.x>=0)
			this->rect.x=(pRect.x+this->alignPos.x*pRect.z);
		if(this->alignPos.y>=0)
			this->rect.y=(pRect.y+this->alignPos.y*pRect.w);

		if(parent->container>=0)
		{
			this->rect.x+=20;
			this->rect.z-=20;
		}

		this->rect.x = (pRect.x > this->rect.x ? pRect.x : (pRect.x+pRect.z < this->rect.x+this->rect.z ? this->rect.x - (this->rect.x+this->rect.z - (pRect.x+pRect.z)) : this->rect.x));
		this->rect.y = (pRect.y > this->rect.y ? pRect.y : (pRect.y+pRect.w < this->rect.y+this->rect.w ? this->rect.y - (this->rect.y+this->rect.w - (pRect.y+pRect.w)) : this->rect.y));

		this->rect.x+=this->offset.x;
		this->rect.z-=this->offset.x;

		if(parent->container>=0)
		{
			this->rect.y+=20;
		}
	}
	
	if(sibling[0])
	{
		this->rect.x=this->sibling[0]->rect.x+this->sibling[0]->rect.z;
	}
	else if(this->sibling[1])
	{
		this->rect.y=this->sibling[1]->rect.y+this->sibling[1]->rect.w;
	}
	else if(sibling[2])
	{
		this->rect.x=this->sibling[2]->rect.x-this->rect.z;
	}
	else if(sibling[3])
	{
		this->rect.y=this->sibling[3]->rect.y-this->rect.w;
	}

	if(this->container!=0)
		this->BroadcastToChilds(&GuiRect::OnSize,tabContainer,data);

	if(container==0)
	{
		this->rect.w=20;
	}
	else if(container==1)
		this->rect.w=20;//calc on childs


	if(this->container==1 && !this->childs.empty())
	{
		GuiRect* te=this->childs.back();

		this->rect.w=te->rect.y+te->rect.w-this->rect.y;
	}
}

void GuiRect::OnLMouseDown(Tab* tabContainer,void* data)
{
	vec2 mpos=*(vec2*)data;

	mpos.y=!this->clip ? mpos.y : mpos.y+this->clip->scrollBar->scrollerPosition*this->clip->contentHeight;

	bool wasPressing=this->pressing;
	bool bContainerButtonPressed=0;

	this->pressing=this->hovering;

	if(this->hovering)
	{
		this->checked=!this->checked;

		tabContainer->SetFocus(this);

		if(this->container>=0)
		{
			bContainerButtonPressed=(mpos.x > this->rect.x && mpos.x < this->rect.x+Tab::CONTAINER_ICON_WH && mpos.y > this->rect.y && mpos.y <this->rect.y+Tab::CONTAINER_ICON_WH);

			if(bContainerButtonPressed)
				this->container=!this->container;
		}

		if(bContainerButtonPressed)
		{
			tabContainer->BroadcastToSelected(&GuiRect::OnSize);
			this->OnExpandos(tabContainer,this);
			tabContainer->SetDraw(1,false);
		}

		if(wasPressing!=this->pressing && this->colorPressing!=this->colorBackground)
			tabContainer->SetDraw(2,0,this);
	}
	if(this->container!=0)
		this->BroadcastToChilds(&GuiRect::OnLMouseDown,tabContainer,data);

	if(wasPressing!=this->pressing && this->colorPressing!=this->colorBackground)
		tabContainer->SetDraw(2,0,this);
}

void GuiRect::OnDLMouseDown(Tab* tabContainer,void* data)
{
	if(this->container!=0)
		this->BroadcastToChilds(&GuiRect::OnDLMouseDown,tabContainer,data);
}

void GuiRect::OnLMouseUp(Tab* tabContainer,void* data)
{
	bool wasPressing=this->pressing;

	this->pressing = false;

	if(this->container!=0)
		this->BroadcastToChilds(&GuiRect::OnLMouseUp,tabContainer,data);

	if(wasPressing!=this->pressing && this->colorPressing!=this->colorBackground)
		tabContainer->SetDraw(2,0,this);
}

void GuiRect::OnRMouseUp(Tab* tabContainer,void* data)
{
	if(this->container!=0)
		this->BroadcastToChilds(&GuiRect::OnRMouseUp,tabContainer,data);
}


void GuiRect::OnMouseMove(Tab* tabContainer,void* data)
{
	vec2 mpos=*(vec2*)data;

	mpos.y=!this->clip ? mpos.y : mpos.y+this->clip->scrollBar->scrollerPosition*this->clip->contentHeight;

	bool _oldHover=this->hovering;
	bool _curHover=_contains(this->rect,mpos);

	if(parent && _curHover)
		parent->hovering=false;
	
	this->hovering=_curHover;

	if(/*_curHover && */this->container!=0)
		this->BroadcastToChilds(&GuiRect::OnMouseMove,tabContainer,data);

	if(_oldHover!=this->hovering && this->colorBackground!=this->colorHovering)
		tabContainer->SetDraw(2,0,this);
}

void GuiRect::OnUpdate(Tab* tabContainer,void* data)
{
	this->BroadcastToChilds(&GuiRect::OnUpdate,tabContainer,data);
}

void GuiRect::OnReparent(Tab* tabContainer,void* data)
{
	this->BroadcastToChilds(&GuiRect::OnReparent,tabContainer,data);
}
void GuiRect::OnSelected(Tab* tabContainer,void* data)
{
	this->BroadcastToChilds(&GuiRect::OnSelected,tabContainer,data);
}
void GuiRect::OnRender(Tab* tabContainer,void* data)
{
	this->BroadcastToChilds(&GuiRect::OnRender,tabContainer);
}
void GuiRect::OnMouseWheel(Tab* tabContainer,void* data)
{
	if(this->clip && this->_contains(this->rect,vec2(tabContainer->mousex,tabContainer->mousey)))
	{
		this->clip->scrollBar->Scroll(tabContainer,*(float*)data);
		//tabContainer->SetDraw(2,0,this->clip->parent);
	}

	this->BroadcastToChilds(&GuiRect::OnMouseWheel,tabContainer,data);
}
void GuiRect::OnActivate(Tab* tabContainer,void* data)
{
	this->active=true;
	this->BroadcastToChilds(&GuiRect::OnActivate,tabContainer);
}
void GuiRect::OnDeactivate(Tab* tabContainer,void* data)
{
	this->active=false;
	this->BroadcastToChilds(&GuiRect::OnDeactivate,tabContainer,data);
}
void GuiRect::OnEntitySelected(Tab* tabContainer,void* data)
{
	this->BroadcastToChilds(&GuiRect::OnEntitySelected,tabContainer,data);
}

void GuiRect::OnExpandos(Tab* tabContainer,void* data)
{
	if(this->parent)
		this->parent->OnExpandos(tabContainer,data);
}

void GuiRect::OnKeyDown(Tab* tabContainer,void* data)
{
	this->BroadcastToChilds(&GuiRect::OnKeyDown,tabContainer,data);
}

void GuiRect::OnKeyUp(Tab* tabContainer,void* data)
{
	this->BroadcastToChilds(&GuiRect::OnKeyDown,tabContainer,data);
}

void GuiRect::OnMouseEnter(Tab* tabContainer,void* data)
{
	this->BroadcastToChilds(&GuiRect::OnMouseEnter,tabContainer,data);
}
void GuiRect::OnMouseExit(Tab* tabContainer,void* data)
{
	this->BroadcastToChilds(&GuiRect::OnMouseExit,tabContainer,data);
}

void GuiRect::OnEnterFocus(Tab* tabContainer,void* data)
{
	this->BroadcastToChilds(&GuiRect::OnEnterFocus,tabContainer,data);
}

void GuiRect::OnExitFocus(Tab* tabContainer,void* data)
{
	this->BroadcastToChilds(&GuiRect::OnExitFocus,tabContainer,data);
}

void GuiRect::SetClip(GuiScrollRect* scrollRect)
{
	this->clip=scrollRect;

	for(std::vector<GuiRect*>::iterator tRect=this->childs.begin();tRect!=this->childs.end();tRect++)
		(*tRect)->SetClip(scrollRect);
}



void GuiRect::SelfRenderEnd(Tab* tabContainer,bool& isSelfRender)
{
	if(isSelfRender)
		tabContainer->EndDraw();
}

bool GuiRect::BeginSelfClip(Tab* tabContainer)
{
	bool clipped=false;

	if(this->clip && !this->clip->isClipped)
	{
		tabContainer->renderer2D->PushScissor(this->clip->rect.x,this->clip->rect.y,this->clip->rect.x+this->clip->width,this->clip->rect.y+this->clip->rect.w);
		tabContainer->renderer2D->Translate(0,-this->clip->scrollBar->scrollerPosition*this->clip->contentHeight);

		clipped=this->clip->isClipped=true;
	}
		
	return clipped;
}

void GuiRect::EndSelfClip(Tab* tabContainer,bool& isSelfClip)
{
	if(isSelfClip)
	{
		tabContainer->renderer2D->Identity();
		tabContainer->renderer2D->PopScissor();
		this->clip->isClipped=false;
	}
}



GuiRect* GuiRect::GetRoot()
{
	return this->parent ? this->parent->GetRoot() : this;
}

GuiRootRect* GuiRect::GetRootRect()
{
	return (GuiRootRect*)this->GetRoot();
}


GuiRect* GuiRect::Rect(float ix, float iy, float iw,float ih,float apx, float apy, float arx,float ary)
{
	return new GuiRect(this,ix,iy,iw,ih,vec2(apx,apy),vec2(arx,ary));
}


GuiString* GuiRect::Text(String str,float ix, float iy, float iw,float ih,vec2 _alignText)
{
	GuiString* label=new GuiString;
	label->parent=this;
	label->rect.make(ix,iy,iw,ih);
	label->alignText=_alignText;
	label->text=str.Buffer();
	this->childs.push_back(label);
	return label;
}

GuiString* GuiRect::Text(String str,vec2 _alignPos,vec2 _alignRect,vec2 _alignText)
{
	GuiString* label=new GuiString;
	label->parent=this;
	label->alignPos=_alignPos;
	label->alignRect=_alignRect;
	label->alignText=_alignText;
	label->text=str.Buffer();
	this->childs.push_back(label);
	return label;
}


GuiString* GuiRect::Container(const char* iText)
{
	GuiString* s=new GuiString;
	s->name="GuiContainer";
	s->Set(this,((int)this->childs.size()) ? this->childs.back() : 0,1,0,0,0,0,20,0,0,1,-1);
	s->text=iText;
	s->alignText.make(1,-1);

	return s;
}


GuiPropertyString* GuiRect::Property(const char* iDescription,void* iValuePointer1,unsigned int iValueType,void* iValuePointer2,unsigned int iValueParameter1,unsigned int iValueParameter2)
{
	GuiPropertyString* p=new GuiPropertyString(iDescription,iValuePointer1,iValueType,iValuePointer2,iValueParameter1,iValueParameter2);
	this->AppendChild(p);
	return p;
}



GuiPropertySlider* GuiRect::SliderProperty(const char* iDescription,float& ref,float& imin,float& imax)
{
	GuiPropertySlider* s=new GuiPropertySlider(iDescription,ref,imin,imax);
	this->AppendChild(s);
	return s;
}


GuiPropertyAnimationController* GuiRect::AnimationControllerProperty(AnimationController& ac)
{
	GuiPropertyAnimationController* a=new GuiPropertyAnimationController(ac);
	this->AppendChild(a);
	return a;
}

GuiViewport* GuiRect::Viewport(vec3 pos,vec3 target,vec3 up,bool perspective)
{
	GuiViewport* v=new GuiViewport;
	v->Set(this,0,0,-1,0,0,0,0,0,0,1,1);
	v->projection= !perspective ? v->projection : v->projection.perspective(90,16/9,1,1000);
	v->view.move(pos);
	v->view.lookat(target,up);
	return v;
}

GuiSceneViewer* GuiRect::SceneViewer()
{
	GuiSceneViewer* sv=new GuiSceneViewer;
	sv->Set(this,0,0,-1,0,0,0,0,0,0,1,1);
	return sv;
}

GuiEntityViewer* GuiRect::EntityViewer()
{
	GuiEntityViewer* sv=new GuiEntityViewer;
	sv->Set(this,0,0,-1,0,0,0,0,0,0,1,1);
	return sv;
}
GuiProjectViewer* GuiRect::ProjectViewer()
{
	GuiProjectViewer* sv=new GuiProjectViewer;
	sv->Set(this,0,0,-1,0,0,0,0,0,0,1,1);
	return sv;
}

GuiScriptViewer* GuiRect::ScriptViewer()
{
	GuiScriptViewer* sv=new GuiScriptViewer();
	sv->Set(this,0,0,-1,0,0,0,0,0,0,1,1);
	return sv;
}

GuiCompilerViewer* GuiRect::CompilerViewer()
{
	GuiCompilerViewer* sv=new GuiCompilerViewer();
	sv->Set(this,0,0,-1,0,0,0,0,0,0,1,1);
	return sv;
}

void GuiRect::AppendChild(GuiRect* iRect)
{
	iRect->sibling[1]=!this->childs.empty() ? this->childs.back() : 0;
	iRect->SetParent(this);
}

void GuiRect::DestroyChilds()
{
	for(size_t i=0;i<this->childs.size();i++)
	{
		this->childs[i]->DestroyChilds();
		SAFEDELETE(this->childs[i]);
	}

	this->childs.clear();
}

template<class GuiRectDerived> GuiRectDerived* GuiRect::Create(int sibIdx,int container,float ix, float iy, float iw,float ih,float iAlignPosX,float iAlignPosY,float iAlignRectX,float iAlignRectY)
{
	GuiRectDerived* guirectderived=new GuiRectDerived;

	if(!guirectderived)
		DEBUG_BREAK();

	guirectderived->Set(this,sibIdx>=0 ? this : 0,sibIdx<0 ? 0 : sibIdx,container,ix,iy,iw,ih,iAlignPosX,iAlignPosY,iAlignRectX,iAlignRectY);

	return guirectderived;
}

///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////EditorProperties////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

EditorProperties::EditorProperties()
{
	this->properties.name="EditorProperties";
	this->properties.Set(0,0,0,0,0,0,0,20,0,0,1,-1);
}

///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////////EditorEntity////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

EditorEntity::EditorEntity():
	selected(false),
	expanded(false),
	level(0)
{
	this->properties.Set(0,0,0,-1,0,0,0,0,0,0,1,1);
}

void EditorEntity::SetParent(Entity* iParent)
{
	Entity::SetParent(iParent);

	this->SetLevel(this);
}

void EditorEntity::SetLevel(EditorEntity* iEntity)
{
	EditorEntity* eeParent=(EditorEntity*)iEntity->parent;

	iEntity->level=eeParent ? eeParent->level+1 : iEntity->level;
	iEntity->expanded=!iEntity->level ? true : false;

	for(std::list<Entity*>::iterator i=iEntity->childs.begin();i!=iEntity->childs.end();i++)
		((EditorEntity*)*i)->SetLevel((EditorEntity*)*i);
}

///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////////GuiRootRect/////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

GuiRootRect::GuiRootRect(Tab* t):tabContainer(t)
{
	this->name="RootRect";
	this->Set(0,0,0,-1,0,0,0,0,0,0,1,1);
}

void GuiRootRect::OnSize(Tab* tab)
{
	this->rect.make(0,Tab::CONTAINER_HEIGHT,tabContainer->windowData->width,tabContainer->windowData->height-Tab::CONTAINER_HEIGHT);

	if(this->container!=0)
		this->BroadcastToChilds(&GuiRect::OnSize,tab);
}

///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////////GuiString///////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

GuiString::GuiString():alignText(-1,-1),clipText(true){this->name="String";}

void GuiString::DrawTheText(Tab* tabContainer,vec2 iOffset)
{
	if(!this->text.empty() || !this->wText.empty())
	{
		int x=this->rect.x;
		int y=this->rect.y;
		int w;
		int h;

		vec2 tAlign(this->alignText.x,this->alignText.y);

		if(this->container>=0)
		{
			tabContainer->renderer2D->DrawBitmap(this->container==1 ? tabContainer->iconDown : tabContainer->iconRight,x,y,x+Tab::CONTAINER_ICON_WH,y+Tab::CONTAINER_ICON_WH);

			x+=TREEVIEW_ROW_ADVANCE,
				w=x+this->rect.z,
				h=y+Tab::CONTAINER_ICON_WH;

			tAlign.make(-1.0f,0.5f);
		}
		else
		{
			x=this->rect.x + iOffset.x,
				y=this->rect.y + iOffset.y,
				w=x+this->rect.z - iOffset.x,
				h=y+this->rect.w - iOffset.y;
		}

		if(!this->text.empty())
			tabContainer->renderer2D->DrawText(this->text.c_str(),x,y,w,h,Renderer2D::COLOR_TEXT,tAlign.x,tAlign.y,this->clipText);

		if(!this->wText.empty())
			tabContainer->renderer2D->DrawText(this->wText.c_str(),x,y,w,h,Renderer2D::COLOR_TEXT,tAlign.x,tAlign.y,this->clipText);
	}
}

void GuiString::OnPaint(Tab* tabContainer,void* data)
{
	bool selfClip=this->BeginSelfClip(tabContainer);

	this->DrawBackground(tabContainer);

	this->DrawTheText(tabContainer);

	if(this->container!=0)
		this->BroadcastToChilds(&GuiRect::OnPaint,tabContainer,data);

	this->EndSelfClip(tabContainer,selfClip);	
}

///////////////////////////////////////////////
///////////////////////////////////////////////
////////////////GuiButtonFunc//////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

GuiButtonFunc::GuiButtonFunc(void (*iFunc)(void*),void* iParam):func(iFunc),param(iParam){}

void GuiButtonFunc::OnLMouseUp(Tab* tab,void* data)
{
	GuiString::OnLMouseUp(tab);

	if(this->hovering)
	{
		if(this->func)
			this->func(this->param);
	}
}

///////////////////////////////////////////////
///////////////////////////////////////////////
////////////////////GuiButton//////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

GuiButton::GuiButton()
{
	alignText.make(0.5f,0.5f);
}
void GuiButton::OnLMouseUp(Tab* tab,void* data)
{
	GuiString::OnLMouseUp(tab);

	if(this->hovering)
	{
		if(this->parent)
			this->parent->OnButtonPressed(tab,this);
	}
}

void GuiButton::OnPaint(Tab* tab,void* data)
{
	GuiString::OnPaint(tab);
}

///////////////////////////////////////////////
///////////////////////////////////////////////
////////////////GuiButtonBool//////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

void GuiButtonBool::OnLMouseUp(Tab* tab,void* data)
{
	GuiString::OnLMouseUp(tab);

	if(this->hovering)
	{
		switch(this->updateMode)
		{
		case -1:	referenceValue=!referenceValue; break;
		case 0:		referenceValue=false;			break;
		case 1:		referenceValue=true;			break;
		}

		if(this->parent)
			this->parent->OnButtonPressed(tab,this);
	}
}

///////////////////////////////////////////////
///////////////////////////////////////////////
////////////////GuiScrollRect//////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

GuiScrollRect::GuiScrollRect():
contentHeight(0),
width(0),
isClipped(false)
{
	this->scrollBar=new GuiScrollBar;
	this->scrollBar->guiRect=this;
	this->scrollBar->Set(this,0,0,-1,0,0,20,0,1,0,-1,1);
}

GuiScrollRect::~GuiScrollRect()
{
	SAFEDELETE(this->scrollBar);
}

void GuiScrollRect::OnMouseWheel(Tab* tabContainer,void* data)
{
	GuiRect::OnMouseWheel(tabContainer,data);

	if(!this->hovering)
		return;

	/*float scrollValue=*(float*)data;
	this->scrollBar->Scroll(tabContainer,scrollValue);*/
}

void GuiScrollRect::OnSize(Tab* tabContainer,void* data)
{
	GuiRect::OnSize(tabContainer,data);

	this->scrollBar->SetScrollerRatio(this->contentHeight,this->rect.w);
	this->width=this->scrollBar->IsVisible()  ? this->rect.z-GuiScrollBar::SCROLLBAR_WIDTH : this->rect.z;
}


///////////////////////////////////////////////
///////////////////////////////////////////////
////////////////GuiProperty*///////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

GuiPropertyString::GuiPropertyString(const char* iDescription,void* iValuePointer1,unsigned int iValueType,void* iValuePointer2,unsigned int iValueParameter1,unsigned int iValueParameter2):
	valuePointer1(iValuePointer1),
	valuePointer2(iValuePointer2),
	valueType(iValueType),
	valueParameter1(iValueParameter1),
	valueParameter2(iValueParameter2)
{
	this->description=iDescription;

	switch(this->valueType)
	{
		default:
			this->name="PropertyString";this->Set(0,0,0,-1,0,0,0,20,0,0,1,-1);
	}
}

void GuiPropertyString::OnPaint(Tab* tabContainer,void* data)
{
	bool selfClip=this->BeginSelfClip(tabContainer);

	this->DrawBackground(tabContainer);

	if(description.Buffer())
		tabContainer->renderer2D->DrawText(description.Buffer(),this->rect.x,this->rect.y,this->rect.x+this->rect.z/2.0f,this->rect.y+this->rect.w);

	const unsigned int ctMaxTmpArraySize=256;

	/*
	enum 
	{
		STRING=0,
		BOOL,
		INT,
		FLOAT,
		VEC2,
		VEC3,
		VEC4,
		PTR,
		MAT4POS,
		ENTITYVECSIZE,
		ANIMATIONVECSIZE,
		ISBONECOMPONENT,
		FLOAT2MINUSFLOAT1,
		MAXVALUE
	};
	*/

	switch(this->valueType)
	{
		case GuiPropertyString::STRING:
		{
			String& tString=*(String*)this->valuePointer1;

			if(tString.Buffer())
				tabContainer->renderer2D->DrawText(tString.Buffer(),this->rect.x+this->rect.z/2.0f,this->rect.y,this->rect.x+this->rect.z,this->rect.y+this->rect.w);
		}
		break;
		case GuiPropertyString::BOOL:
		{
			bool& tBool=*(bool*)this->valuePointer1;
			tabContainer->renderer2D->DrawText(tBool ? "True" : "False",this->rect.x+this->rect.z/2.0f,this->rect.y,this->rect.x+this->rect.z,this->rect.y+this->rect.w);
		}
		break;
		case GuiPropertyString::INT:
		{
			int& tInt=*(int*)this->valuePointer1;

			char tCharInt[ctMaxTmpArraySize];
			sprintf(tCharInt,"%d",tInt);

			tabContainer->renderer2D->DrawText(tCharInt,this->rect.x+this->rect.z/2.0f,this->rect.y,this->rect.x+this->rect.z,this->rect.y+this->rect.w);
		}
		break;
		case GuiPropertyString::FLOAT:
		{
			float& tFloat=*(float*)this->valuePointer1;

			//https://stackoverflow.com/questions/16413609/printf-variable-number-of-decimals-in-float

			char tCharFloat[ctMaxTmpArraySize];
			sprintf(tCharFloat,"%*.*f",this->valueParameter1,this->valueParameter2,tFloat);

			tabContainer->renderer2D->DrawText(tCharFloat,this->rect.x+this->rect.z/2.0f,this->rect.y,this->rect.x+this->rect.z,this->rect.y+this->rect.w);
		}
		break;
		case GuiPropertyString::VEC2:
		{
			vec2& tVec2=*(vec2*)this->valuePointer1;

			char tCharVec2[ctMaxTmpArraySize];
			sprintf(tCharVec2,"%*.*f , %*.*f",this->valueParameter1,this->valueParameter2,tVec2.x,this->valueParameter1,this->valueParameter2,tVec2.y);

			tabContainer->renderer2D->DrawText(tCharVec2,this->rect.x+this->rect.z/2.0f,this->rect.y,this->rect.x+this->rect.z,this->rect.y+this->rect.w);
		}
		break;
		case GuiPropertyString::VEC3:
		{
			vec3& tVec3=*(vec3*)this->valuePointer1;

			char tCharVec3[ctMaxTmpArraySize];
			sprintf(tCharVec3,"%*.*f , %*.*f , %*.*f",	this->valueParameter1,this->valueParameter2,tVec3.x,
														this->valueParameter1,this->valueParameter2,tVec3.y,
														this->valueParameter1,this->valueParameter2,tVec3.z);

			tabContainer->renderer2D->DrawText(tCharVec3,this->rect.x+this->rect.z/2.0f,this->rect.y,this->rect.x+this->rect.z,this->rect.y+this->rect.w);
		}
		break;
		case GuiPropertyString::VEC4:
		{
			vec4& tVec4=*(vec4*)this->valuePointer1;

			char tCharVec4[ctMaxTmpArraySize];
			sprintf(tCharVec4,"%*.*f , %*.*f , %*.*f , %*.*f",	this->valueParameter1,this->valueParameter2,tVec4.x,
																this->valueParameter1,this->valueParameter2,tVec4.y,
																this->valueParameter1,this->valueParameter2,tVec4.z,
																this->valueParameter1,this->valueParameter2,tVec4.w);

			tabContainer->renderer2D->DrawText(tCharVec4,this->rect.x+this->rect.z/2.0f,this->rect.y,this->rect.x+this->rect.z,this->rect.y+this->rect.w);
		}
		break;
		case GuiPropertyString::PTR:
		{
			char tCharPointer[ctMaxTmpArraySize];
			sprintf(tCharPointer,"0x%p",this->valuePointer1);

			tabContainer->renderer2D->DrawText(tCharPointer,this->rect.x+this->rect.z/2.0f,this->rect.y,this->rect.x+this->rect.z,this->rect.y+this->rect.w);
		}
		break;
		case GuiPropertyString::MAT4POS:
		{
			mat4& tMat4=*(mat4*)this->valuePointer1;

			vec3 tPosition=tMat4.position();

			char tCharVec3[ctMaxTmpArraySize];
			sprintf(tCharVec3,"%*.*f , %*.*f , %*.*f",	this->valueParameter1,this->valueParameter2,tPosition.x,
														this->valueParameter1,this->valueParameter2,tPosition.y,
														this->valueParameter1,this->valueParameter2,tPosition.z);

			tabContainer->renderer2D->DrawText(tCharVec3,this->rect.x+this->rect.z/2.0f,this->rect.y,this->rect.x+this->rect.z,this->rect.y+this->rect.w);
		}
		break;
		case GuiPropertyString::ENTITYVECSIZE:
		{
			std::vector<Entity*>& tEntityVec=*(std::vector<Entity*>*)this->valuePointer1;

			size_t tCount=tEntityVec.size();

			char tCharVecSize[10];
			sprintf(tCharVecSize,"%d",tCharVecSize);

			tabContainer->renderer2D->DrawText(tCharVecSize,this->rect.x+this->rect.z/2.0f,this->rect.y,this->rect.x+this->rect.z,this->rect.y+this->rect.w);
		}
		break;
		case GuiPropertyString::ANIMATIONVECSIZE:
		{
			std::vector<Animation*>& tAnimationVec=*(std::vector<Animation*>*)this->valuePointer1;

			size_t tCount=tAnimationVec.size();

			char tCharVecSize[10];
			sprintf(tCharVecSize,"%d",tCharVecSize);

			tabContainer->renderer2D->DrawText(tCharVecSize,this->rect.x+this->rect.z/2.0f,this->rect.y,this->rect.x+this->rect.z,this->rect.y+this->rect.w);
		}
		break;
		case GuiPropertyString::ISBONECOMPONENT:
		{
			Entity* tEntity=(Entity*)this->valueParameter1;

			tabContainer->renderer2D->DrawText(tEntity->findComponent<Bone>() ? "Yes" : "No",this->rect.x+this->rect.z/2.0f,this->rect.y,this->rect.x+this->rect.z,this->rect.y+this->rect.w);
		}
		break;
		case GuiPropertyString::FLOAT2MINUSFLOAT1:
		{
			float& a=*(float*)this->valueParameter1;
			float& b=*(float*)this->valueParameter2;

			char tCharFloatMinusOp[20];
			sprintf(tCharFloatMinusOp,"%*.*d",this->valueParameter1,this->valueParameter2,b-a);

			tabContainer->renderer2D->DrawText(tCharFloatMinusOp,this->rect.x+this->rect.z/2.0f,this->rect.y,this->rect.x+this->rect.z,this->rect.y+this->rect.w);
		}
		break;
		default:
			tabContainer->renderer2D->DrawText("valueType error",this->rect.x+this->rect.z/2.0f,this->rect.y,this->rect.x+this->rect.z,this->rect.y+this->rect.w);
	}

	if(this->container!=0)
		this->BroadcastToChilds(&GuiRect::OnPaint,tabContainer,data);

	this->EndSelfClip(tabContainer,selfClip);
	
}

///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////////GuiSlider///////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////



void GuiSlider::DrawSliderTip(Tab* tabContainer,void* data)
{
	
	bool selfClip=this->BeginSelfClip(tabContainer);

	float tip=(this->rect.x+10) + ((referenceValue)/(maximum-minimum))*(this->rect.z-20);
	tabContainer->renderer2D->DrawRectangle(tip-5,this->rect.y+this->rect.w/4.0f-5,tip+5,this->rect.y+this->rect.w/4.0f+5,Renderer2D::COLOR_TEXT);

	this->EndSelfClip(tabContainer,selfClip);
	
}


void GuiSlider::OnPaint(Tab* tabContainer,void* data)
{
	bool selfClip=this->BeginSelfClip(tabContainer);

	this->DrawBackground(tabContainer);

	tabContainer->renderer2D->DrawRectangle(this->rect.x+10,this->rect.y+this->rect.w/4.0f-2,this->rect.x+this->rect.z-10,this->rect.y+this->rect.w/4.0f+2,0x000000);

	String smin(this->minimum);
	String smax(this->maximum);
	String value(this->referenceValue);

	tabContainer->renderer2D->DrawText(smin.Buffer(),this->rect.x+10,this->rect.y,this->rect.x+this->rect.z-10,this->rect.y+this->rect.w,Renderer2D::COLOR_TEXT,0,0.75);
	tabContainer->renderer2D->DrawText(smax.Buffer(),this->rect.x+10,this->rect.y,this->rect.x+this->rect.z-10,this->rect.y+this->rect.w,Renderer2D::COLOR_TEXT,1,0.75);
	tabContainer->renderer2D->DrawText(value.Buffer(),this->rect.x+10,this->rect.y,this->rect.x+this->rect.z-10,this->rect.y+this->rect.w,Renderer2D::COLOR_TEXT,0.5f,0.75);

	float tip=(this->rect.x+10) + ((referenceValue)/(maximum-minimum))*(this->rect.z-20);

	tabContainer->renderer2D->DrawRectangle(tip-5,this->rect.y+this->rect.w/4.0f-5,tip+5,this->rect.y+this->rect.w/4.0f+5,Renderer2D::COLOR_TEXT);

	if(this->container!=0)
		this->BroadcastToChilds(&GuiRect::OnPaint,tabContainer,data);

	this->EndSelfClip(tabContainer,selfClip);
	
}

void GuiSlider::OnMouseMove(Tab* tabContainer,void* data)
{
	GuiRect::OnMouseMove(tabContainer,data);

	if(this->pressing)
	{
		vec2& mpos=*(vec2*)data;

		if(mpos.x > this->rect.x && mpos.x < this->rect.x+this->rect.z)
		{
			float f1=(mpos.x-(this->rect.x+10))/(this->rect.z-20);
			float f2=maximum-minimum;
			float cursor=f1*f2;

			cursor = cursor<minimum ? minimum : (cursor>maximum ? maximum : cursor);
			
			if(referenceValue!=cursor)
			{
				referenceValue=cursor;
				tabContainer->SetDraw(2,0,this);
			}
		}
	}
}

void GuiSlider::OnSize(Tab* tabContainer,void* data)
{
	/*float oldRatio=maximum/minimum;
	float value=this->referenceValue ? *this->referenceValue : 0;*/

	GuiRect::OnSize(tabContainer);
}

///////////////////////////////////////////////
///////////////////////////////////////////////
///////////GuiPropertySlider///////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

GuiPropertySlider::GuiPropertySlider(const char* iDescription,float& iRefVal,float& iMin,float& iMax):slider(iRefVal,iMin,iMax)
{
	this->description=iDescription;
	this->name="PropertySlider";
	this->Set(0,0,0,-1,0,0,0,25,0,0,1,-1);
	this->slider.Set(this,0,0,-1,0,0,0,0,0.5f,0,0.5f,1);
}

void GuiPropertySlider::OnPaint(Tab* tabContainer,void* data)
{
	bool selfClip=this->BeginSelfClip(tabContainer);

	this->DrawBackground(tabContainer);

	if(description.Buffer())
	{
		String s=description + " " + String(this->slider.referenceValue);
		tabContainer->renderer2D->DrawText(s.Buffer(),this->rect.x,this->rect.y,this->rect.x+rect.z/2.0f,this->rect.y+this->rect.w);
	}

	if(this->container!=0)
		this->BroadcastToChilds(&GuiRect::OnPaint,tabContainer,data);

	this->EndSelfClip(tabContainer,selfClip);
	
}

///////////////////////////////////////////////
///////////////////////////////////////////////
///////////GuiAnimationController//////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

GuiAnimationController::GuiAnimationController(AnimationController& iAnimationController)
	:animationController(iAnimationController),
	slider(animationController.cursor,this->animationController.start,this->animationController.end),
	play(this->animationController.play),
	stop(this->animationController.play)
{
	this->name="GuiAnimationController";

	this->Set(0,0,0,-1,0,0,0,41,0,0,1,-1);

	this->slider.Set(this,0,0,-1,0,0,0,26,0.5f,0,1,-1);
	this->play.Set(this,0,0,-1,0,0,15,15,0.5f,0.75f,-1,-1);
	this->stop.Set(this,&this->play,2,-1,20,0,15,15,-1,0.75f,-1,-1);

	this->stop.colorBackground=this->play.colorBackground=0x000000;
	this->stop.colorPressing=this->play.colorPressing=0xffffff;
	this->stop.colorHovering=this->play.colorHovering=0x88888888;

	this->play.updateMode=1;
	this->stop.updateMode=0;//set 0 onlyif 1
}

void GuiAnimationController::OnMouseMove(Tab* tab,void* data)
{
	float value=this->slider.referenceValue;

	GuiRect::OnMouseMove(tab,data);

	if(value!=this->slider.referenceValue && this->slider.pressing)
	{
		this->animationController.SetFrame(this->slider.referenceValue);
		tab->SetDraw(2,0,this);
	}
}

void GuiAnimationController::OnButtonPressed(Tab* tabContainer,GuiButtonBool* iButton)
{
	if(iButton==&this->play)
		this->animationController.Play();

	if(iButton==&this->stop)
		this->animationController.Stop();
}

///////////////////////////////////////////////
///////////////////////////////////////////////
///////GuiPropertyAnimationController//////////
///////////////////////////////////////////////
///////////////////////////////////////////////

GuiPropertyAnimationController::GuiPropertyAnimationController(AnimationController& iAnimationController)
	:guiAnimationController(iAnimationController)
{
	this->name="GuiPropertyAnimationController";
	this->Set(0,0,0,-1,0,0,0,this->guiAnimationController.rect.w,0,0,1,-1);
	this->description="Controller";
	this->guiAnimationController.SetParent(this);
	this->guiAnimationController.alignPos.x=0.5f;
	this->guiAnimationController.alignRect.x=0.5f;
	/*this->name="GuiPropertyAnimationController";
	this->description="Controller";
	this->Set(this,0,0,-1,0,0,0,guiAnimationController.rect.w,0,0,0.5f,-1);
	this->guiAnimationController.SetParent(this);
	this->guiAnimationController.sibling[0]=this;
	this->guiAnimationController.alignPos.x=0.5f;
	this->guiAnimationController.alignRect.x=0.5f;*/
}

///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////////GuiViewport/////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

void launchStopGuiViewportCallback(void* iData)
{
	GuiViewport* guiViewport=(GuiViewport*)iData;

	bool executedWithSuccess=EngineIDE::instance->compiler->CreateAndroidTarget();

	if(!executedWithSuccess)
		DEBUG_BREAK();

}

GuiViewport::GuiViewport():
	renderBuffer(0),
	renderBitmap(0),
	rootEntity(0),
	needsPicking(0),
	pickedEntity(0),
	playStopButton(0)
{
	this->name="Viewport";

	this->playStopButton=new GuiButtonFunc;

	this->AppendChild(this->playStopButton);

	this->playStopButton->func=launchStopGuiViewportCallback;
	this->playStopButton->param=this;
	this->playStopButton->colorHovering=Renderer2D::COLOR_GUI_BACKGROUND+30;
	this->playStopButton->colorPressing=Renderer2D::COLOR_GUI_BACKGROUND+90;
	this->playStopButton->text="Run";
	this->playStopButton->fixed.w=20;
	this->playStopButton->alignRect.make(1,-1);

}
GuiViewport::~GuiViewport()
{
	SAFEDELETEARRAY(this->renderBuffer);
}

void GuiViewport::OnSize(Tab* tabContainer,void* data)
{
	GuiRect::OnSize(tabContainer,data);
}

void GuiViewport::OnPaint(Tab* tabContainer,void* data)
{
	bool selfClip=this->BeginSelfClip(tabContainer);

	tabContainer->renderer3D->Render(this,false);

	if(this->container!=0)
		this->BroadcastToChilds(&GuiRect::OnPaint,tabContainer);

	this->EndSelfClip(tabContainer,selfClip);
	
}

void GuiViewport::OnMouseWheel(Tab* tabContainer,void* data)
{
	GuiRect::OnMouseWheel(tabContainer);

	float factor=*(float*)data;

	this->view*=mat4().translate(0,0,factor*10);
}

void GuiViewport::OnLMouseUp(Tab* tabContainer,void* data)
{
	if(this->hovering/* && this->pickedEntity*/)
		Tab::BroadcastToPool(&Tab::OnGuiEntitySelected,(void*)this->pickedEntity);

	GuiRect::OnLMouseUp(tabContainer,data);
}

void GuiViewport::OnMouseMove(Tab* tabContainer,void* data)
{
	GuiRect::OnMouseMove(tabContainer,data);

	if(this->hovering)
	{
		vec2 &mpos=*(vec2*)data;

		if(InputManager::keyboardInput.IsPressed(0x01/*VK_LBUTTON*/))
		{
			float dX=(mpos.x-this->mouseold.x);
			float dY=(mpos.y-this->mouseold.y);

			if(InputManager::keyboardInput.IsPressed(0x011/*VK_CONTROL*/))
			{
				mat4 mview;
				vec3 vx,vy,vz;
				vec3 pos;
				mat4 rot;

				mview=this->view;

				mview.traspose();
				mview.inverse();

				mview.axes(vx,vy,vz);

				pos=this->model.position();

				this->model.move(vec3());

				if(dY)
					rot.rotate(dY,vx);
				this->model.rotate(dX,0,0,1);

				this->model*=rot;

				this->model.move(pos);
			}
			else
			{
				this->view*=mat4().translate(dX,dY,0);
			}
		}

		this->needsPicking=true;

		mouseold=mpos;
	}
}


void GuiViewport::OnActivate(Tab* tabContainer,void* data)
{
	GuiRect::OnActivate(tabContainer);
	tabContainer->renderer3D->Register(this);
}
void GuiViewport::OnDeactivate(Tab* tabContainer,void* data)
{
	GuiRect::OnDeactivate(tabContainer);
	tabContainer->renderer3D->Unregister(this);
}

void GuiViewport::OnReparent(Tab* tabContainer,void* data)
{
	GuiRect::OnReparent(tabContainer);
}

///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////////GuiScrollBar////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

GuiScrollBar::GuiScrollBar():
guiRect(0),
	scrollerPressed(-1),
	scrollerPosition(0),
	scrollerRatio(1),
	parentAlignRectX(0)
{
	this->name="ScrollBar";
}
GuiScrollBar::~GuiScrollBar()
{

}


void GuiScrollBar::SetScrollerRatio(float contentHeight,float containerHeight)
{
	float oldScrollerRatio=this->scrollerRatio;

	this->scrollerRatio = (contentHeight<containerHeight) ? 1.0f : containerHeight/contentHeight;

	if(oldScrollerRatio!=this->scrollerRatio)
		SetScrollerPosition(this->scrollerPosition);
}

void GuiScrollBar::SetScrollerPosition(float positionPercent)
{
	float oldScrollerPosition=this->scrollerPosition;

	float scrollerContainerHeight=this->GetContainerHeight();
	float scrollerHeight=this->GetScrollerHeight();

	if(positionPercent+scrollerRatio>1)
		this->scrollerPosition=(scrollerContainerHeight-scrollerHeight)/scrollerContainerHeight;
	else
		this->scrollerPosition = positionPercent < 0 ? 0 : positionPercent;
}

void GuiScrollBar::Scroll(Tab* tabContainer,float upOrDown)
{
	float rowHeightRatio=this->scrollerRatio/GuiSceneViewer::TREEVIEW_ROW_HEIGHT;

	float amount=this->scrollerPosition + (upOrDown<0 ? rowHeightRatio : -rowHeightRatio);

	this->SetScrollerPosition(amount);

	tabContainer->SetDraw(2,0,this->guiRect);
}

void GuiScrollBar::SetRect(GuiRect* iRect)
{
	
}

bool GuiScrollBar::IsVisible()
{
	return this->scrollerRatio<1.0f;
}

float GuiScrollBar::GetContainerHeight()
{
	return this->rect.w-2.0f*SCROLLBAR_TIP_HEIGHT;
}
float GuiScrollBar::GetScrollerTop()
{
	return this->GetContainerTop()+this->scrollerPosition*this->GetContainerHeight();
}
float GuiScrollBar::GetScrollerBottom()
{
	return this->GetScrollerTop()+this->scrollerRatio*this->GetContainerHeight();
}
float GuiScrollBar::GetScrollerHeight()
{
	return this->GetScrollerBottom()-this->GetScrollerTop();
}
float GuiScrollBar::GetContainerTop()
{
	return this->rect.y+SCROLLBAR_TIP_HEIGHT;
}
float GuiScrollBar::GetContainerBottom()
{
	return this->rect.y+this->rect.w-SCROLLBAR_TIP_HEIGHT;
}

void GuiScrollBar::OnLMouseUp(Tab* tabContainer,void* data)
{
	GuiRect::OnLMouseUp(tabContainer);

	this->scrollerPressed=-1;
}

void GuiScrollBar::OnLMouseDown(Tab* tabContainer,void* data)
{
	GuiRect::OnLMouseDown(tabContainer,data);

	if(!this->hovering || scrollerRatio==1.0f)
		return;

	vec2& mpos=*(vec2*)data;

	if(mpos.y<this->GetContainerTop())
		this->Scroll(tabContainer,1);
	else if(mpos.y<this->GetContainerBottom())
	{
		this->scrollerPressed=0;

		if(mpos.y>=this->GetScrollerTop() && mpos.y<=this->GetScrollerBottom())
			this->scrollerPressed=((mpos.y-this->GetScrollerTop())/this->GetScrollerHeight())*this->scrollerRatio;
		else
			SetScrollerPosition((mpos.y-this->GetContainerTop())/this->GetContainerHeight());
	}
	else this->Scroll(tabContainer,-1);

	if(this->parent)
		tabContainer->SetDraw(2,0,this->parent);
}

void GuiScrollBar::OnMouseMove(Tab* tabContainer,void* data)
{
	GuiRect::OnMouseMove(tabContainer,data);

	if(this->scrollerRatio==1.0f || this->scrollerPressed<0)
		return;

	vec2& mpos=*(vec2*)data;

	if(mpos.y>this->GetContainerTop() && mpos.y<this->GetContainerBottom())
	{
		float mouseContainerY=(mpos.y-this->GetContainerTop())/this->GetContainerHeight();

		this->SetScrollerPosition(mouseContainerY-this->scrollerPressed);

		if(this->parent)
			tabContainer->SetDraw(2,0,this->parent);
	}
}


void GuiScrollBar::OnPaint(Tab* tabContainer,void* data)
{
	if(this->scrollerRatio==1.0f)
		return;

	bool selfClip=this->BeginSelfClip(tabContainer);

	tabContainer->renderer2D->DrawRectangle(this->rect.x,this->rect.y,this->rect.x+GuiScrollBar::SCROLLBAR_WIDTH,this->rect.y+GuiScrollBar::SCROLLBAR_TIP_HEIGHT,Renderer2D::COLOR_GUI_BACKGROUND);
	tabContainer->renderer2D->DrawRectangle(this->rect.x,this->rect.y+this->rect.w-GuiScrollBar::SCROLLBAR_TIP_HEIGHT,this->rect.x+GuiScrollBar::SCROLLBAR_WIDTH,this->rect.y+this->rect.w,Renderer2D::COLOR_GUI_BACKGROUND);

	tabContainer->renderer2D->DrawBitmap(tabContainer->iconUp,this->rect.x,this->rect.y,this->rect.x+GuiScrollBar::SCROLLBAR_WIDTH,this->rect.y+GuiScrollBar::SCROLLBAR_TIP_HEIGHT);
	tabContainer->renderer2D->DrawBitmap(tabContainer->iconDown,this->rect.x,this->rect.y+this->rect.w-GuiScrollBar::SCROLLBAR_TIP_HEIGHT,this->rect.x+GuiScrollBar::SCROLLBAR_WIDTH,this->rect.y+this->rect.w);

	tabContainer->renderer2D->DrawRectangle(this->rect.x,this->GetContainerTop(),this->rect.x+GuiScrollBar::SCROLLBAR_WIDTH,this->GetContainerBottom(),Renderer2D::COLOR_GUI_BACKGROUND);
	
	tabContainer->renderer2D->DrawRectangle(this->rect.x,this->GetScrollerTop(),this->rect.x+GuiScrollBar::SCROLLBAR_WIDTH,this->GetScrollerBottom(),0x00000000);

	if(this->container!=0)
		this->BroadcastToChilds(&GuiRect::OnPaint,tabContainer,data);

	this->EndSelfClip(tabContainer,selfClip);
	
}

///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////GuiSceneViewer/////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

GuiSceneViewer::GuiSceneViewer():
entityRoot(0)
{
	this->entityRoot=new EditorEntity;
	this->entityRoot->name="SceneRootEntity";
	this->entityRoot->expanded=true;

	this->name="Scene";
	this->sceneName="Scene";
}

GuiSceneViewer::~GuiSceneViewer()
{
	printf("destroying treeview %p\n",this);
}

void GuiSceneViewer::OnMouseWheel(Tab* tabContainer,void* data)
{
	GuiRect::OnMouseWheel(tabContainer,data);

	if(this->hovering)
	{
		float wheelFactor=*(float*)data;

		this->scrollBar->Scroll(tabContainer,wheelFactor);

		//tabContainer->SetDraw(2,0,this);
	}
}

void GuiSceneViewer::OnRMouseUp(Tab* tabContainer,void* data)
{
	GuiRect::OnRMouseUp(tabContainer,data);

	vec2& mpos=*(vec2*)data;

	vec2 tDrawCanvas(-GuiRect::TREEVIEW_ROW_ADVANCE,-GuiRect::TREEVIEW_ROW_HEIGHT);

	bool eEntityExpanded=false;
	EditorEntity* eEntity = this->GetHoveredRow(this->entityRoot,mpos,tDrawCanvas,eEntityExpanded);
		
	int menuResult=tabContainer->TrackGuiSceneViewerPopup(eEntity ? true : false);
	
	switch(menuResult)
	{
	case 1:
		{
			EditorEntity* newEntity=new EditorEntity;

			newEntity->name="EntityPippo";

			newEntity->SetParent(eEntity ? eEntity : this->entityRoot);
			newEntity->bbox.a.make(-1,-1,-1);
			newEntity->bbox.b.make(1,1,1);

			newEntity->OnPropertiesCreate();

			this->UpdateNodes(this->entityRoot);
		}
		break;
	case 2:eEntity->parent->childs.erase(std::find(eEntity->parent->childs.begin(),eEntity->parent->childs.end(),eEntity));break;
	case 3:eEntity->CreateComponent<EditorLight>();break;
	case 4:eEntity->CreateComponent<EditorMesh>();break;
	case 5:eEntity->CreateComponent<EditorCamera>();break;
	case 14:eEntity->CreateComponent<EditorScript>();break;
	}

	this->OnSize(tabContainer);
	tabContainer->SetDraw(2,0,this);
}

void GuiSceneViewer::OnRecreateTarget(Tab* tabContainer,void* data)
{
	GuiRect::OnRecreateTarget(tabContainer);
}

void GuiSceneViewer::OnEntitiesChange(Tab* tabContainer,void* data)
{
	EditorEntity* entity=(EditorEntity*)data;

	if(entity)
		entity->SetParent(this->entityRoot);

	this->contentHeight=-(float)TREEVIEW_ROW_HEIGHT+this->UpdateNodes(this->entityRoot);

	scrollBar->SetScrollerRatio(this->contentHeight,this->rect.w);

	if(this->active)
	{
		this->OnSize(tabContainer);
		tabContainer->SetDraw(2,0,this);
	}

	GuiRect::OnEntitiesChange(tabContainer,data);
}

void GuiSceneViewer::OnEntitySelected(Tab* tabContainer,void* data)
{
	GuiRect::OnEntitySelected(tabContainer,data);

	EditorEntity* entity=(EditorEntity*)data;

	if(entity)
	{
		if(this->selection.end()==std::find(this->selection.begin(),this->selection.end(),entity))
		{
			this->UnselectNodes(this->entityRoot);
			this->ExpandUntil(entity);
			this->selection.clear();
			this->selection.push_back(entity);

			this->UpdateNodes(this->entityRoot);
			this->OnSize(tabContainer);

			entity->selected=true;

			entity->CreateComponent<EditorGizmo>();

			tabContainer->SetDraw(2,0,this);
		}
	}
}

void GuiSceneViewer::ExpandUntil(EditorEntity* iTarget)
{
	iTarget->expanded=true;

	if(iTarget->parent)
		GuiSceneViewer::ExpandUntil((EditorEntity*)iTarget->parent);
}

void GuiSceneViewer::UnselectNodes(EditorEntity* node)
{
	node->selected=false;

	for(std::vector<EntityComponent*>::iterator i=node->components.begin();i!=node->components.end();)
		(*i)->is<EditorGizmo>() ? i=node->components.erase(i) : i++ ; 

	for(std::list<Entity*>::iterator nCh=node->childs.begin();nCh!=node->childs.end();nCh++)
		this->UnselectNodes((EditorEntity*)*nCh);
}

EditorEntity* GuiSceneViewer::GetHoveredRow(EditorEntity* iEntityNode,vec2& iMousePos,vec2& iFramePos,bool& oExpandos)
{
	float tDrawFromHeight=this->scrollBar->scrollerPosition*this->contentHeight;

	if(iFramePos.y+TREEVIEW_ROW_HEIGHT>=tDrawFromHeight && iFramePos.y<=tDrawFromHeight+this->rect.w)
	{
		float tRelativeY=this->rect.y+iFramePos.y-tDrawFromHeight;

		float tCursor=this->rect.x+iFramePos.x+TREEVIEW_ROW_ADVANCE*iEntityNode->level;

		oExpandos= iEntityNode->childs.size() && (iMousePos.x>tCursor && iMousePos.x<tCursor+TREEVIEW_ROW_ADVANCE);

		if(iMousePos.y>tRelativeY && iMousePos.y<tRelativeY+GuiSceneViewer::TREEVIEW_ROW_HEIGHT)
			return iEntityNode;
	}

	iFramePos.y+=TREEVIEW_ROW_HEIGHT;

	if(iEntityNode->expanded)
	{
		for(std::list<Entity*>::iterator nCh=iEntityNode->childs.begin();nCh!=iEntityNode->childs.end();nCh++)
		{
			EditorEntity* tHoveredEntity=this->GetHoveredRow((EditorEntity*)*nCh,iMousePos,iFramePos,oExpandos);
			if(tHoveredEntity)
				return tHoveredEntity;
		}
	}

	return 0;
}

void GuiSceneViewer::OnLMouseDown(Tab* tabContainer,void* iData)
{
	if(this->hovering)
	{	
		vec2& tMousePos=*(vec2*)iData;

		if(!InputManager::keyboardInput.IsPressed(0x11/*VK_CONTROL*/))
			this->selection.clear();

		vec2 tDrawCanvas(-TREEVIEW_ROW_ADVANCE,-TREEVIEW_ROW_HEIGHT);

		bool eEntityExpandosPressed=false;
		EditorEntity* eEntity=this->GetHoveredRow(this->entityRoot,tMousePos,tDrawCanvas,eEntityExpandosPressed);

		if(eEntity)
		{
			if(!eEntityExpandosPressed)
			{
				this->UnselectNodes(this->entityRoot);

				if(!eEntity->selected)
					eEntity->selected=true;
			}
			else
			{
				eEntity->expanded=!eEntity->expanded;

				this->UpdateNodes(this->entityRoot);
				this->OnSize(tabContainer);
			}

			this->selection.push_back(eEntity);
		}
		else
			this->UnselectNodes(this->entityRoot);

		Tab::BroadcastToPool(&Tab::OnGuiEntitySelected,eEntity);

		tabContainer->SetDraw(2,0,this);
	}

	GuiRect::OnLMouseDown(tabContainer,iData);
}


int GuiSceneViewer::UpdateNodes(EditorEntity* node)
{
	if(!node)
		return 0;

	if(node==this->entityRoot)
		this->contentHeight=0;
	else
		this->contentHeight += TREEVIEW_ROW_HEIGHT;

	if(node->expanded)
	{
		for(std::list<Entity*>::iterator nCh=node->childs.begin();nCh!=node->childs.end();nCh++)
			this->UpdateNodes((EditorEntity*)*nCh);
	}

	return this->contentHeight;
}

void GuiSceneViewer::DrawNodes(Tab* tabContainer,EditorEntity* node,vec2& iFromPosition)
{
	if(!node)
		return;

	float drawFromY=this->scrollBar->scrollerPosition*this->contentHeight;

	if(iFromPosition.y+TREEVIEW_ROW_HEIGHT>=drawFromY && iFromPosition.y<=drawFromY+this->rect.w)
	{
		float relativeY=this->rect.y+iFromPosition.y-drawFromY;

		if(node->selected)
			tabContainer->renderer2D->DrawRectangle(0,(float)relativeY,(float)this->width,(float)relativeY+GuiSceneViewer::TREEVIEW_ROW_HEIGHT,Renderer2D::COLOR_TAB_SELECTED);

		float xCursor=this->rect.x+iFromPosition.x+TREEVIEW_ROW_ADVANCE*node->level;

		if(node->childs.size())
		{
			tabContainer->renderer2D->DrawBitmap(node->expanded ? tabContainer->iconDown : tabContainer->iconRight,xCursor,relativeY,xCursor+Tab::CONTAINER_ICON_WH,relativeY+GuiSceneViewer::TREEVIEW_ROW_HEIGHT);
			xCursor+=TREEVIEW_ROW_ADVANCE;
		}

		tabContainer->renderer2D->DrawText(node->name.Buffer(),xCursor,relativeY,xCursor+this->width,relativeY+GuiSceneViewer::TREEVIEW_ROW_HEIGHT,Renderer2D::COLOR_TEXT,-1,0.5);
	}
	else if(iFromPosition.y>drawFromY)
		return;

	iFromPosition.y+=TREEVIEW_ROW_HEIGHT;

	if(node->expanded)
	{
		for(std::list<Entity*>::iterator nCh=node->childs.begin();nCh!=node->childs.end();nCh++)
			this->DrawNodes(tabContainer,(EditorEntity*)*nCh,iFromPosition);
	}

}


void GuiSceneViewer::OnPaint(Tab* tabContainer,void* data)
{
	bool selfClip=this->BeginSelfClip(tabContainer);

	this->DrawBackground(tabContainer);

	tabContainer->renderer2D->PushScissor(this->rect.x,this->rect.y,this->rect.x+this->width,this->rect.y+this->rect.w);

	vec2 tDrawCanvas(-TREEVIEW_ROW_ADVANCE,-TREEVIEW_ROW_HEIGHT);

	this->DrawNodes(tabContainer,this->entityRoot,tDrawCanvas);

	tabContainer->renderer2D->PopScissor();

	if(this->container!=0)
		this->BroadcastToChilds(&GuiRect::OnPaint,tabContainer,data);

	this->EndSelfClip(tabContainer,selfClip);
}

void GuiSceneViewer::OnKeyDown(Tab* tabContainer,void* data)
{
	if(this==tabContainer->GetFocus())
	{
		if(InputManager::keyboardInput.IsPressed(0x11/*VK_CONTROL*/) && !InputManager::keyboardInput.IsPressed(0x12/*VK_ALT*/))
		{
			if(InputManager::keyboardInput.IsPressed('S'))
			{
				String tSaveFile=EngineIDE::instance->projectFolder + "\\" + this->sceneName.c_str() + EngineIDE::instance->GetSceneExtension();
				this->Save(tSaveFile.Buffer());
			}
		}
	}

	GuiScrollRect::OnKeyDown(tabContainer,data);
}





void saveEntityRecursively(Entity* iEntity,FILE* iFile)
{
	int childsSize=iEntity->childs.size();
	int componentsSize=iEntity->components.size();
	int nameCount=iEntity->name.Count();

	fwrite(&childsSize,sizeof(int),1,iFile);//4

	fwrite(iEntity->local,sizeof(sizeof(float)),16,iFile);//64
	fwrite(iEntity->world,sizeof(sizeof(float)),16,iFile);//64

	fwrite(&nameCount,sizeof(int),1,iFile);//4
	fwrite(iEntity->name.Buffer(),iEntity->name.Count(),1,iFile);//variadic

	fwrite(iEntity->bbox.a,sizeof(sizeof(float)),3,iFile);//12
	fwrite(iEntity->bbox.b,sizeof(sizeof(float)),3,iFile);//12

	fwrite(&componentsSize,sizeof(int),1,iFile);//4

	for(std::vector<EntityComponent*>::iterator cIter=iEntity->components.begin();cIter!=iEntity->components.end();cIter++)
	{
		if((*cIter)->is<Script>())
		{
			Script* tScript=(Script*)(*cIter);

			fwrite(&Serialization::Script,sizeof(unsigned char),1,iFile);//1
			
			nameCount=tScript->script.path.Count();

			fwrite(&nameCount,sizeof(int),1,iFile);//4
			fwrite(tScript->script.path.Buffer(),tScript->script.path.Count(),1,iFile);//variadic
		}
		else
			fwrite(&Serialization::Unknown,sizeof(unsigned char),1,iFile);//1
	}
	
	if(childsSize)
	{
		for(std::list<Entity*>::iterator eIter=iEntity->childs.begin();eIter!=iEntity->childs.end();eIter++)
			saveEntityRecursively(*eIter,iFile);
	}
}

EditorEntity* loadEntityRecursively(EditorEntity* iEditorEntityParent,FILE* iFile)
{
	int nameCount;
	int componentsSize;
	int childsSize;
	unsigned char componentCode;

	EditorEntity* tEditorEntity=new EditorEntity;

	tEditorEntity->SetParent(iEditorEntityParent);

	fread(&childsSize,sizeof(sizeof(int)),1,iFile);//4

	fread(tEditorEntity->local,sizeof(sizeof(float)),16,iFile);//64
	fread(tEditorEntity->world,sizeof(sizeof(float)),16,iFile);//64
	
	fread(&nameCount,sizeof(int),1,iFile);//4

	{
		char *tNameBuf=new char[nameCount+1];
		fread(tNameBuf,nameCount,1,iFile);//variadic
		tNameBuf[nameCount]='\0';

		tEditorEntity->name=tNameBuf;

		SAFEDELETEARRAY(tNameBuf);
	}

	fread(tEditorEntity->bbox.a,sizeof(sizeof(float)),3,iFile);//12
	fread(tEditorEntity->bbox.b,sizeof(sizeof(float)),3,iFile);//12

	tEditorEntity->OnResourcesCreate();
	tEditorEntity->OnPropertiesCreate();

	fread(&componentsSize,sizeof(int),1,iFile);//4

	for(int i=0;i<componentsSize;i++)
	{
		fread(&componentCode,sizeof(unsigned char),1,iFile);//1

		if(componentCode==Serialization::Script)
		{
			EditorScript* tScript=tEditorEntity->CreateComponent<EditorScript>();

			fread(&nameCount,sizeof(int),1,iFile);//4

			{
				char *tNameBuf=new char[nameCount+1];
				fread(tNameBuf,nameCount,1,iFile);//variadic
				tNameBuf[nameCount]='\0';

				tScript->script.path=tNameBuf;

				SAFEDELETEARRAY(tNameBuf);
			}
		}
	}

	if(childsSize)
	{
		for(int i=0;i<childsSize;i++)
			loadEntityRecursively(tEditorEntity,iFile);
	}

	return tEditorEntity;
}

void GuiSceneViewer::Save(const char* iFilename)
{
	FILE* file=fopen(iFilename,"wb");
	if(!file)
		return;

	saveEntityRecursively(this->entityRoot,file);

	fclose(file);
}

void GuiSceneViewer::Load(const char* iFilename)
{
	FILE* file=fopen(iFilename,"rb");
	if(!file)
		return;

	for(std::list<Entity*>::iterator i=this->entityRoot->childs.begin();i!=this->entityRoot->childs.end();)
		i=this->entityRoot->childs.erase(i);

	EditorEntity* tEntity=loadEntityRecursively(0,file);

	std::list<Entity*> tChildsCopy=tEntity->childs;

	for(std::list<Entity*>::iterator i=tChildsCopy.begin();i!=tChildsCopy.end();i++)
		(*i)->SetParent(this->entityRoot);

	SAFEDELETE(tEntity);

	if(this->active)
	{
		Tab* tab=this->GetRootRect()->tabContainer;

		this->UpdateNodes(this->entityRoot);
		this->OnSize(tab);
		tab->SetDraw(2,0,this);
	}

	fclose(file);
}

///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////GuiEntityViewer/////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

GuiEntityViewer::GuiEntityViewer():
entity(0),tabContainer(0)
{
	this->name="Entity";
};

GuiEntityViewer::~GuiEntityViewer()
{
	printf("destroying properties %p\n",this);
}

void GuiEntityViewer::OnEntitySelected(Tab* tabContainer,void* data)
{
	EditorEntity* iEntity=(EditorEntity*)data;

	if(this->entity!=iEntity)
	{
		if(this->entity)
		{
			this->BroadcastToChilds(&GuiRect::OnDeactivate,tabContainer);
			this->entity->properties.SetParent(0);
			this->entity->properties.SetClip(0);
			this->entity=0;
			this->scrollBar->SetParent(0);
		}

		if(iEntity)
		{
			this->entity=iEntity;
			this->entity->properties.SetParent(this);

			this->scrollBar->SetParent(this);
			this->entity->properties.SetClip(this);

			this->CalcNodesHeight(&iEntity->properties);
			this->scrollBar->SetScrollerPosition(0);

			this->OnSize(tabContainer);
			this->entity->properties.OnActivate(tabContainer);
		}
		else
		{
			this->CalcNodesHeight(&iEntity->properties);
			this->OnSize(tabContainer);
		}

		tabContainer->SetDraw(2,0,this);
	}
	else
	{
		this->CalcNodesHeight(&iEntity->properties);
		this->OnSize(tabContainer);

		tabContainer->SetDraw(2,0,this);
	}

	GuiRect::OnEntitySelected(tabContainer);
}

void GuiEntityViewer::OnExpandos(Tab* tabContainer,void* data)
{
	this->CalcNodesHeight(&this->entity->properties);
	this->OnSize(tabContainer);
}

void GuiEntityViewer::OnPaint(Tab* tabContainer,void* data)
{
	bool selfClip=this->BeginSelfClip(tabContainer);

	tabContainer->renderer2D->DrawRectangle(this->rect.x,this->rect.y,this->rect.x+this->width,this->rect.y+this->rect.w,Renderer2D::COLOR_GUI_BACKGROUND);

	if(this->entity)
		this->entity->properties.OnPaint(tabContainer);

	this->scrollBar->OnPaint(tabContainer);

	this->EndSelfClip(tabContainer,selfClip);
}

void GuiEntityViewer::OnActivate(Tab* iTabContainer,void* data)
{
	tabContainer=iTabContainer;

	GuiRect::OnActivate(tabContainer);
}


void GuiEntityViewer::OnMouseWheel(Tab* tabContainer,void* data)
{
	GuiScrollRect::OnMouseWheel(tabContainer,data);
}

bool GuiEntityViewer::ProcessMouseInput(vec2&,vec2&,GuiRect* node)
{
	return false;
}
void GuiEntityViewer::DrawNodes(Tab*,GuiRect* node,vec2&)
{

}
int GuiEntityViewer::CalcNodesHeight(GuiRect* node)
{
	if(!node || !this->entity)
		return 0;

	this->contentHeight=0;

	for(std::vector<GuiRect*>::iterator nCh=this->entity->properties.childs.begin();nCh!=this->entity->properties.childs.end();nCh++)
	{
		GuiRect* prop=(*nCh);
		this->contentHeight+=prop->rect.w;
	}

	return this->contentHeight;
}

///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////ResourceNode/////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

ResourceNode::ResourceNode():
	parent(0),
	level(0),
	isDir(0),
	selectedLeft(0),
	selectedRight(0)

{}
ResourceNode::~ResourceNode()
{
	this->fileName="";
	this->selectedLeft=false;
	this->selectedRight=false;
	this->level=0;
	this->isDir=false;
}

ResourceNodeDir::ResourceNodeDir():expanded(0){}
ResourceNodeDir::~ResourceNodeDir()
{
	for(std::list<ResourceNode*>::iterator nCh=this->files.begin();nCh!=this->files.end();nCh++)
		SAFEDELETE(*nCh);

	for(std::list<ResourceNodeDir*>::iterator nCh=this->dirs.begin();nCh!=this->dirs.end();nCh++)
		SAFEDELETE(*nCh);

	if(this->parent)
	{
		ResourceNodeDir* tParent=(ResourceNodeDir*)this->parent;

		if(this->isDir)
			tParent->dirs.erase(std::find(tParent->dirs.begin(),tParent->dirs.end(),this));
		else
			tParent->files.erase(std::find(tParent->files.begin(),tParent->files.end(),this));
	}
}

///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////GuiProjectViewer/////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

GuiProjectViewer::GuiProjectViewer():
	splitterLeft(false),
	splitterRight(false),
	hotspotDist(0)
{
	this->name="Project";

	dirViewer.Set(this,0,0,-1,0,0,0,0,-1,0,-1,1);
	fileViewer.Set(this,0,0,-1,0,0,0,0,-1,0,-1,1);
	resourceViewer.Set(this,0,0,-1,0,0,0,0,-1,0,-1,1);

	this->rootResource.fileName=EngineIDE::instance->projectFolder;
	this->rootResource.expanded=true;
	this->rootResource.isDir=true;

	dirViewer.rootResource=&this->rootResource;
	fileViewer.rootResource=&this->rootResource;

	dirViewer.selectedDirs.push_back(&this->rootResource);
}

GuiProjectViewer::~GuiProjectViewer()
{
	printf("destroying resources %p\n",this);
}



void GuiProjectViewer::OnActivate(Tab* tabContainer,void* data)
{
	if(!this->active)
	{
		EngineIDE::instance->ScanDir(this->rootResource.fileName);
		EngineIDE::instance->CreateNodes(this->rootResource.fileName,&this->rootResource);

		this->dirViewer.CalcNodesHeight(&this->rootResource);
		this->fileViewer.CalcNodesHeight(&this->rootResource);

		float tWidth=tabContainer->windowData->width/3.0f;

		dirViewer.fixed.x=0;
		dirViewer.fixed.z=tWidth-2;
		fileViewer.fixed.x=tWidth+2;
		fileViewer.fixed.z=tWidth-4;
		resourceViewer.fixed.x=tWidth*2+2;
		resourceViewer.fixed.z=tWidth;

		this->OnSize(tabContainer,data);
	}

	GuiRect::OnActivate(tabContainer);
}

void GuiProjectViewer::OnDeactivate(Tab* tabContainer,void* data)
{
	if(this->active)
	{
		this->rootResource.files.erase(this->rootResource.files.begin(),this->rootResource.files.end());
		this->rootResource.dirs.erase(this->rootResource.dirs.begin(),this->rootResource.dirs.end());
	}

	GuiRect::OnDeactivate(tabContainer);
}


void GuiProjectViewer::OnLMouseDown(Tab* tabContainer,void* data)
{
	GuiRect::OnLMouseDown(tabContainer,data);

	if(this->hovering)
	{
		vec2& mpos=*(vec2*)data;

		if(mpos.x<=this->fileViewer.rect.x)
		{
			this->splitterLeft=true;
			this->hotspotDist=this->fileViewer.rect.x-mpos.x;
		}
		else if(mpos.x<=this->resourceViewer.rect.x)
		{
			this->splitterRight=true;
			this->hotspotDist=this->resourceViewer.rect.x-mpos.x;
		}
	}
}

void GuiProjectViewer::OnLMouseUp(Tab* tabContainer,void* data)
{
	if(this->pressing)
	{
		this->splitterLeft=false;
		this->splitterRight=false;
	}

	GuiRect::OnLMouseUp(tabContainer);
}

void GuiProjectViewer::OnMouseMove(Tab* tabContainer,void* data)
{

	if(this->hovering)
	{
		tabContainer->SetCursor(1);

		if(this->pressing)
		{
			vec2& mpos=*(vec2*)data;

			if(this->splitterLeft)
			{
				float tRightWidthAbs=this->fileViewer.rect.x+this->fileViewer.rect.z;
				this->dirViewer.fixed.z=mpos.x-2;
				this->fileViewer.fixed.x=mpos.x+2;
				this->fileViewer.fixed.z=this->resourceViewer.rect.x-this->fileViewer.rect.x-4;

				this->dirViewer.OnSize(tabContainer);
				this->fileViewer.OnSize(tabContainer);
			}
			if(this->splitterRight)
			{
				this->fileViewer.fixed.z=mpos.x-this->fileViewer.rect.x-2;
				this->resourceViewer.fixed.x=mpos.x+2;
				this->resourceViewer.fixed.z=this->rect.x+this->rect.z-this->resourceViewer.rect.x;

				this->fileViewer.OnSize(tabContainer);
				this->resourceViewer.OnSize(tabContainer);
			}

			

			tabContainer->SetDraw(1,0,0);
		}
	}

	GuiRect::OnMouseMove(tabContainer,data);
}

void GuiProjectViewer::OnReparent(Tab* tabContainer,void* data)
{
	GuiRect::OnReparent(tabContainer);

	tabContainer->OnGuiSize();
	tabContainer->OnGuiRecreateTarget();
}


void GuiProjectViewer::OnPaint(Tab* tabContainer,void* data)
{
	bool selfClip=this->BeginSelfClip(tabContainer);

	tabContainer->renderer2D->DrawRectangle(this->rect,Renderer2D::COLOR_MAIN_BACKGROUND,true);

	if(this->container!=0)
		this->BroadcastToChilds(&GuiRect::OnPaint,tabContainer,data);

	this->EndSelfClip(tabContainer,selfClip);
	
}

void GuiProjectViewer::OnSize(Tab* tabContainer,void* data)
{
	GuiRect::OnSize(tabContainer);

	this->resourceViewer.rect.z=this->rect.x+this->rect.z-this->resourceViewer.rect.x;
}


/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
///////////////GuiProjectViewer::GuiProjectDirViewer/////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////


void GuiProjectViewer::GuiProjectDirViewer::DrawNodes(Tab* tabContainer,ResourceNodeDir* node,vec2& pos,bool& terminated)
{
	if(terminated)
		return;

	float drawFromHeight=this->scrollBar->scrollerPosition*this->contentHeight;

	if(pos.y+TREEVIEW_ROW_HEIGHT>=drawFromHeight && pos.y<=drawFromHeight+this->rect.w)
	{
		float relativeY=this->rect.y+pos.y-drawFromHeight;

		if(node->selectedLeft)
			tabContainer->renderer2D->DrawRectangle(this->rect.x,relativeY,this->rect.x+this->width,(float)relativeY+GuiSceneViewer::TREEVIEW_ROW_HEIGHT,Renderer2D::COLOR_TAB_SELECTED);

		float xCursor=this->rect.x+TREEVIEW_ROW_ADVANCE*node->level;

		if(node->dirs.size())
		{
			tabContainer->renderer2D->DrawBitmap(node->expanded ? tabContainer->iconDown : tabContainer->iconRight,xCursor,relativeY,xCursor+Tab::CONTAINER_ICON_WH,relativeY+GuiSceneViewer::TREEVIEW_ROW_HEIGHT);
			xCursor+=TREEVIEW_ROW_ADVANCE;
		}

		tabContainer->renderer2D->DrawBitmap(tabContainer->iconFolder,xCursor,relativeY,xCursor+Tab::CONTAINER_ICON_WH,relativeY+GuiSceneViewer::TREEVIEW_ROW_HEIGHT);

		xCursor+=TREEVIEW_ROW_ADVANCE;

		tabContainer->renderer2D->DrawText(node->fileName.Buffer(),xCursor,relativeY,this->width,relativeY+GuiSceneViewer::TREEVIEW_ROW_HEIGHT,Renderer2D::COLOR_TEXT,-1,0.5f);


	}

	pos.y+=TREEVIEW_ROW_HEIGHT;

	if(pos.y>drawFromHeight+this->rect.w)
	{
		terminated=true;
		return;
	}

	if(node->expanded)
	{
		for(std::list<ResourceNodeDir*>::iterator nCh=node->dirs.begin();nCh!=node->dirs.end();nCh++)
			this->DrawNodes(tabContainer,*nCh,pos,terminated);
	}

	return;
}

int GuiProjectViewer::GuiProjectDirViewer::CalcNodesHeight(ResourceNodeDir* node)
{
	if(!node)
		return 0;

	if(node==this->rootResource)
		this->contentHeight=0;

	this->contentHeight += node->isDir  ? TREEVIEW_ROW_HEIGHT : 0;

	if(node->expanded)
	{
		for(std::list<ResourceNodeDir*>::iterator nCh=node->dirs.begin();nCh!=node->dirs.end();nCh++)
			this->CalcNodesHeight(*nCh);
	}

	return this->contentHeight;
}

void GuiProjectViewer::GuiProjectDirViewer::UnselectNodes(ResourceNodeDir* node)
{
	if(!node)
		return;

	node->selectedLeft=false;

	for(std::list<ResourceNode*>::iterator nCh=node->files.begin();nCh!=node->files.end();nCh++)
		(*nCh)->selectedLeft=0;

	for(std::list<ResourceNodeDir*>::iterator nCh=node->dirs.begin();nCh!=node->dirs.end();nCh++)
		this->UnselectNodes(*nCh);
}

ResourceNodeDir* GuiProjectViewer::GuiProjectDirViewer::GetHoveredRow(ResourceNodeDir* iResourceNodeDirNode,vec2& iMousePos,vec2& iFramePos,bool& oExpandos)
{
	float tDrawFromHeight=this->scrollBar->scrollerPosition*this->contentHeight;

	if(iFramePos.y+TREEVIEW_ROW_HEIGHT>=tDrawFromHeight && iFramePos.y<=tDrawFromHeight+this->rect.w)
	{
		float tRelativeY=this->rect.y+iFramePos.y-tDrawFromHeight;

		float tCursor=this->rect.x+iFramePos.x+TREEVIEW_ROW_ADVANCE*iResourceNodeDirNode->level;

		oExpandos= iResourceNodeDirNode->dirs.size() && (iMousePos.x>tCursor && iMousePos.x<tCursor+TREEVIEW_ROW_ADVANCE);

		if(iMousePos.y>tRelativeY && iMousePos.y<tRelativeY+GuiSceneViewer::TREEVIEW_ROW_HEIGHT)
			return iResourceNodeDirNode;
	}

	iFramePos.y+=TREEVIEW_ROW_HEIGHT;

	if(iResourceNodeDirNode->expanded)
	{
		for(std::list<ResourceNodeDir*>::iterator nCh=iResourceNodeDirNode->dirs.begin();nCh!=iResourceNodeDirNode->dirs.end();nCh++)
		{
			ResourceNodeDir* tHoveredEntity=this->GetHoveredRow((ResourceNodeDir*)*nCh,iMousePos,iFramePos,oExpandos);
			if(tHoveredEntity)
				return tHoveredEntity;
		}
	}

	return 0;
}

void GuiProjectViewer::GuiProjectDirViewer::OnLMouseDown(Tab* iTabContainer,void* iData)
{
	GuiRect::OnLMouseDown(iTabContainer,iData);

	if(!this->hovering)
		return;

	vec2& tMousePos=*(vec2*)iData;

	vec2 tDrawCanvas(0,0);

	bool resourceNodeDirExpanded=false;

	ResourceNodeDir* resourceNodeDir=this->GetHoveredRow(this->rootResource,tMousePos,tDrawCanvas,resourceNodeDirExpanded);

	if(resourceNodeDir)
	{
		if(!resourceNodeDirExpanded)
		{
			this->UnselectNodes(this->rootResource);

			if(!resourceNodeDir->selectedLeft)
				resourceNodeDir->selectedLeft=true;

			this->CalcNodesHeight(this->rootResource);
			this->OnSize(iTabContainer);
		}
		else
			resourceNodeDir->expanded=!resourceNodeDir->expanded;

		if(!InputManager::keyboardInput.IsPressed(0x11/*VK_CONTROL*/))
			this->selectedDirs.clear();

		this->selectedDirs.push_back(resourceNodeDir);

		iTabContainer->SetDraw(2,0,this);
	}
}

void GuiProjectViewer::GuiProjectDirViewer::OnPaint(Tab* tabContainer,void* data)
{
	bool selfClip=this->BeginSelfClip(tabContainer);

	this->DrawBackground(tabContainer);

	tabContainer->renderer2D->PushScissor(this->rect.x,this->rect.y,this->rect.x+this->width,this->rect.y+this->rect.w);

	vec2 tDrawCanvas(0,0);

	bool terminated=false;
	this->DrawNodes(tabContainer,this->rootResource,tDrawCanvas,terminated);

	tabContainer->renderer2D->PopScissor();

	if(this->container!=0)
		this->BroadcastToChilds(&GuiRect::OnPaint,tabContainer,data);

	this->EndSelfClip(tabContainer,selfClip);

}


/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
///////////////GuiProjectViewer::GuiProjectDirViewer/////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////

void GuiProjectViewer::GuiProjectFileViewer::DrawNodes(Tab* tabContainer,ResourceNodeDir* _node,vec2& pos)
{
	float drawFromHeight=this->scrollBar->scrollerPosition*this->contentHeight;

	for(std::list<ResourceNodeDir*>::iterator nCh=_node->dirs.begin();nCh!=_node->dirs.end();nCh++)
	{
		if(pos.y+TREEVIEW_ROW_HEIGHT>=drawFromHeight && pos.y<=drawFromHeight+this->rect.w)
		{
			float relativeY=this->rect.y+pos.y-drawFromHeight;

			ResourceNodeDir* node=(*nCh);

			if(node->selectedRight)
				tabContainer->renderer2D->DrawRectangle(this->rect.x,relativeY,this->rect.x+this->width,(float)relativeY+GuiSceneViewer::TREEVIEW_ROW_HEIGHT,Renderer2D::COLOR_TAB_SELECTED);

			float xCursor=this->rect.x;

			tabContainer->renderer2D->DrawBitmap(tabContainer->iconFolder,xCursor,relativeY,xCursor+Tab::CONTAINER_ICON_WH,relativeY+GuiSceneViewer::TREEVIEW_ROW_HEIGHT);

			xCursor+=TREEVIEW_ROW_ADVANCE;

			tabContainer->renderer2D->DrawText(node->fileName.Buffer(),xCursor,relativeY,xCursor+this->width,relativeY+GuiSceneViewer::TREEVIEW_ROW_HEIGHT,Renderer2D::COLOR_TEXT,-1,0.5f);
		}
		else if(pos.y>drawFromHeight)
			return;

		pos.y+=TREEVIEW_ROW_HEIGHT;
	}

	for(std::list<ResourceNode*>::iterator nCh=_node->files.begin();nCh!=_node->files.end();nCh++)
	{
		if(pos.y+TREEVIEW_ROW_HEIGHT>=drawFromHeight && pos.y<=drawFromHeight+this->rect.w)
		{
			float relativeY=this->rect.y+pos.y-drawFromHeight;

			ResourceNode* node=(*nCh);

			if(node->selectedRight)
				tabContainer->renderer2D->DrawRectangle(this->rect.x,relativeY,this->rect.x+this->width,relativeY+GuiSceneViewer::TREEVIEW_ROW_HEIGHT,Renderer2D::COLOR_TAB_SELECTED);

			float xCursor=this->rect.x;
			tabContainer->renderer2D->DrawBitmap(tabContainer->iconFile,xCursor,relativeY,xCursor+Tab::CONTAINER_ICON_WH,relativeY+GuiSceneViewer::TREEVIEW_ROW_HEIGHT);

			xCursor+=TREEVIEW_ROW_ADVANCE;

			tabContainer->renderer2D->DrawText(node->fileName.Buffer(),xCursor,relativeY,xCursor+rect.z,relativeY+GuiSceneViewer::TREEVIEW_ROW_HEIGHT,Renderer2D::COLOR_TEXT,-1,0.5f);
		}
		else if(pos.y>drawFromHeight)
			return;

		pos.y+=TREEVIEW_ROW_HEIGHT;
	}

	return;
}



int GuiProjectViewer::GuiProjectFileViewer::CalcNodesHeight(ResourceNodeDir* node)
{
	if(!node)
		return 0;

	return this->contentHeight=(node->dirs.size() + node->files.size())*TREEVIEW_ROW_HEIGHT;
}




void GuiProjectViewer::GuiProjectFileViewer::UnselectNodes(ResourceNodeDir* node)
{
	if(!node)
		return;

	node->selectedRight=false;

	for(std::list<ResourceNode*>::iterator nCh=node->files.begin();nCh!=node->files.end();nCh++)
		(*nCh)->selectedRight=0;

	for(std::list<ResourceNodeDir*>::iterator nCh=node->dirs.begin();nCh!=node->dirs.end();nCh++)
		this->UnselectNodes(*nCh);
}




ResourceNode* GuiProjectViewer::GuiProjectFileViewer::GetHoveredRow(ResourceNodeDir* iResourceNodeDirNode,vec2& iMousePos,vec2& iFramePos,bool& oExpandos)
{
	float drawFromHeight=this->scrollBar->scrollerPosition*this->contentHeight;

	for(std::list<ResourceNodeDir*>::iterator dir=iResourceNodeDirNode->dirs.begin();dir!=iResourceNodeDirNode->dirs.end();dir++)
	{
		if(iFramePos.y+TREEVIEW_ROW_HEIGHT>=drawFromHeight && iFramePos.y<=drawFromHeight+this->rect.w)
		{
			float relativeY=this->rect.y+iFramePos.y-drawFromHeight;

			ResourceNodeDir* node=(*dir);

			float xCursor=this->rect.x+TREEVIEW_ROW_ADVANCE*node->level;

			if(iMousePos.y>relativeY && iMousePos.y<relativeY+GuiSceneViewer::TREEVIEW_ROW_HEIGHT)
				return node;
		}

		iFramePos.y+=TREEVIEW_ROW_HEIGHT;
	}

	for(std::list<ResourceNode*>::iterator file=iResourceNodeDirNode->files.begin();file!=iResourceNodeDirNode->files.end();file++)
	{
		if(iFramePos.y+TREEVIEW_ROW_HEIGHT>=drawFromHeight && iFramePos.y<=drawFromHeight+this->rect.w)
		{
			float relativeY=this->rect.y+iFramePos.y-drawFromHeight;

			ResourceNode* node=(*file);

			float xCursor=this->rect.x+TREEVIEW_ROW_ADVANCE*node->level;

			if(iMousePos.y>relativeY && iMousePos.y<relativeY+GuiSceneViewer::TREEVIEW_ROW_HEIGHT)
				return node;

		}

		iFramePos.y+=TREEVIEW_ROW_HEIGHT;
	}

	return 0;
}
void GuiProjectViewer::GuiProjectFileViewer::OnLMouseDown(Tab* tabContainer,void* data)
{
	if(this->hovering)
	{
		vec2& mpos=*(vec2*)data;

		if(!InputManager::keyboardInput.IsPressed(0x11/*VK_CONTROL*/))
			this->selectedFiles.clear();

		vec2 tDrawCanvas(0,0);

		bool exp=false;
		ResourceNode* node=this->GetHoveredRow(this->rootResource,mpos,tDrawCanvas,exp);

		if(node)
		{
			this->UnselectNodes(this->rootResource);

			if(!node->selectedRight)
				node->selectedRight=true;

			if(exp)
			{
				this->CalcNodesHeight(this->rootResource);
				this->OnSize(tabContainer);
			}

			this->selectedFiles.push_back(node);

			//TabContainer::BroadcastToPool(&TabContainer::OnGuiEntitySelected,this->selection[0]);
		}	
		else
		{
			this->UnselectNodes(this->rootResource);
		}

		tabContainer->SetDraw(2,0,this);
	}

	GuiRect::OnLMouseDown(tabContainer,data);
}
void GuiProjectViewer::GuiProjectFileViewer::OnRMouseUp(Tab* tabContainer,void* data)
{
	GuiRect::OnRMouseUp(tabContainer,data);

	vec2& mpos=*(vec2*)data;

	vec2 tDrawCanvas(0,0);

	bool tHoveredResourceNodeExpandedPressed=false;
	ResourceNode* tHoveredResourceNode=this->GetHoveredRow(this->rootResource,mpos,tDrawCanvas,tHoveredResourceNodeExpandedPressed);

	int menuResult=tabContainer->TrackProjectFileViewerPopup(tHoveredResourceNode);

	switch(menuResult)
	{
		case 1:
			if(tHoveredResourceNode && tHoveredResourceNode->parent)
			{
				ResourceNodeDir* parentDirectory=(ResourceNodeDir*)tHoveredResourceNode->parent;

				if(tHoveredResourceNode->isDir)
					parentDirectory->dirs.remove((ResourceNodeDir*)tHoveredResourceNode);
				else
					parentDirectory->files.remove(tHoveredResourceNode);

				String tFileNameBase=tHoveredResourceNode->parent->fileName + "\\" + tHoveredResourceNode->fileName;
				String tFileNameBaseExtended=tFileNameBase + EngineIDE::instance->GetEntityExtension();

				File::Delete(tFileNameBase.Buffer());
				File::Delete(tFileNameBaseExtended.Buffer());
				
				SAFEDELETE(tHoveredResourceNode);
			}
		break;
		case 3://load 
			if(tHoveredResourceNode->fileName.Extension() == &EngineIDE::instance->GetSceneExtension()[1])
			{
				GuiSceneViewer* tGuiSceneViewer=GuiSceneViewer::GetPool().front();

				if(tGuiSceneViewer)
				{
					String tHoveredNodeFilename=tHoveredResourceNode->parent->fileName + "\\" + tHoveredResourceNode->fileName;

					tGuiSceneViewer->Load(tHoveredNodeFilename.Buffer());
					tGuiSceneViewer->GetRootRect()->tabContainer->SetDraw(2,0,tGuiSceneViewer);
				}
			}
		break;
	}

	this->OnSize(tabContainer);
	tabContainer->SetDraw(2,0,this);
}



void GuiProjectViewer::GuiProjectFileViewer::OnPaint(Tab* tabContainer,void* data)
{
	bool selfClip=this->BeginSelfClip(tabContainer);

	this->DrawBackground(tabContainer);

	tabContainer->renderer2D->PushScissor(this->rect.x,this->rect.y,this->rect.x+this->width,this->rect.y+this->rect.w);

	vec2 tDrawCanvas(0,0);

	this->DrawNodes(tabContainer,this->rootResource,tDrawCanvas);

	tabContainer->renderer2D->PopScissor();

	if(this->container!=0)
		this->BroadcastToChilds(&GuiRect::OnPaint,tabContainer,data);

	this->EndSelfClip(tabContainer,selfClip);
}

void GuiProjectViewer::GuiProjectFileViewer::OnDLMouseDown(Tab* tabContainer,void* data)
{
	if(this==tabContainer->GetFocus())
	{
		vec2& mpos=*(vec2*)data;

		vec2 tDrawCanvas(0,0);

		bool tHoveredResourceNodeExpandedPressed=false;
		ResourceNode* tHoveredResourceNode=this->GetHoveredRow(this->rootResource,mpos,tDrawCanvas,tHoveredResourceNodeExpandedPressed);

		if(tHoveredResourceNode)
		{
			String tExtension=tHoveredResourceNode->fileName.Extension();
			String tFilename=tHoveredResourceNode->parent->fileName + "\\" + tHoveredResourceNode->fileName;

			if(tExtension == &EngineIDE::instance->GetSceneExtension()[1])
			{
				Thread* renderThread=GuiViewport::GetPool()[0]->GetRootRect()->tabContainer->threadRender;
				Task* drawTask=GuiViewport::GetPool()[0]->GetRootRect()->tabContainer->taskDraw;
				
				drawTask->Block(true);

				GuiSceneViewer* guiSceneViewer=tabContainer->parentWindowContainer->SpawnViewer<GuiSceneViewer>();
				guiSceneViewer->Load(tFilename.Buffer());
				
				drawTask->Block(false);

				//guiSceneViewer->GetRootRect()->tabContainer->SetDraw(2,0,guiSceneViewer);
			}
			else if(tExtension=="cpp")
			{
				/*GuiScriptViewer* guiScriptViewer=tabContainer->parentWindowContainer->SpawnViewer<GuiScriptViewer>();
				guiScriptViewer->Open(tFilename);
				guiScriptViewer->GetRootRect()->tabContainer->SetDraw(2,0,guiScriptViewer);*/
			}
		}
	}

	GuiRect::OnDLMouseDown(tabContainer,data);
}

///////////////////////////////////////////////
///////////////////////////////////////////////
//////////////////////GuiImage/////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////
GuiImage::GuiImage():
width(0),
height(0),
bpp(0)
{}

GuiImage::~GuiImage()
{
	this->width=-1;
	this->height=-1;
	this->bpp=-1;
}

///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////DrawInstance/////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////


DrawInstance::DrawInstance(int iNoneAllRect,bool iFrame,GuiRect* iRect,const char* iName,bool iRemove):code(iNoneAllRect),frame(iFrame),rect(iRect),name(iName),remove(iRemove){}

///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////GuiScriptViewer/////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

GuiScriptViewer::GuiPaper::GuiPaper():lineCount(0),lineNumbers(true){}

void GuiScriptViewer::GuiPaper::DrawLineNumbers(Tab* tabContainer)
{
	float tTextHeight=tabContainer->renderer2D->GetFontHeight();
	float tRowY=this->rect.y;

	for(int i=0;i<this->lineCount;i++)
	{
		tabContainer->renderer2D->DrawText(String(i+1).Buffer(),this->rect.x,tRowY,this->rect.x + this->rect.z,tRowY + tTextHeight);
		tRowY+=tTextHeight;
	}
}

void GuiScriptViewer::GuiPaper::DrawBreakpoints(Tab* tabContainer)
{
	float tFontHeight=tabContainer->renderer2D->GetFontHeight();

	std::vector<Debugger::Breakpoint>& breakpoints=EngineIDE::instance->debugger->breakpointSet;

	for(size_t i=0;i<breakpoints.size();i++)
	{
		if(breakpoints[i].script==this->scriptViewer->script)
		{
			unsigned int tLineInsertion=this->rect.y + (breakpoints[i].line - 1) * tFontHeight;

			unsigned int tBreakColor = breakpoints[i].breaked ? 0xff0000 : 0xffff00 ;

			tabContainer->renderer2D->DrawRectangle(this->rect.x + 1,tLineInsertion + 1,this->rect.x+this->textOffset.x -1,tLineInsertion + tFontHeight - 1,tBreakColor,true);
		}
	}
}

void GuiScriptViewer::GuiPaper::OnPaint(Tab* tabContainer,void* data)
{
	bool selfClip=this->BeginSelfClip(tabContainer);

	this->DrawBackground(tabContainer);

	this->DrawBreakpoints(tabContainer);

	if(this->lineNumbers)
		this->DrawLineNumbers(tabContainer);

	this->DrawTheText(tabContainer,this->textOffset);

	if(this->container!=0)
		this->BroadcastToChilds(&GuiRect::OnPaint,tabContainer,data);

	this->EndSelfClip(tabContainer,selfClip);
}

void GuiScriptViewer::GuiPaper::OnLMouseDown(Tab* tabContainer,void* iData)
{
	GuiString::OnLMouseDown(tabContainer,iData);

	vec2 tMpos=*(vec2*)iData;

	tMpos.y=!this->clip ? tMpos.y : tMpos.y+this->clip->scrollBar->scrollerPosition*this->clip->contentHeight;

	if(tMpos.x < this->textOffset.x)
	{
		unsigned int tBreakOnLine=(tMpos.y-this->rect.y)/tabContainer->renderer2D->GetFontHeight() + 1;

		EditorScript* tEditorScript=(EditorScript*)this->scriptViewer->script;

		std::vector<Debugger::Breakpoint>& tAvailableBreakpoints=EngineIDE::instance->debugger->allAvailableBreakpoints;
		std::vector<Debugger::Breakpoint>& tBreakpoints=EngineIDE::instance->debugger->breakpointSet;

		for(size_t i=0;i<tAvailableBreakpoints.size();i++)
		{
			if(tAvailableBreakpoints[i].script==this->scriptViewer->script && tAvailableBreakpoints[i].line==tBreakOnLine)
			{
				std::vector<Debugger::Breakpoint>::iterator tFoundedBreakpointIterator=std::find(tBreakpoints.begin(),tBreakpoints.end(),tAvailableBreakpoints[i]);

				bool tAdd=tBreakpoints.end()==tFoundedBreakpointIterator;

				if(tAdd)
					tBreakpoints.push_back(tAvailableBreakpoints[i]);
				else
					tBreakpoints.erase(tFoundedBreakpointIterator);

				EngineIDE::instance->debugger->SetBreakpoint(tAvailableBreakpoints[i],tAdd);

				tabContainer->SetDraw(2,false,this->scriptViewer);

				break;
			}
		}
	}
}


GuiScriptViewer::GuiScriptViewer():
	script(0),
	cursor(0),
	row(0),
	col(0),
	lineNumbers(true)
{
	this->name="Script";

	this->paper=this->Create<GuiPaper>();
	this->paper->scriptViewer=this;
	this->paper->name="ScriptSource";
	this->paper->clipText=false;
	this->paper->SetClip(this);
	this->paper->textOffset.x=20;
}

void GuiScriptViewer::Open(Script* iScript)
{
	this->script=(EditorScript*)iScript;
	this->cursor=0;

	if(!iScript->script.IsOpen())
	{
		if(iScript->script.Open())
		{
			int size=iScript->script.Size();

			if(size>0)
			{
				char* buf=new char[size+1];
				iScript->script.Read(buf,size);
				buf[size]='\0';
				this->paper->text=buf;
				delete [] buf;
			}

			iScript->script.Close();
		}

		this->cursor=(char*)this->paper->text.c_str();
		this->row=0;
		this->col=0;

		this->SetCaretPosition(this->GetRootRect()->tabContainer,CARET_RECALC,0);
	}

	this->script->scriptViewer=this;
}

bool GuiScriptViewer::Save()
{
	if(this->script)
	{
		if(!File::Exist(this->script->script.path.Buffer()))
			File::Create(this->script->script.path.Buffer());

		if(this->script->script.Open("wb"))
		{
			this->script->script.Write((void*)this->paper->text.c_str(),this->paper->text.size(),1);

			this->script->script.Close();

			return true;
		}
		else
			DEBUG_BREAK();
	}

	return false;
} 


bool GuiScriptViewer::Compile()
{
	bool exited=false;
	bool compiled=false;
	bool runned=false;

	if(this->script)
	{
		exited=EngineIDE::instance->compiler->UnloadScript(this->script);

		compiled=EngineIDE::instance->compiler->Compile(this->script);

		runned=EngineIDE::instance->compiler->LoadScript(this->script);
	}

	return exited && compiled && runned;
}


vec4 GuiScriptViewer::GetCaretPosition(Tab* tabContainer,unsigned int iCaretOp,void* iParam)
{
	float tFontHeight=tabContainer->renderer2D->GetFontHeight();

	bool tRecalcSize=false;

	switch(iCaretOp)
	{
		case CARET_RECALC:
		{
			char*	pText=(char*)this->paper->text.c_str();

			bool tCarriageReturn=false;
			int tCharWidth=0;
			this->caret=vec4();

			this->caret.w=tFontHeight;

			while(*pText)
			{
				if(tCarriageReturn)
				{
					this->caret.y+=tFontHeight;
					this->caret.x=0;
					this->col=0;
					this->row+=1;

					tCarriageReturn=false;
				}

				tCharWidth=tabContainer->renderer2D->GetCharWidth(*pText);

				if(*pText=='\n' ||  *pText=='\r')
					tCarriageReturn=true;

				this->caret.z=tCharWidth;

				if(pText==this->cursor)
					break;

				this->caret.x+=tCharWidth;
				this->col+=1;

				pText++;
			}

			printf("cursor: %d,col: %d\n",this->cursor-this->paper->text.c_str(),this->col);

			break;
		}
		case CARET_CANCEL:
		{
			if(this->cursor==(char*)this->paper->text.back())
				return this->caret;

			this->paper->text.erase(this->cursor-(char*)this->paper->text.c_str(),1);

			--this->cursor;

			printf("cursor: %d,col: %d\n",this->cursor-this->paper->text.c_str(),this->col);
			
			break;
		}
		case CARET_BACKSPACE:
		{
			if(this->cursor==this->paper->text.c_str())
				return this->caret;

			char tCharCode=*(--this->cursor);

			if(tCharCode=='\n' ||  tCharCode=='\r')
			{
				//find previous row length
				char*			pText=this->cursor-1;
				unsigned int	tRowCharsWidth=0;
				unsigned int    tRowCharCount=0;

				while(*pText!='\n' &&  *pText!='\r')
				{
					tRowCharsWidth+=tabContainer->renderer2D->GetCharWidth(*pText);

					if(pText==(char*)this->paper->text.c_str())
						break;

					pText--;
					tRowCharCount++;
					
				}

				this->caret.x=tRowCharsWidth;
				this->caret.y-=tFontHeight;
				this->row--;
				this->col=tRowCharCount;

				tRecalcSize=true;
			}
			else
			{
				this->caret.x-=tabContainer->renderer2D->GetCharWidth(tCharCode);
				this->col--;
			}

			this->paper->text.erase(this->cursor-this->paper->text.c_str(),1);
			
			printf("cursor: %d,col: %d\n",this->cursor-this->paper->text.c_str(),this->col);
			
			break;
		}
		case CARET_ADD:
		{
			char tCharcode=*(char*)iParam;

			tCharcode=='\r' ? tCharcode='\n' : 0;

			if(tCharcode=='\n' || tCharcode=='\r')
			{
				this->caret.x=0;
				this->caret.y+=tFontHeight;
				this->row++;
				this->col=0;
				tRecalcSize=true;
			}
			else
			{
				this->caret.x+=tabContainer->renderer2D->GetCharWidth(tCharcode);
				this->col++;
			}

			size_t tPosition=this->cursor-this->paper->text.c_str();

			this->paper->text.insert(tPosition,1,tCharcode);
			this->cursor=(char*)this->paper->text.c_str()+tPosition+1;

			printf("cursor: %d,col: %d\n",this->cursor-this->paper->text.c_str(),this->col);
		
			break;
		}
		case CARET_ARROWLEFT:
		{
			if(this->cursor==this->paper->text.c_str())
				return this->caret;

			char tCharCode=*(--this->cursor);

			if(tCharCode=='\n' ||  tCharCode=='\r')
			{
				char*			pText=this->cursor;
				unsigned int	tRowLenght=0;
				unsigned int    tRowCharCount=0;

				//find previous row lengthc

				while(true)
				{
					if(this->cursor!=pText && (*pText=='\n' || *pText=='\r'))
						break;

					tRowLenght+=tabContainer->renderer2D->GetCharWidth(*pText);

					if(pText==this->paper->text.c_str())
						break;

					pText--;
					tRowCharCount++;
				}

				this->caret.x=tRowLenght;
				this->caret.y-=tFontHeight;
				this->row--;
				this->col=tRowCharCount;
			}
			else
			{
				this->caret.x-=tabContainer->renderer2D->GetCharWidth(tCharCode);
				this->col--;
			}

			printf("cursor: %d,col: %d\n",this->cursor-this->paper->text.c_str(),this->col);
		
			break;
		}
		case CARET_ARROWRIGHT:
		{
			char tCharCode=*this->cursor;

			if(tCharCode=='\n' || tCharCode=='\r')
			{
				this->caret.x=0;
				this->caret.y+=tFontHeight;
				this->row++;
				this->col=0;
			}
			else
			{
				this->caret.x+=tabContainer->renderer2D->GetCharWidth(tCharCode);
				this->col++;
			}

			this->cursor++;

			printf("cursor: %d,col: %d\n",this->cursor-this->paper->text.c_str(),this->col);
		
			break;
		}
		case CARET_ARROWUP:
		{
			unsigned int tRowCharWidth=0;
			unsigned int tColumn=0;

			//---find current rowhead

			char* pText=this->cursor;

			//skip the tail of the current row if present
			if(*pText=='\r' || *pText=='\n')
				pText--;

			//find the last upper row or the head of the current row
			while( pText!=this->paper->text.c_str() && *pText!='\r' &&  *pText!='\n' )
				pText--;

			//return if no previous row exists
			if(pText==this->paper->text.c_str())
				return this->caret; 

			//go to the upper row pre-carriage char 
			pText--;

			//find the last upper superior row or the head of the upper row
			while( pText!=this->paper->text.c_str() && *pText!='\r' &&  *pText!='\n' )
				pText--;

			//go to the upper superior row pre-carriage char 
			if(pText!=this->paper->text.c_str())
				pText++;

			//finally found the upper matching position
			while( tColumn!=this->col && *pText!='\0' && *pText!='\r' && *pText!='\n' )
			{
				tRowCharWidth+=tabContainer->renderer2D->GetCharWidth(*pText);

				pText++;
				tColumn++;
			}

			this->cursor=pText;
			this->caret.x=tRowCharWidth;
			this->caret.y-=tFontHeight;
			this->col=tColumn;
			this->row--;

			printf("cursor: %d,col: %d\n",this->cursor-this->paper->text.c_str(),this->col);
		
			break;
		}
		case CARET_ARROWDOWN:
		{
			unsigned int tRowCharWidth=0;
			unsigned int tColumn=0;

			//find current rowtail

			char* pText=this->cursor;

			while( *pText!='\0' && *pText!='\r' && *pText!='\n' )
			{
				this->cursor++;
				pText++;
			}

			if(*pText=='\0')
				return this->caret; //no previous row exists

			pText++;
			this->cursor++;

			//finally found the lower matching position

			while( tColumn!=this->col && *pText!='\0' && *pText!='\r' && *pText!='\n' )
			{
				tRowCharWidth+=tabContainer->renderer2D->GetCharWidth(*pText);

				pText++;
				this->cursor++;
				tColumn++;
			}

			/*if(tColumn!=this->col)//string is shorter of the lower matching position
				tRowCharWidth*/

			this->caret.x=tRowCharWidth;
			this->caret.y+=tFontHeight;
			this->col=tColumn;
			this->row++;

			printf("cursor: %d,col: %d\n",this->cursor-this->paper->text.c_str(),this->col);
		
			break;
		}
	}

	if(tRecalcSize)
		this->OnSize(tabContainer);

	return this->caret;
}

void GuiScriptViewer::OnKeyDown(Tab* tabContainer,void* iData)
{
	if(this->script)
	{
		unsigned int	tCaretOperation=CARET_DONTCARE;
		void*			tCaretParameter=0;
		char			tCharcode;

		bool			tRedraw=false;

		if(iData)
		{
			if(InputManager::keyboardInput.IsPressed(0x11/*VK_CONTROL*/) && !InputManager::keyboardInput.IsPressed(0x12/*VK_ALT*/))
			{
				if(InputManager::keyboardInput.IsPressed('S'))
				{
					this->Save();
				}
			}
			else
			{
				tCharcode=*(int*)iData;

				switch(tCharcode)
				{
					case 0x08:/*VK_BACK*/tCaretOperation=CARET_BACKSPACE; break;
					default: 
						tCaretOperation=CARET_ADD;
						tCaretParameter=&tCharcode;
				}

				tRedraw=true;
			}
		}
		else
		{
			if(InputManager::keyboardInput.IsPressed(0x25/*VK_LEFT*/))
				tCaretOperation=CARET_ARROWLEFT;
			if(InputManager::keyboardInput.IsPressed(0x27/*VK_RIGHT*/))
				tCaretOperation=CARET_ARROWRIGHT;
			if(InputManager::keyboardInput.IsPressed(0x26/*VK_UP*/))
				tCaretOperation=CARET_ARROWUP;
			if(InputManager::keyboardInput.IsPressed(0x28/*VK_DOWN*/))
				tCaretOperation=CARET_ARROWDOWN;
			if(InputManager::keyboardInput.IsPressed(0x03/*VK_CANCEL*/))
				tCaretOperation=CARET_CANCEL;

			if(InputManager::keyboardInput.IsPressed(0x74/*VK_F5*/))
				EngineIDE::instance->debugger->ContinueDebuggee();

			tRedraw=true;
		}

		this->SetCaretPosition(tabContainer,tCaretOperation,tCaretParameter);

		if(tRedraw)
			tabContainer->SetDraw(2,0,this);
	}

	GuiRect::OnKeyDown(tabContainer,iData);
}

void GuiScriptViewer::OnKeyUp(Tab* tabContainer,void* data)
{
	GuiRect::OnKeyUp(tabContainer,data);
}

void GuiScriptViewer::OnLMouseDown(Tab* tabContainer,void* iData)
{
	GuiRect::OnLMouseDown(tabContainer,iData);

	vec2 tMpos=*(vec2*)iData;

	this->SetCaretPosition(tabContainer,CARET_MOUSEPOS,0);
	tabContainer->SetFocus(this->paper);
	tabContainer->renderer2D->caret->enable(true);
}

void GuiScriptViewer::OnDeactivate(Tab* tabContainer,void* data)
{
	tabContainer->SetFocus(0);
	tabContainer->renderer2D->caret->enable(false);

	GuiRect::OnDeactivate(tabContainer,data);
}

void GuiScriptViewer::OnMouseMove(Tab* tabContainer,void* data)
{
	GuiRect::OnMouseMove(tabContainer,data);

	if(this->hovering)
	{
		vec2 tMpos=*(vec2*)data;

		if(tMpos.x < this->paper->textOffset.x)
		{
			
		}
		else
		{

		}
	}
}

void GuiScriptViewer::OnSize(Tab* tabContainer,void* data)
{
	if(!this->paper->text.empty())
	{
		this->paper->lineCount=this->CountScriptLines()-1;

		float tFontHeight=tabContainer->renderer2D->GetFontHeight();

		this->contentHeight=this->paper->lineCount * tFontHeight;
	}

	GuiScrollRect::OnSize(tabContainer,data);
}


int GuiScriptViewer::CountScriptLines()
{
	char* t=(char*)this->paper->text.c_str();

	int tLinesCount=!(*t) ? 0 : 1;

	while(*t)
	{
		if(*t=='\n' || *t=='\r')
			tLinesCount++;

		t++;
	}

	return tLinesCount;
}

void GuiScriptViewer::SetCaretPosition(Tab* tabContainer,unsigned int iCaretOp,void* iParam)
{
	this->caret=GetCaretPosition(tabContainer,iCaretOp,iParam);

	vec4 tCaret(this->caret);

	tCaret.x+=this->paper->rect.x+this->paper->textOffset.x;
	tCaret.y+=this->paper->rect.y+this->paper->textOffset.y;

	tabContainer->renderer2D->caret->set(this->paper,vec2(tCaret.x,tCaret.y),vec2(tCaret.z,tCaret.w));
}

///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////GuiCompilerViewer///////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

GuiCompilerViewer::GuiCompilerViewer(){this->name="Compiler";}

wchar_t* nthOccurrenceInLine(wchar_t* iStr,char iChar,int iNth)
{
	wchar_t* str=iStr;
	int occurr=0;

	char c=*str;

	while(c!='\0' || c!='\n')
	{
		if(c==iChar)
		{
			if(++occurr==iNth)
				return str;
		}

		c=*(++str);
	}

	return 0;
}


bool GuiCompilerViewer::ParseCompilerOutputFile(wchar_t* fileBuffer)
{
	bool bReturnValue=true;

	this->scrollBar->SetParent(0);

	this->DestroyChilds();

	GuiRect* messagesGlue=this->Create<GuiRect>();

	const int MESSAHE_ROW_HEIGHT=20;

	if(fileBuffer)
	{
		wchar_t* LineBegin=fileBuffer;
		wchar_t* FileEnd=LineBegin;
		while(*FileEnd++);

		while(LineBegin!=FileEnd-1)
		{
			wchar_t* LineEnd=wcschr(LineBegin,'\n');

			wchar_t* compileError=wcsstr(LineBegin,L"error C");
			wchar_t* linkError=wcsstr(LineBegin,L"error LNK");

			compileError!=0 && LineEnd < compileError ? compileError=0 : 0;
			linkError!=0 && LineEnd < linkError ? linkError=0 : 0;

			bool simpleMessage=!compileError && !linkError;

			GuiString* tCompilerMessageRow=new GuiString;

			{
				tCompilerMessageRow->fixed.w=MESSAHE_ROW_HEIGHT;
				tCompilerMessageRow->alignRect.y=-1;
				tCompilerMessageRow->alignText.make(-1,0.5f);
			}
			
			if(simpleMessage)
			{
				tCompilerMessageRow->wText=std::wstring(LineBegin,LineEnd-LineBegin);
			}
			else
			{
				bReturnValue=false;

				wchar_t* FileEnd=nthOccurrenceInLine(LineBegin,':', compileError ? 2 : 1);//the first : should be the volume drive

				if(FileEnd)
					FileEnd+=2;

				wchar_t* ErrorEnd=nthOccurrenceInLine(FileEnd,':',1);

				if(ErrorEnd)
					ErrorEnd+=2;

				tCompilerMessageRow->wText=/*std::wstring(LineBegin,FileEnd-LineBegin)*/std::wstring(FileEnd,ErrorEnd-FileEnd).append(std::wstring(ErrorEnd,LineEnd-ErrorEnd));
				tCompilerMessageRow->colorBackground=0xff0000;
			}

			messagesGlue->AppendChild(tCompilerMessageRow);

			LineBegin=++LineEnd;
		}

		this->scrollBar->SetParent(this);

		this->contentHeight=messagesGlue->childs.size()*MESSAHE_ROW_HEIGHT;

		messagesGlue->SetClip(this);

	}

	return bReturnValue;
}


void GuiCompilerViewer::OnSize(Tab* tabContainer,void* data)
{
	this->scrollBar->SetScrollerRatio(this->contentHeight,this->rect.w);

	if(this->childs.size()==2)
		//we don't need the GuiScrollRect::width cause the newly GuiRect::offset
		this->scrollBar->IsVisible() ? this->childs[0]->offset.z=-GuiScrollBar::SCROLLBAR_WIDTH : this->childs[0]->offset.z=0;

	GuiRect::OnSize(tabContainer,data);

	this->width=this->rect.z;
}


///////////////////////////////////////////////
///////////////////////////////////////////////
/////////////////Properties////////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

#define __APPENDPROPERTYTOENTITY()	EditorEntity* eEntity=(EditorEntity*)this->entity; \
										eEntity->properties.AppendChild(&this->properties); /*\
										Tab::BroadcastToPool(&Tab::OnGuiEntitySelected,this->entity);*/



void EditorEntity::OnPropertiesCreate()
{
	std::vector<GuiRect*> lvl(2);

	lvl[0]=this->properties.Container("Entity");
	lvl[0]->Property("Name",&this->name,GuiPropertyString::STRING);
	lvl[0]->Property("Ptr",this,GuiPropertyString::PTR);
	lvl[0]->Property("Position",&this->world,GuiPropertyString::MAT4POS);
	lvl[1]=lvl[0]->Container("AABB");
	lvl[1]->Property("min",this->bbox.a,GuiPropertyString::VEC3);
	lvl[1]->Property("max",this->bbox.b,GuiPropertyString::VEC3);
	lvl[1]->Property("Volume",this->bbox.b-this->bbox.a,GuiPropertyString::VEC3);
	lvl[0]->Property("Childs",&this->childs,GuiPropertyString::ENTITYVECSIZE);
}

void EditorEntity::OnPropertiesUpdate(Tab* tab)
{
	for(std::vector<EntityComponent*>::iterator it=this->components.begin();it!=this->components.end();it++)
	{
		EditorProperties* componentProperties=dynamic_cast<EditorProperties*>(*it);
		if(componentProperties)
			componentProperties->OnPropertiesUpdate(tab);
	}
}

/*
void EditorEntity::update()
{
	for(std::vector<EntityComponent*>::iterator it=this->components.begin();it!=this->components.end();it++)
	{
		(*it)->update();

	}

	this->parent ? this->world=(this->local * this->parent->world) : this->world;

	for(std::list<Entity*>::iterator it=this->childs.begin();it!=this->childs.end();it++)
		(*it)->update();
}*/

void EditorMesh::OnPropertiesCreate()
{
	this->properties.text="Mesh";
	this->properties.Property("Controlpoints",&this->ncontrolpoints,GuiPropertyString::INT);
	this->properties.Property("Normals",&this->nnormals,GuiPropertyString::INT);
	this->properties.Property("Polygons",&this->npolygons,GuiPropertyString::INT);
	this->properties.Property("Texcoord",&this->ntexcoord,GuiPropertyString::INT);
	this->properties.Property("Vertexindices",&this->nvertexindices,GuiPropertyString::INT);

	__APPENDPROPERTYTOENTITY();
}

void EditorMesh::OnPropertiesUpdate(Tab* tab)
{
}

void EditorSkin::OnPropertiesCreate()
{
	this->properties.text="Skin";
	this->properties.Property("Clusters",&this->nclusters,GuiPropertyString::INT);
	this->properties.Property("Textures",&this->ntextures,GuiPropertyString::INT);

	__APPENDPROPERTYTOENTITY();
}
void EditorSkin::OnPropertiesUpdate(Tab* tab)
{
}
void EditorRoot::OnPropertiesCreate()
{
	this->properties.text="Root";

	__APPENDPROPERTYTOENTITY();
}
void EditorRoot::OnPropertiesUpdate(Tab* tab)
{
}
void EditorSkeleton::OnPropertiesCreate()
{
	this->properties.text="Skeleton";

	__APPENDPROPERTYTOENTITY();
}
void EditorSkeleton::OnPropertiesUpdate(Tab* tab)
{
}
void EditorGizmo::OnPropertiesCreate()
{
	this->properties.text="Gizmo";

	__APPENDPROPERTYTOENTITY();
}
void EditorGizmo::OnPropertiesUpdate(Tab* tab)
{
}
void EditorAnimation::OnPropertiesCreate()
{
	this->properties.text="Animation";
	this->properties.Property("IsBone",this,GuiPropertyString::ISBONECOMPONENT);
	this->properties.Property("Duration",&this->start,GuiPropertyString::FLOAT2MINUSFLOAT1,&this->end);
	this->properties.Property("Begin",&this->start,GuiPropertyString::FLOAT);
	this->properties.Property("End",&this->end,GuiPropertyString::FLOAT);

	__APPENDPROPERTYTOENTITY();
}
void EditorAnimation::OnPropertiesUpdate(Tab* tab)
{
}
void EditorAnimationController::OnPropertiesCreate()
{
	this->properties.text="AnimationController";
	this->properties.Property("Number of nodes",&this->animations,GuiPropertyString::ANIMATIONVECSIZE);
	this->properties.SliderProperty("Velocity",this->speed,this->start,this->end);
	this->properties.Property("Duration",&this->start,GuiPropertyString::FLOAT2MINUSFLOAT1,&this->end);
	this->properties.Property("Begin",&this->start,GuiPropertyString::FLOAT);
	this->properties.Property("End",&this->end,GuiPropertyString::FLOAT);
	guiPropertyAnimationController=this->properties.AnimationControllerProperty(*this);

	__APPENDPROPERTYTOENTITY();
}

void EditorAnimationController::OnPropertiesUpdate(Tab* tab)
{
	if(this->oldCursor!=this->cursor)
		tab->SetDraw(2,0,&guiPropertyAnimationController->guiAnimationController.slider);

	this->oldCursor=this->cursor;
}



void EditorBone::OnPropertiesCreate()
{
	this->properties.text="Bone";

	__APPENDPROPERTYTOENTITY();
}
void EditorBone::OnPropertiesUpdate(Tab* tab)
{
}
void EditorLight::OnPropertiesCreate()
{
	this->properties.text="Light";

	__APPENDPROPERTYTOENTITY();
}
void EditorLight::OnPropertiesUpdate(Tab* tab)
{
}

void editScriptEditorCallback(void* iData)
{
	EditorScript* editorScript=(EditorScript*)iData;

	Tab* tabContainer=EngineIDE::instance->mainAppWindow->containers[0]->tabContainers[0];

	if(!tabContainer)
		DEBUG_BREAK();

	if(GuiScriptViewer::GetPool().empty())
		tabContainer->tabs.ScriptViewer();
	
	GuiScriptViewer* guiScriptViewer=GuiScriptViewer::GetPool().front();

	if(guiScriptViewer)
	{
		guiScriptViewer->Open(editorScript);
		tabContainer->SetDraw(0,1);
	}
}

void compileScriptEditorCallback(void* iData)
{
	EditorScript* editorScript=(EditorScript*)iData;

    EngineIDE::instance->compiler->Compile(editorScript);
}

void launchStopScriptEditorCallback(void* iData)
{
	EditorScript* editorScript=(EditorScript*)iData;

	if(editorScript->runtime)
	{
		if(EngineIDE::instance->compiler->UnloadScript(editorScript))
			editorScript->buttonLaunch->text="Launch";
	}
	else
	{
		if(EngineIDE::instance->compiler->LoadScript(editorScript))
			editorScript->buttonLaunch->text="Stop";
	}

	editorScript->properties.GetRootRect()->tabContainer->SetDraw(2,0,editorScript->buttonLaunch);
}

EditorScript::EditorScript():scriptViewer(0)
{

};

void EditorScript::OnPropertiesCreate()
{
	this->properties.text="Script";
	GuiRect* fileProp=this->properties.Property("File",&this->Script::script.path,GuiPropertyString::STRING);
	this->properties.Property("Running",&this->Script::runtime,GuiPropertyString::BOOL);

	GuiButtonFunc* buttonEdit=new GuiButtonFunc;
	buttonEdit->name="EditorScript Edit Button";
	this->properties.AppendChild(buttonEdit);
	buttonEdit->func=editScriptEditorCallback;
	buttonEdit->param=this;
	//buttonEdit->colorBackground=Renderer2DInterface::COLOR_GUI_BACKGROUND;
	buttonEdit->colorHovering=Renderer2D::COLOR_GUI_BACKGROUND+30;
	buttonEdit->colorPressing=Renderer2D::COLOR_GUI_BACKGROUND+90;
	buttonEdit->text="Edit";
	buttonEdit->fixed.w=20;
	buttonEdit->alignRect.make(1,-1);

	GuiButtonFunc* buttonCompile=new GuiButtonFunc;
	this->properties.AppendChild(buttonCompile);
	buttonCompile->func=compileScriptEditorCallback;
	buttonCompile->param=this;
	buttonCompile->colorHovering=Renderer2D::COLOR_GUI_BACKGROUND+30;
	buttonCompile->colorPressing=Renderer2D::COLOR_GUI_BACKGROUND+90;
	buttonCompile->text="Compile";
	buttonCompile->fixed.w=20;
	buttonCompile->alignRect.make(1,-1);

	this->buttonLaunch=new GuiButtonFunc;
	this->properties.AppendChild(buttonLaunch);
	this->buttonLaunch->func=launchStopScriptEditorCallback;
	this->buttonLaunch->param=this;
	this->buttonLaunch->colorHovering=Renderer2D::COLOR_GUI_BACKGROUND+30;
	this->buttonLaunch->colorPressing=Renderer2D::COLOR_GUI_BACKGROUND+90;
	this->buttonLaunch->text="Launch";
	this->buttonLaunch->fixed.w=20;
	this->buttonLaunch->alignRect.make(1,-1);

	__APPENDPROPERTYTOENTITY();
}
void EditorScript::OnPropertiesUpdate(Tab* tab)
{
}

void EditorScript::OnResourcesCreate()
{
	String tFileNamePath=EngineIDE::instance->projectFolder + "\\" + this->entity->name;
	this->script.SetFilename(tFileNamePath + ".cpp");

	if(!File::Exist(this->script.path.Buffer()))
	{
		if(!File::Create(this->script.path.Buffer()))
			DEBUG_BREAK();

		if(this->script.Open("wb"))
		{
			String content="#include \"entities.h\"\n\nstruct " + this->entity->name + "_ : EntityScript\n{\n\t int counter;\n\tvoid init()\n\t{\n\t\tcounter=0;\n\tthis->entity->local.identity();\n\t\tprintf(\"inited\\n\");\n\t}\n\n\tvoid update()\n\t{\n\t\tthis->entity->local.translate(0.1f,0,0);\n\t//printf(\"counter: %d\\n\",counter);\n\tcounter++;\n\t}\n\n\tvoid deinit()\n\t{\n\t\tprintf(\"deinited\\n\");\n\t}\n\n};\n";
			int contantCount=content.Count();

			this->script.Write((void*)content.Buffer(),contantCount,1);
			this->script.Close();
		}
	}
}

void EditorCamera::OnPropertiesCreate()
{
	this->properties.text="Camera";

	__APPENDPROPERTYTOENTITY();
}
void EditorCamera::OnPropertiesUpdate(Tab* tab)
{
}


///////////////////////////////////////////////
///////////////////////////////////////////////
/////////////////FileSystem////////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

bool FileExists(const char* iFile)
{
	FILE* tFile=fopen(iFile,"rb");

	if(tFile)
	{
		return true;
		fclose(tFile);
	}

	return false;
}