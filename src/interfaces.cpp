#include "interfaces.h"

#include "imgpng.h"
#include "imgjpg.h"
#include "imgtga.h"


///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////////AppInterface////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

Ide::Ide():
	timerMain(0),
	mainAppWindow(0),
	compiler(0),
	processId(0),
	processThreadId(0),
	stringEditor(0)
{}

String Ide::GetSceneExtension()
{
	return L".engineScene";
}
String Ide::GetEntityExtension()
{
	return L".engineEntity";
}

///////////////////////////////////////////////
///////////////////////////////////////////////
///////////EditorWindowContainer///////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

Container::Container()
{
	resizeDiffHeight=0;
	resizeDiffWidth=0;
	resizeEnumType=-1;
	resizeCheckWidth=0;
	resizeCheckHeight=0;
}

///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////////Debugger//////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////
Debugger::Debugger():breaked(false),threadSuspendend(false),runningScript(0),runningScriptFunction(0),debuggerCode(0),lastBreakedAddress(0){}


///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////////TouchInput//////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

TouchInput::TouchInput()
{
	for(int i=0;i<10;i++)
	{
		pressed[i]=0;
		released[i]=0;
		position[i].make(0,0);
	}
}

bool TouchInput::IsPressed(int i){return pressed[i];}
bool TouchInput::IsReleased(int i){return released[i];}

void TouchInput::SetPressed(bool b,int i){pressed[i]=b;}
void TouchInput::SetReleased(bool b,int i){released[i]=b;}


vec2& TouchInput::GetPosition(int i){return position[i];}
void   TouchInput::SetPosition(vec2& pos,int i){position[i]=pos;}

MouseInput::MouseInput()
{}

bool MouseInput::Left(){return this->left;}
bool MouseInput::Right(){return this->right;}
bool MouseInput::Middle(){return this->middle;}

TouchInput InputManager::touchInput;
MouseInput InputManager::mouseInput;
KeyboardInput InputManager::keyboardInput;

/*
InputInterface InputManager::voiceInput;
InputInterface InputManager::joystickInput;*/


///////////////////////////////////////////////
///////////////////////////////////////////////
//////////////////TabContainer/////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

unsigned char Tab::rawUpArrow[]={0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0xa7,0x0,0x0,0x0,0xa8,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x87,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0x88,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6a,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0x6b,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4b,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0x4c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2b,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xfe,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xfe,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0x2c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xb,0x0,0x0,0x0,0xfa,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xfb,0x0,0x0,0x0,0xc,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7,0x0,0x0,0x0,0xdc,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xdc,0x0,0x0,0x0,0x7,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc,0x0,0x0,0x0,0xe7,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xe7,0x0,0x0,0x0,0xc,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0};
unsigned char Tab::rawRightArrow[]={0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc,0x0,0x0,0x0,0x7,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe7,0x0,0x0,0x0,0xdc,0x0,0x0,0x0,0xb,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xfa,0x0,0x0,0x0,0x2b,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0x4b,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xfe,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0x6a,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0x87,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xa7,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xa8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0x88,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xfe,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0x6b,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0x4c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xfb,0x0,0x0,0x0,0x2c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe7,0x0,0x0,0x0,0xdc,0x0,0x0,0x0,0xc,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc,0x0,0x0,0x0,0x7,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0};
unsigned char Tab::rawLeftArrow[]={0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x07,0x0,0x0,0x0,0x0c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0c,0x0,0x0,0x0,0xdc,0x0,0x0,0x0,0xe7,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2c,0x0,0x0,0x0,0xfb,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4c,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6b,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xfe,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x01,0x0,0x0,0x0,0x88,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa8,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa7,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x01,0x0,0x0,0x0,0x87,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6a,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xfe,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4b,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2b,0x0,0x0,0x0,0xfa,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0b,0x0,0x0,0x0,0xdc,0x0,0x0,0x0,0xe7,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x07,0x0,0x0,0x0,0x0c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0};
unsigned char Tab::rawDownArrow[]={0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc,0x0,0x0,0x0,0xe7,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xef,0x0,0x0,0x0,0xe7,0x0,0x0,0x0,0xc,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7,0x0,0x0,0x0,0xdc,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xdc,0x0,0x0,0x0,0x7,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc,0x0,0x0,0x0,0xfb,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xfa,0x0,0x0,0x0,0xb,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2c,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xfe,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xfe,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0x2b,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4c,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0x4b,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6b,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0x6a,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x88,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0x87,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0xa8,0x0,0x0,0x0,0xa7,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0};
unsigned char Tab::rawFolder[]={0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe6,0xc1,0x9b,0x12,0xe9,0xc4,0x9f,0xd8,0xe9,0xc4,0xa0,0xff,0xe9,0xc4,0xa0,0xff,0xe9,0xc4,0xa0,0xff,0xe9,0xc4,0xa0,0xff,0xe9,0xc4,0xa0,0xff,0xe6,0xc0,0x9a,0x5b,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe5,0xc1,0x9e,0x20,0xe5,0xc2,0x9e,0xef,0xe5,0xc2,0x9e,0xff,0xe5,0xc2,0x9e,0xff,0xe5,0xc2,0x9d,0xff,0xe5,0xc2,0x9d,0xff,0xe5,0xc2,0x9d,0xff,0xe4,0xc2,0x9c,0xa6,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe3,0xbe,0x98,0x21,0xdf,0xb9,0x94,0xee,0xdf,0xb9,0x93,0xff,0xdf,0xb9,0x93,0xff,0xde,0xb9,0x92,0xff,0xde,0xb9,0x93,0xff,0xde,0xb9,0x93,0xff,0xdd,0xb7,0x90,0xe4,0xda,0xb2,0x89,0xa2,0xda,0xb2,0x8a,0xa3,0xda,0xb2,0x8a,0xa3,0xda,0xb2,0x8a,0xa3,0xda,0xb2,0x8a,0x86,0xe6,0xc1,0x97,0xf,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfb,0xda,0xaf,0xd2,0xf7,0xd6,0xab,0xfd,0xf7,0xd6,0xab,0xff,0xf7,0xd6,0xab,0xff,0xf7,0xd6,0xab,0xff,0xf6,0xd6,0xab,0xff,0xf6,0xd6,0xab,0xff,0xf6,0xd6,0xab,0xff,0xf6,0xd5,0xab,0xff,0xf6,0xd5,0xab,0xff,0xf6,0xd5,0xab,0xff,0xf6,0xd5,0xab,0xff,0xf6,0xd5,0xab,0xff,0xfa,0xda,0xaf,0xd7,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf7,0xd5,0xaa,0xff,0xf7,0xd5,0xaa,0xff,0xf7,0xd5,0xaa,0xff,0xf7,0xd5,0xaa,0xff,0xf7,0xd5,0xaa,0xff,0xf7,0xd5,0xaa,0xff,0xf7,0xd5,0xaa,0xff,0xf7,0xd5,0xaa,0xff,0xf7,0xd5,0xaa,0xff,0xf7,0xd5,0xaa,0xff,0xf7,0xd5,0xaa,0xff,0xf7,0xd5,0xaa,0xff,0xf7,0xd5,0xaa,0xff,0xf7,0xd5,0xaa,0xff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf3,0xcf,0xa3,0xff,0xf3,0xcf,0xa3,0xff,0xf3,0xcf,0xa3,0xff,0xf3,0xcf,0xa3,0xff,0xf3,0xcf,0xa3,0xff,0xf3,0xcf,0xa3,0xff,0xf3,0xcf,0xa3,0xff,0xf3,0xcf,0xa3,0xff,0xf3,0xcf,0xa3,0xff,0xf3,0xcf,0xa3,0xff,0xf3,0xcf,0xa3,0xff,0xf3,0xcf,0xa3,0xff,0xf3,0xcf,0xa3,0xff,0xf3,0xcf,0xa3,0xff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xee,0xc8,0x9b,0xff,0xee,0xc8,0x9b,0xff,0xee,0xc8,0x9b,0xff,0xee,0xc8,0x9b,0xff,0xee,0xc8,0x9b,0xff,0xee,0xc8,0x9b,0xff,0xee,0xc8,0x9b,0xff,0xee,0xc8,0x9b,0xff,0xee,0xc8,0x9b,0xff,0xee,0xc8,0x9b,0xff,0xee,0xc8,0x9b,0xff,0xee,0xc8,0x9b,0xff,0xee,0xc8,0x9b,0xff,0xee,0xc8,0x9b,0xff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xea,0xc2,0x95,0xff,0xea,0xc2,0x95,0xff,0xea,0xc2,0x95,0xff,0xea,0xc2,0x95,0xff,0xea,0xc2,0x95,0xff,0xea,0xc2,0x95,0xff,0xea,0xc2,0x95,0xff,0xea,0xc2,0x95,0xff,0xea,0xc2,0x95,0xff,0xea,0xc2,0x95,0xff,0xea,0xc2,0x95,0xff,0xea,0xc2,0x95,0xff,0xea,0xc2,0x95,0xff,0xea,0xc2,0x95,0xff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe5,0xbb,0x8e,0xff,0xe5,0xbb,0x8e,0xff,0xe5,0xbb,0x8e,0xff,0xe5,0xbb,0x8e,0xff,0xe5,0xbb,0x8e,0xff,0xe5,0xbb,0x8e,0xff,0xe5,0xbb,0x8e,0xff,0xe5,0xbb,0x8e,0xff,0xe5,0xbb,0x8e,0xff,0xe5,0xbb,0x8e,0xff,0xe5,0xbb,0x8e,0xff,0xe5,0xbb,0x8e,0xff,0xe5,0xbb,0x8e,0xff,0xe5,0xbb,0x8e,0xff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe1,0xb6,0x87,0xff,0xe1,0xb6,0x87,0xff,0xe1,0xb6,0x87,0xff,0xe1,0xb6,0x87,0xff,0xe1,0xb6,0x87,0xff,0xe1,0xb6,0x87,0xff,0xe1,0xb6,0x87,0xff,0xe1,0xb6,0x87,0xff,0xe1,0xb6,0x87,0xff,0xe1,0xb6,0x87,0xff,0xe1,0xb6,0x87,0xff,0xe1,0xb6,0x87,0xff,0xe1,0xb6,0x87,0xff,0xe1,0xb6,0x87,0xff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xdc,0xb0,0x7f,0xff,0xdc,0xb0,0x7f,0xff,0xdc,0xb0,0x7f,0xff,0xdc,0xb0,0x7f,0xff,0xdc,0xb0,0x7f,0xff,0xdc,0xb0,0x7f,0xff,0xdc,0xb0,0x7f,0xff,0xdc,0xb0,0x7f,0xff,0xdc,0xb0,0x7f,0xff,0xdc,0xb0,0x7f,0xff,0xdc,0xb0,0x7f,0xff,0xdc,0xb0,0x7f,0xff,0xdc,0xb0,0x7f,0xff,0xdc,0xb0,0x7f,0xff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xd8,0xa9,0x78,0xff,0xd8,0xa9,0x78,0xff,0xd8,0xa9,0x78,0xff,0xd8,0xa9,0x78,0xff,0xd8,0xa9,0x78,0xff,0xd8,0xa9,0x78,0xff,0xd8,0xa9,0x78,0xff,0xd8,0xa9,0x78,0xff,0xd8,0xa9,0x78,0xff,0xd8,0xa9,0x78,0xff,0xd8,0xa9,0x78,0xff,0xd8,0xa9,0x78,0xff,0xd8,0xa9,0x78,0xff,0xd8,0xa9,0x78,0xff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xd3,0xa3,0x71,0xff,0xd3,0xa3,0x71,0xff,0xd3,0xa3,0x71,0xff,0xd3,0xa3,0x71,0xff,0xd3,0xa3,0x71,0xff,0xd3,0xa3,0x71,0xff,0xd3,0xa3,0x71,0xff,0xd3,0xa3,0x71,0xff,0xd3,0xa3,0x71,0xff,0xd3,0xa3,0x71,0xff,0xd3,0xa3,0x71,0xff,0xd3,0xa3,0x71,0xff,0xd3,0xa3,0x71,0xff,0xd3,0xa3,0x71,0xff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc9,0x96,0x64,0xe7,0xca,0x97,0x65,0xff,0xca,0x97,0x65,0xff,0xca,0x97,0x65,0xff,0xca,0x97,0x65,0xff,0xca,0x97,0x65,0xff,0xca,0x97,0x65,0xff,0xca,0x97,0x65,0xff,0xca,0x97,0x65,0xff,0xca,0x97,0x65,0xff,0xca,0x97,0x65,0xff,0xca,0x97,0x65,0xff,0xca,0x97,0x65,0xff,0xc9,0x97,0x64,0xf1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0};
unsigned char Tab::rawFile[]={0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc8,0xc8,0xc8,0x4c,0xe0,0xe0,0xe0,0xcd,0xe1,0xe1,0xe1,0xc0,0xe1,0xe1,0xe1,0xbf,0xe1,0xe1,0xe1,0xbf,0xe1,0xe1,0xe1,0xbf,0xe1,0xe1,0xe1,0xc0,0xd6,0xd6,0xd6,0xc4,0xbd,0xbd,0xbd,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc5,0xc5,0xc5,0x70,0xec,0xec,0xec,0xff,0xed,0xed,0xed,0xff,0xed,0xed,0xed,0xff,0xed,0xed,0xed,0xff,0xed,0xed,0xed,0xff,0xee,0xee,0xee,0xff,0xeb,0xeb,0xeb,0xff,0xce,0xce,0xce,0xff,0xbd,0xbd,0xbd,0xa6,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xbe,0xbe,0xbe,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc5,0xc5,0xc5,0x6c,0xec,0xec,0xec,0xff,0xed,0xed,0xed,0xff,0xed,0xed,0xed,0xff,0xed,0xed,0xed,0xff,0xed,0xed,0xed,0xff,0xed,0xed,0xed,0xff,0xef,0xef,0xef,0xff,0xd3,0xd3,0xd3,0xfd,0xe1,0xe1,0xe1,0xff,0xde,0xde,0xde,0xae,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc8,0xc8,0xc8,0x6c,0xee,0xee,0xee,0xff,0xef,0xef,0xef,0xff,0xef,0xef,0xef,0xff,0xef,0xef,0xef,0xff,0xef,0xef,0xef,0xff,0xef,0xef,0xef,0xff,0xf0,0xf0,0xf0,0xff,0xdb,0xdb,0xdb,0xff,0xc0,0xc0,0xc0,0xfe,0xc9,0xc9,0xc9,0xff,0xb9,0xb9,0xb9,0xbd,0x0,0x0,0x0,0x0,0xff,0xff,0xff,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc9,0xc9,0xc9,0x6b,0xf0,0xf0,0xf0,0xff,0xf1,0xf1,0xf1,0xff,0xf1,0xf1,0xf1,0xff,0xf1,0xf1,0xf1,0xff,0xf1,0xf1,0xf1,0xff,0xf1,0xf1,0xf1,0xff,0xf1,0xf1,0xf1,0xff,0xe7,0xe7,0xe7,0xff,0xc3,0xc3,0xc3,0xff,0xb6,0xb6,0xb6,0xfc,0xc2,0xc2,0xc2,0xff,0xbd,0xbd,0xbd,0x95,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xcb,0xcb,0xcb,0x6b,0xf2,0xf2,0xf2,0xff,0xf3,0xf3,0xf3,0xff,0xf3,0xf3,0xf3,0xff,0xf3,0xf3,0xf3,0xff,0xf3,0xf3,0xf3,0xff,0xf3,0xf3,0xf3,0xff,0xf3,0xf3,0xf3,0xff,0xf2,0xf2,0xf2,0xff,0xf2,0xf2,0xf2,0xff,0xf4,0xf4,0xf4,0xff,0xf2,0xf2,0xf2,0xff,0xd5,0xd5,0xd5,0xc0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xcd,0xcd,0xcd,0x6b,0xf4,0xf4,0xf4,0xff,0xf5,0xf5,0xf5,0xff,0xf5,0xf5,0xf5,0xff,0xf5,0xf5,0xf5,0xff,0xf5,0xf5,0xf5,0xff,0xf5,0xf5,0xf5,0xff,0xf5,0xf5,0xf5,0xff,0xf5,0xf5,0xf5,0xff,0xf6,0xf6,0xf6,0xff,0xf6,0xf6,0xf6,0xff,0xf8,0xf8,0xf8,0xff,0xe4,0xe4,0xe4,0xbc,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xcf,0xcf,0xcf,0x6b,0xf6,0xf6,0xf6,0xff,0xf7,0xf7,0xf7,0xff,0xf7,0xf7,0xf7,0xff,0xf7,0xf7,0xf7,0xff,0xf7,0xf7,0xf7,0xff,0xf7,0xf7,0xf7,0xff,0xf7,0xf7,0xf7,0xff,0xf7,0xf7,0xf7,0xff,0xf7,0xf7,0xf7,0xff,0xf7,0xf7,0xf7,0xff,0xf9,0xf9,0xf9,0xff,0xe5,0xe5,0xe5,0xbc,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xd0,0xd0,0xd0,0x6b,0xf8,0xf8,0xf8,0xff,0xf9,0xf9,0xf9,0xff,0xf9,0xf9,0xf9,0xff,0xf9,0xf9,0xf9,0xff,0xf9,0xf9,0xf9,0xff,0xf9,0xf9,0xf9,0xff,0xf9,0xf9,0xf9,0xff,0xf9,0xf9,0xf9,0xff,0xf9,0xf9,0xf9,0xff,0xf9,0xf9,0xf9,0xff,0xfb,0xfb,0xfb,0xff,0xe8,0xe8,0xe8,0xbc,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xd2,0xd2,0xd2,0x6b,0xf9,0xf9,0xf9,0xff,0xfa,0xfa,0xfa,0xff,0xfa,0xfa,0xfa,0xff,0xfa,0xfa,0xfa,0xff,0xfa,0xfa,0xfa,0xff,0xfa,0xfa,0xfa,0xff,0xfa,0xfa,0xfa,0xff,0xfa,0xfa,0xfa,0xff,0xfa,0xfa,0xfa,0xff,0xfa,0xfa,0xfa,0xff,0xfc,0xfc,0xfc,0xff,0xe9,0xe9,0xe9,0xbb,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xd3,0xd3,0xd3,0x6b,0xfb,0xfb,0xfb,0xff,0xfc,0xfc,0xfc,0xff,0xfc,0xfc,0xfc,0xff,0xfc,0xfc,0xfc,0xff,0xfc,0xfc,0xfc,0xff,0xfc,0xfc,0xfc,0xff,0xfc,0xfc,0xfc,0xff,0xfc,0xfc,0xfc,0xff,0xfc,0xfc,0xfc,0xff,0xfc,0xfc,0xfc,0xff,0xfe,0xfe,0xfe,0xff,0xeb,0xeb,0xeb,0xbb,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xd4,0xd4,0xd4,0x6b,0xfc,0xfc,0xfc,0xff,0xfd,0xfd,0xfd,0xff,0xfd,0xfd,0xfd,0xff,0xfd,0xfd,0xfd,0xff,0xfd,0xfd,0xfd,0xff,0xfd,0xfd,0xfd,0xff,0xfd,0xfd,0xfd,0xff,0xfd,0xfd,0xfd,0xff,0xfd,0xfd,0xfd,0xff,0xfd,0xfd,0xfd,0xff,0xff,0xff,0xff,0xff,0xec,0xec,0xec,0xbb,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xd4,0xd4,0xd4,0x6b,0xfd,0xfd,0xfd,0xff,0xfe,0xfe,0xfe,0xff,0xfe,0xfe,0xfe,0xff,0xfe,0xfe,0xfe,0xff,0xfe,0xfe,0xfe,0xff,0xfe,0xfe,0xfe,0xff,0xfe,0xfe,0xfe,0xff,0xfe,0xfe,0xfe,0xff,0xfe,0xfe,0xfe,0xff,0xfe,0xfe,0xfe,0xff,0xff,0xff,0xff,0xff,0xec,0xec,0xec,0xbb,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xd5,0xd5,0xd5,0x6a,0xfd,0xfd,0xfd,0xff,0xfe,0xfe,0xfe,0xff,0xfe,0xfe,0xfe,0xff,0xfe,0xfe,0xfe,0xff,0xfe,0xfe,0xfe,0xff,0xfe,0xfe,0xfe,0xff,0xfe,0xfe,0xfe,0xff,0xfe,0xfe,0xfe,0xff,0xfe,0xfe,0xfe,0xff,0xfe,0xfe,0xfe,0xff,0xff,0xff,0xff,0xff,0xed,0xed,0xed,0xbb,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xdb,0xdb,0xdb,0x70,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf1,0xf1,0xf1,0xc5,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xa4,0xa4,0xa4,0x41,0xbc,0xbc,0xbc,0xab,0xbb,0xbb,0xbb,0xa2,0xbb,0xbb,0xbb,0xa1,0xbb,0xbb,0xbb,0xa1,0xbb,0xbb,0xbb,0xa1,0xbb,0xbb,0xbb,0xa1,0xbb,0xbb,0xbb,0xa1,0xbb,0xbb,0xbb,0xa1,0xbb,0xbb,0xbb,0xa2,0xbb,0xbb,0xbb,0xa2,0xbd,0xbd,0xbd,0xaa,0xb4,0xb4,0xb4,0x73,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x4,0x0,0x0,0x0,0x5,0x0,0x0,0x0,0x5,0x0,0x0,0x0,0x5,0x0,0x0,0x0,0x5,0x0,0x0,0x0,0x5,0x0,0x0,0x0,0x5,0x0,0x0,0x0,0x5,0x0,0x0,0x0,0x5,0x0,0x0,0x0,0x5,0x0,0x0,0x0,0x5,0x0,0x0,0x0,0x5,0x0,0x0,0x0,0x5,0x0,0x0,0x0,0x4,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0};






GuiRect* Tab::focused=0;
GuiRect* Tab::pressed=0;
GuiRect* Tab::hovered=0;

Tab::Tab(float x,float y,float w,float h):
rects(this),
	windowData(0),
	parentWindowContainer(0),
	selected(0),
	mouseDown(false),
	isRender(false),
	splitterContainer(0),
	renderer3D(0),
	renderer2D(0),
	recreateTarget(false),
	resizeTarget(true),
	resizing(false),
	lastFrameTime(0),
	iconUp(0),
	iconLeft(0),
	iconRight(0),
	iconDown(0),
	iconFolder(0),
	iconFile(0),
	threadRender(0)
{}

Tab::~Tab()
{
	wprintf(L"deleting TabContainer %p\n",this);
}

GuiRect* Tab::GetSelected()
{
	return selected<rects.childs.size() ? rects.childs[selected] : 0;
}

void Tab::Draw()
{
	if(this->taskDraw->pause)
		DEBUG_BREAK();

	if(!this->drawInstances.empty())
	{
		DrawInstance*& tDrawInstance=this->drawInstances.front();

		if(!tDrawInstance)
			DEBUG_BREAK();

		if(tDrawInstance->code || tDrawInstance->frame)
		{
			if(this->BeginDraw())
			{
				if(tDrawInstance->frame)
					this->DrawFrame();

				switch(tDrawInstance->code)
				{
				case 1:this->OnGuiPaint();break;
				case 2:tDrawInstance->rect->OnPaint(GuiMsg(this,tDrawInstance->rect,0));break;
				}

				this->EndDraw();
			}
		}

		if(tDrawInstance->remove)
		{
			SAFEDELETE(tDrawInstance);
			this->drawInstances.pop_front();
		}
	}
	else if(Timer::instance->GetTime()-this->lastFrameTime>(1000.0f/Timer::instance->renderFps))
	{
		this->lastFrameTime=Timer::instance->GetTime();
		this->renderer3D->Render();
	}

	Ide::instance->stringEditor->Draw(this);
}

DrawInstance* Tab::SetDraw(int iNoneAllRect,bool iFrame,GuiRect* iRect,String iName,bool iRemove)
{
	DrawInstance* newInstance=new DrawInstance(iNoneAllRect,iFrame,iRect,iName,iRemove);
	this->drawInstances.push_back(newInstance);
	return newInstance;
}

void Tab::BroadcastToSelected(void (GuiRect::*iFunc)(const GuiMsg&),void* iData)
{
	GuiRect* selectedTab=this->GetSelected();

	if(selectedTab)
		(selectedTab->*iFunc)(GuiMsg(this,selectedTab,0,iFunc,iData));
}

void Tab::BroadcastToAll(void (GuiRect::*iFunc)(const GuiMsg&),void* iData)
{
	(this->rects.*iFunc)(GuiMsg(this,&this->rects,0,iFunc,iData));
}


template<class C> void Tab::BroadcastToSelected(void (GuiRect::*iFunc)(const GuiMsg&),void* iData)
{
	GuiRect* selectedTab=this->GetSelected();

	if(selectedTab)
		selectedTab->BroadcastTo<C>(iFunc,iData);
}

template<class C> void Tab::BroadcastToAll(void (GuiRect::*iFunc)(const GuiMsg&),void* iData)
{
	this->rects.BroadcastTo<C>(iFunc,iData);
}


void Tab::SetSelection(GuiRect* iRect)
{
	this->BroadcastToSelected(&GuiRect::OnDeactivate);

	for(size_t i=0;i<this->rects.childs.size();i++)
	{
		if(iRect==this->rects.childs[i])
		{
			this->selected=i;
			break;
		}
	}

	this->BroadcastToSelected(&GuiRect::OnActivate);
	this->BroadcastToSelected(&GuiRect::OnSize);

	this->SetDraw();
}


void Tab::OnGuiSize(void* data)
{
	this->windowData->OnSize();

	this->rects.rect.make(0.0f,(float)Tab::CONTAINER_HEIGHT,this->windowData->width,this->windowData->height-Tab::CONTAINER_HEIGHT);
	this->rects.edges.x=0;
	this->rects.edges.y=(float)Tab::CONTAINER_HEIGHT;
	this->rects.edges.z=this->windowData->width;
	this->rects.edges.w=this->windowData->height;

	this->BroadcastToSelected(&GuiRect::OnSize,data);

	this->resizeTarget=true;
}

void Tab::OnWindowPosChanging(void* data)
{
	this->resizeTarget=true;

	this->windowData->OnWindowPosChanging();

	this->rects.rect.make(0,Tab::CONTAINER_HEIGHT,this->windowData->width,this->windowData->height-Tab::CONTAINER_HEIGHT);
	this->rects.edges.x=0;
	this->rects.edges.y=(float)Tab::CONTAINER_HEIGHT;
	this->rects.edges.z=this->windowData->width;
	this->rects.edges.w=this->windowData->height;

	this->BroadcastToSelected(&GuiRect::OnSize,data);
}

void Tab::OnGuiMouseMove(void* data)
{
	splitterContainer->currentTabContainer=this;

	/*if(mouseDown && tmx!=mousex && tmy!=mousey)
		splitterContainer->CreateFloatingTab(this);

	mousex=tmx;
	mousey=tmy;*/

	//if(mousey>TabContainer::CONTAINER_HEIGHT)
	this->BroadcastToSelected(&GuiRect::OnMouseMove,vec2(this->mousex,this->mousey));
}

void Tab::OnGuiLMouseUp(void* data)
{
	mouseDown=false;

	this->BroadcastToSelected(&GuiRect::OnLMouseUp,vec2(this->mousex,this->mousey));
}

void Tab::OnGuiMouseWheel(void* data)
{

}

void Tab::OnGuiLMouseDown(void* data)
{
	//this->OnGuiMouseMove();


	float &x=this->mousex;
	float &y=this->mousey;


	if(y<=CONTAINER_HEIGHT)
	{
		int tPreviousTabSelected=selected;

		for(int i=0;i<(int)rects.childs.size();i++)
		{
			bool tMouseContained=x>(i*TAB_WIDTH) && x< (i*TAB_WIDTH+TAB_WIDTH) && y > (CONTAINER_HEIGHT-TAB_HEIGHT) &&  y<CONTAINER_HEIGHT;

			if(tMouseContained)// && tPreviousTabSelected!=i)
			{

				mouseDown=true;

				this->SetSelection(rects.childs[i]);

				break;
			}
		}
	}
	else
	{
		this->BroadcastToSelected(&GuiRect::OnLMouseDown,vec2(this->mousex,this->mousey));
	}
}

void Tab::OnGuiDLMouseDown(void* data)
{
	if(this->mousey>CONTAINER_HEIGHT)
		this->BroadcastToSelected(&GuiRect::OnDLMouseDown,vec2(this->mousex,this->mousey));
}


void Tab::OnGuiUpdate(void* data)
{
	this->BroadcastToSelected(&GuiRect::OnUpdate,data);
}

void Tab::OnGuiRMouseUp(void* data)
{
	this->BroadcastToSelected(&GuiRect::OnRMouseUp,data);
}

void Tab::OnGuiRender(void* data)
{
	this->BroadcastToSelected(&GuiRect::OnRender,data);
}

void Tab::DrawFrame()
{

}

void Tab::OnGuiPaint(void* data)
{

}

void Tab::OnResizeContainer(void* data)
{

}

void Tab::OnEntitiesChange(void* data)
{
	this->BroadcastToSelected(&GuiRect::OnEntitiesChange,data);
}
void Tab::OnGuiActivate(void* data)
{
	this->BroadcastToSelected(&GuiRect::OnActivate,data);


}
void Tab::OnGuiDeactivate(void* data)
{
	this->BroadcastToSelected(&GuiRect::OnDeactivate,data);
}
void Tab::OnGuiEntitySelected(void* data)
{
	this->BroadcastToSelected(&GuiRect::OnEntitySelected,data);
}

void Tab::OnGuiKeyDown(void* data)
{
	this->BroadcastToSelected(&GuiRect::OnKeyDown,data);
}

void Tab::OnGuiKeyUp(void* data)
{
	this->BroadcastToSelected(&GuiRect::OnKeyUp,data);
}

void Tab::OnGuiRecreateTarget(void* data)
{
	this->BroadcastToSelected(&GuiRect::OnRecreateTarget,data);
}

void Tab::SetFocus(GuiRect* iFocusedRect)
{
	if(Tab::focused)
		Tab::focused->OnExitFocus(GuiMsg(Tab::focused->GetRootRect()->tabContainer,Tab::focused,0,&GuiRect::OnExitFocus,Tab::focused));

	Tab::focused=iFocusedRect;

	if(Tab::focused)
		Tab::focused->OnEnterFocus(GuiMsg(Tab::focused->GetRootRect()->tabContainer,Tab::focused,0,&GuiRect::OnEnterFocus,Tab::focused));
}

GuiRect* Tab::GetFocus()
{
	return Tab::focused;
}


///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////SplitterContainer///////////////
///////////////////////////////////////////////
///////////////////////////////////////////////
Splitter::Splitter():
splitterSize(4)
{
	floatingTabRef=0;
	floatingTab=0;
	floatingTabTarget=0;
	floatingTabRefTabIdx=-1;
	floatingTabRefTabCount=-1;
	floatingTabTargetAnchorPos=-1;
	floatingTabTargetAnchorTabIndex=-1;

	splitterCursor=L"IDC_ARROW";
}
Splitter::~Splitter()
{
}

///////////////////////////////////////////////
///////////////////////////////////////////////
//////////////////GuiCaret///////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

StringEditor::Cursor::Cursor():cursor(0){}

StringEditor::StringEditor():
	string(0),
	tab(0),
	lastBlinkTime(0),
	blinking(false),
	enabled(false),
	blinkingRate(BLINKRATE),
	recalcBackground(false)
{}

void StringEditor::Bind(GuiString* iString,Cursor* iCursor)
{
	this->string=iString;
	this->tab=iString->GetRootRect()->tabContainer;
	this->cursor=iCursor;

	if(!this->cursor)
		this->cursor=new Cursor;

	if(!this->cursor->cursor)
		this->cursor->cursor=iString->text->c_str();

	this->EditText(CARET_RECALC,0);
}

void StringEditor::Enable(bool iEnable)
{
	this->enabled=iEnable;
}


bool StringEditor::EditText(unsigned int iCaretOp,void* iParam)
{
	float tFontHeight=tab->renderer2D->GetFontHeight();

	bool tMustResize=false;

	switch(iCaretOp)
	{
	case CARET_RECALC:
		{
			const wchar_t*	pText=this->string->text->c_str();

			bool tCarriageReturn=false;
			int tCharWidth=0;

			this->cursor->caret=vec4(this->string->textEdges.x,this->string->textEdges.y,0,tFontHeight);

			while(*pText)
			{
				if(tCarriageReturn)
				{
					this->cursor->caret.x=0;
					this->cursor->caret.y+=tFontHeight;
					
					this->cursor->rowcol.x+=1;
					this->cursor->rowcol.y=0;

					tCarriageReturn=false;
				}

				tCharWidth=tab->renderer2D->GetCharWidth(*pText);

				if(*pText=='\n' ||  *pText=='\r')
					tCarriageReturn=true;

				this->cursor->caret.z=tCharWidth;

				if(pText==this->cursor->cursor)
					break;

				this->cursor->caret.x+=tCharWidth;
				this->cursor->rowcol.y+=1;

				pText++;
			}

			break;
		}
		case CARET_CANCEL:
		{
			if(this->string->text->empty() || this->cursor->cursor==&this->string->text->back())
				return false;

			std::wstring::iterator sIt=this->string->text->begin()+this->cursor->rowcol.y;

			if(sIt!=this->string->text->end())
				this->string->text->erase(sIt);

			break;
		}
		case CARET_BACKSPACE:
		{
			if(this->cursor->cursor==this->string->text->c_str())
				return false;

			char tCharCode=*(--this->cursor->cursor);

			if(tCharCode=='\n' ||  tCharCode=='\r')
			{
				//find previous row length
				const wchar_t*	pText=this->cursor->cursor-1;
				unsigned int	tRowCharsWidth=0;
				unsigned int    tRowCharCount=0;

				while(*pText!='\n' &&  *pText!='\r')
				{
					tRowCharsWidth+=tab->renderer2D->GetCharWidth(*pText);

					if(pText==this->string->text->c_str())
						break;

					pText--;
					tRowCharCount++;

				}

				this->cursor->caret.x=tRowCharsWidth;
				this->cursor->caret.y-=tFontHeight;
				this->cursor->rowcol.x--;
				this->cursor->rowcol.y=tRowCharCount;

				tMustResize=true;
			}
			else
			{
				this->cursor->caret.x-=tab->renderer2D->GetCharWidth(tCharCode);
				this->cursor->rowcol.y--;
			}

			this->string->text->erase(this->cursor->cursor-this->string->text->c_str(),1);

			break;
		}
		case CARET_ADD:
		{
			char tCharcode=*(char*)iParam;

			tCharcode=='\r' ? tCharcode='\n' : 0;

			if(tCharcode=='\n' || tCharcode=='\r')
			{
				this->cursor->caret.x=0;
				this->cursor->caret.y+=tFontHeight;
				this->cursor->rowcol.x++;
				this->cursor->rowcol.y=0;
				tMustResize=true;
			}
			else
			{
				this->cursor->caret.x+=tab->renderer2D->GetCharWidth(tCharcode);
				this->cursor->rowcol.y++;
			}

			size_t tPosition=this->cursor->cursor-this->string->text->c_str();

			this->string->text->insert(tPosition,1,tCharcode);
			this->cursor->cursor=this->string->text->c_str()+tPosition+1;

			break;
		}
		case CARET_ARROWLEFT:
		{
			if(this->cursor->cursor==this->string->text->c_str())
				return false;

			char tCharCode=*(--this->cursor->cursor);

			if(tCharCode=='\n' ||  tCharCode=='\r')
			{
				const wchar_t*	pText=this->cursor->cursor;
				unsigned int	tRowLenght=0;
				unsigned int    tRowCharCount=0;

				//find previous row lengthc

				while(true)
				{
					if(this->cursor->cursor!=pText && (*pText=='\n' || *pText=='\r'))
						break;

					tRowLenght+=tab->renderer2D->GetCharWidth(*pText);

					if(pText==this->string->text->c_str())
						break;

					pText--;
					tRowCharCount++;
				}

				this->cursor->caret.x=tRowLenght;
				this->cursor->caret.y-=tFontHeight;
				this->cursor->rowcol.x--;
				this->cursor->rowcol.y=tRowCharCount;
			}
			else
			{
				this->cursor->caret.x-=tab->renderer2D->GetCharWidth(tCharCode);
				this->cursor->rowcol.y--;
			}

			break;
		}
		case CARET_ARROWRIGHT:
		{
			char tCharCode=*this->cursor->cursor;

			if(tCharCode=='\0')
				break;

			if(tCharCode=='\n' || tCharCode=='\r')
			{
				this->cursor->caret.x=0;
				this->cursor->caret.y+=tFontHeight;
				this->cursor->rowcol.x++;
				this->cursor->rowcol.y=0;
			}
			else
			{
				this->cursor->caret.x+=tab->renderer2D->GetCharWidth(tCharCode);
				this->cursor->rowcol.y++;
			}

			this->cursor->cursor++;

			break;
		}
		case CARET_ARROWUP:
		{
			unsigned int tRowCharWidth=0;
			unsigned int tColumn=0;

			//---find current rowhead

			const wchar_t* pText=this->cursor->cursor;

			//skip the tail of the current row if present
			if(*pText=='\r' || *pText=='\n')
				pText--;

			//find the last upper row or the head of the current row
			while( pText!=this->string->text->c_str() && *pText!='\r' &&  *pText!='\n' )
				pText--;

			//return if no previous row exists
			if(pText==this->string->text->c_str())
				return false;

			//go to the upper row pre-carriage char
			pText--;

			//find the last upper superior row or the head of the upper row
			while( pText!=this->string->text->c_str() && *pText!='\r' &&  *pText!='\n' )
				pText--;

			//go to the upper superior row pre-carriage char
			if(pText!=this->string->text->c_str())
				pText++;

			//finally found the upper matching position
			while( tColumn!=this->cursor->rowcol.y && *pText!='\0' && *pText!='\r' && *pText!='\n' )
			{
				tRowCharWidth+=tab->renderer2D->GetCharWidth(*pText);

				pText++;
				tColumn++;
			}

			this->cursor->cursor=pText;
			this->cursor->caret.x=tRowCharWidth;
			this->cursor->caret.y-=tFontHeight;
			this->cursor->rowcol.y=tColumn;
			this->cursor->rowcol.x--;

			break;
		}
		case CARET_ARROWDOWN:
		{
			unsigned int tRowCharWidth=0;
			unsigned int tColumn=0;

			//find current rowtail

			const wchar_t* pText=this->cursor->cursor;

			while( *pText!='\0' && *pText!='\r' && *pText!='\n' )
			{
				this->cursor->cursor++;
				pText++;
			}

			if(*pText=='\0')
				return false; //no previous row exists

			pText++;
			this->cursor->cursor++;

			//finally found the lower matching position

			while( tColumn!=this->cursor->rowcol.y && *pText!='\0' && *pText!='\r' && *pText!='\n' )
			{
				tRowCharWidth+=tab->renderer2D->GetCharWidth(*pText);

				pText++;
				this->cursor->cursor++;
				tColumn++;
			}

			/*if(tColumn!=this->cursor->rowcol.y)//string is shorter of the lower matching position
				tRowCharWidth*/

			this->cursor->caret.x=tRowCharWidth;
			this->cursor->caret.y+=tFontHeight;
			this->cursor->rowcol.y=tColumn;
			this->cursor->rowcol.x++;

			break;
		}
	}

	if(tMustResize)
		this->string->OnSize(GuiMsg(this->tab,0,this->string,&GuiRect::OnSize,0));

	this->recalcBackground=true;

	//wprintf(L"cursor: %d,col: %d\n",this->cursor->cursor-this->string->text->c_str(),this->cursor->rowcol.y);
}

///////////////////////////////////////////////
///////////////////////////////////////////////
//////////////////Renderer2D///////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

Renderer2D::Renderer2D(Tab* iTabContainer):
	tabContainer(iTabContainer),
	tabSpaces(4)
{}


///////////////////////////////////////////////
///////////////////////////////////////////////
/////////////Renderer3DInterface///////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

Renderer3D::Renderer3D(Tab* iTabContainer):
	tabContainer(iTabContainer)
{

}

bool Renderer3D::Block()
{
	this->tabContainer->taskDraw->pause=true;

	while(this->tabContainer->taskDraw->executing);

	return true;
}
bool Renderer3D::Release()
{
	this->tabContainer->taskDraw->pause=false;
	return true;
}

void Renderer3D::Register(GuiViewport* iViewport)
{
	if(this->viewports.end()==std::find(this->viewports.begin(),this->viewports.end(),iViewport))
		this->viewports.push_back(iViewport);
}
void Renderer3D::Unregister(GuiViewport* iViewport)
{
	this->viewports.remove(iViewport);
}

Shader* Renderer3D::FindShader(const char* name,bool exact)
{
	return Shader::Find(name,exact);
}

void Renderer3D::SetMatrices(const float* view,const float* mdl)
{
	for(size_t i=0;i<this->shaders.size();i++)
	{
		this->shaders[i]->Use();

		if(view)
			this->shaders[i]->SetProjectionMatrix((float*)view);
		if(mdl)
			this->shaders[i]->SetModelviewMatrix((float*)mdl);
	}
}

bool Renderer3D::LoadTexture(String iFilename,Texture* iTexture)
{
    FILE *tFile=fopen(StringUtils::ToChar(iFilename).c_str(),"rb");
	bool tReturn=false;

	if(tFile)
	{
		short int bmp_signature=0x4d42;
		int jpg_signature1=0xe0ffd8ff;
		int jpg_signature2=0xdbffd8ff;
		int jpg_signature3=0xe1ffd8ff;
		int png_signature1=0x474e5089;
		int png_signature2=0x0a1a0a0d;

		int sign1;
		int sign2;

		fread(&sign1,4,1,tFile);
		fread(&sign2,4,1,tFile);

		if(bmp_signature==(short int)sign1)
		{
            fseek(tFile,0x12,SEEK_SET);
            fread(&iTexture->m_width,2,1,tFile);
            fseek(tFile,0x16,SEEK_SET);
            fread(&iTexture->m_height,2,1,tFile);
            fseek(tFile,0x1c,SEEK_SET);
            fread(&iTexture->m_bpp,2,1,tFile);

            rewind(tFile);

            fseek(tFile,0,SEEK_END);
            iTexture->m_bufsize=ftell(tFile)-54;
            rewind(tFile);
            fseek(tFile,54,SEEK_SET);

            iTexture->m_buf=new unsigned char[iTexture->m_bufsize];

            fread(iTexture->m_buf,1,iTexture->m_bufsize,tFile);

            fclose(tFile);

			return true;
		}
		else
		{
			fclose(tFile);

			std::string tCharFilename=StringUtils::ToChar(iFilename);

			if(jpg_signature1==sign1 || jpg_signature3==sign1 || jpg_signature2==sign2  || jpg_signature3==sign2 )
			{
				int ncomp;

				iTexture->m_buf=jpgd::decompress_jpeg_image_from_file(tCharFilename.c_str(),&iTexture->m_width,&iTexture->m_height,&ncomp,4);

				tReturn=iTexture->m_buf ? true : false;
			}
			else if(png_signature1==sign1 && png_signature2==sign2)
			{
				{
					std::vector<unsigned char> image;
					unsigned long w, h;
					std::vector<unsigned char> buffer;
					int error=-1;

					loadFile(buffer,tCharFilename);

					error = decodePNG(image, w, h, buffer.empty() ? 0 : &buffer[0], (unsigned long)buffer.size());

					if(!error)
					{
						iTexture->m_bufsize=image.size();
						iTexture->m_buf=new unsigned char[iTexture->m_bufsize];
						memcpy(iTexture->m_buf,&image[0],iTexture->m_bufsize);
						iTexture->m_width=w;
						iTexture->m_height=h;

						tReturn=true;
					}

					tReturn=false;
				}
			}
			else if(655360==sign1 && 0==sign2)
			{
				tReturn=LoadTGA(tCharFilename.c_str(),iTexture->m_buf,iTexture->m_bufsize,iTexture->m_width,iTexture->m_height,iTexture->m_bpp);
			}
		}
	}

	return tReturn;

}

///////////////////////////////////////////////
///////////////////////////////////////////////
////////////////////GuiMsg/////////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

GuiMsg::GuiMsg(Tab* iTab,GuiRect* iSender,GuiRect* iTarget,void (GuiRect::*iFunction)(const GuiMsg&),void* iData):
	tab(iTab),
	sender(iSender),
	target(iTarget),
	func(iFunction),
	data(iData)
{}

///////////////////////////////////////////////
///////////////////////////////////////////////
////////////////////GuiRect////////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

GuiRect::GuiRect(GuiRect* iParent,float ix, float iy, float iw,float ih,vec2 _alignPos,vec2 _alignRect):
	colorBackground(Renderer2D::COLOR_GUI_BACKGROUND),
	colorForeground(Renderer2D::COLOR_TEXT),
	colorHovering(colorBackground),
	colorPressing(colorBackground),
	colorChecked(colorBackground),
	pressing(false),
	hovering(false),
	checked(false),
	active(false),
	scalars(1,1,1,1),
	minimums(0,0),
	userData(0)
{
	this->SetEdges();
	this->SetParent(iParent);
	this->fixed.make(ix,iy,iw,ih);
}

GuiRect::~GuiRect()
{

}

void GuiRect::SetParent(GuiRect* iParent)
{
	GuiRect* oldParent=this->parent;
	this->parent=iParent;

	if(oldParent)
		oldParent->childs.erase(std::find(oldParent->childs.begin(),oldParent->childs.end(),this));

	if(this->parent)
		this->parent->childs.push_back(this);

	this->active=iParent ? iParent->active : 0;
}

void GuiRect::CalcRect()
{
	Edges &re=this->refedges;
	vec4  &o=this->offsets;
	vec4  &s=this->scalars;
	vec4  &e=this->edges;
	vec4  &r=this->rect;
	vec4  &f=this->fixed;
	vec2  &m=this->minimums;

	float tLeft=0;
	float tTop=0;
	float tRight=0;
	float tBottom=0;

	if(this->parent)
	{
		vec4  &pe=this->parent->edges;

		tLeft= (re.left ? *re.left : (f.x ? f.x : pe.x)) + (o.x);
		tTop= (re.top ? *re.top : (f.y ? f.y : pe.y)) + (o.y);
		tRight= (re.right ? *re.right : (f.z ? tLeft+f.z : pe.z)) + (o.z);
		tBottom= (re.bottom ? *re.bottom : (f.w ? tTop+f.w : pe.w)) + (o.w);
	}
	else
	{
		tLeft= (re.left ? *re.left : (f.x ? f.x : 0)) + (o.x);
		tTop= (re.top ? *re.top : (f.y ? f.y : 0)) + (o.y);
		tRight= (re.right ? *re.right : (f.z ? tLeft+f.z : 0)) + (o.z);
		tBottom= (re.bottom ? *re.bottom : (f.w ? tTop+f.w : 0)) + (o.w);
	}

	tLeft += s.x!=1 ? (tRight-tLeft)*s.x : 0;
	tTop += s.y!=1 ? (tBottom-tTop)*s.y : 0;

	tRight = s.z!=1 ? tLeft + (tRight-tLeft)*s.z : tRight;
	tBottom = s.w!=1 ? tTop + (tBottom-tTop)*s.w : tBottom;

	float tWidth=tRight-tLeft;
	float tHeight=tBottom-tTop;

	tWidth=(tWidth<m.x) ? m.x : tWidth;
	tHeight=(tHeight<m.y) ? m.y : tHeight;

	e.make(tLeft,tTop,tLeft+tWidth,tTop+tHeight);
	r.make(tLeft,tTop,tWidth,tHeight);
}



void GuiRect::SetEdges(float* iLeft,float* iTop,float* iRight,float* iBottom)
{
	this->refedges.left=iLeft;
	this->refedges.top=iTop;
	this->refedges.right=iRight;
	this->refedges.bottom=iBottom;
}

bool GuiRect::Contains(vec4& quad,vec2 point)
{
	return (point.x>quad.x && point.x<(quad.x+quad.z) && point.y>quad.y && point.y<(quad.y+quad.w));
}

void GuiRect::BroadcastToChilds(void (GuiRect::*func)(const GuiMsg&),const GuiMsg& iMsg)
{
	for(std::vector<GuiRect*>::iterator tRect=this->childs.begin();tRect!=this->childs.end();tRect++)
		((*tRect)->*func)(iMsg);
}

void GuiRect::BroadcastToRoot(void (GuiRect::*func)(const GuiMsg&),const GuiMsg& iMsg)
{
	GuiRootRect* root=dynamic_cast<GuiRootRect*>(this->GetRoot());

	if(root)
		(root->*func)(iMsg);
}




void GuiRect::OnEntitiesChange(const GuiMsg& iMsg)
{
	this->BroadcastToChilds(&GuiRect::OnEntitiesChange,iMsg);
}

void GuiRect::DrawBackground(Tab* iTab)
{
	unsigned int tCurrentColor=this->checked ? this->colorChecked : (this->pressing ? this->colorPressing : (this->hovering ? this->colorHovering : this->colorBackground) );

	iTab->renderer2D->DrawRectangle(this->rect.x,this->rect.y,this->rect.x+this->rect.z,this->rect.y+this->rect.w,tCurrentColor);
}


void GuiRect::OnPaint(const GuiMsg& iMsg)
{
	this->DrawBackground(iMsg.tab);
	this->BroadcastToChilds(&GuiRect::OnPaint,iMsg);
}


void GuiRect::OnSize(const GuiMsg& iMsg)
{
	this->CalcRect();
	this->BroadcastToChilds(&GuiRect::OnSize,iMsg);

	if(!this->childs.empty())
	{
		GuiRect* tLastChild=this->childs.back();

		this->rect.w=tLastChild->rect.y+tLastChild->rect.w-this->rect.y;
		this->edges.w=tLastChild->edges.w;
	}
}

void GuiRect::OnLMouseDown(const GuiMsg& iMsg)
{
	bool wasPressing=this->pressing;
	
	this->pressing=this->hovering;

	if(this->hovering)
	{
		this->checked=!this->checked;

		iMsg.tab->SetFocus(this);

		if(wasPressing!=this->pressing && this->colorPressing!=this->colorBackground)
			iMsg.tab->SetDraw(2,0,this);
	}

	this->BroadcastToChilds(&GuiRect::OnLMouseDown,iMsg);

	if(wasPressing!=this->pressing && this->colorPressing!=this->colorBackground)
		iMsg.tab->SetDraw(2,0,this);
}

void GuiRect::OnDLMouseDown(const GuiMsg& iMsg)
{
	this->BroadcastToChilds(&GuiRect::OnDLMouseDown,iMsg);
}

void GuiRect::OnLMouseUp(const GuiMsg& iMsg)
{
	bool wasPressing=this->pressing;

	this->pressing = false;

	this->BroadcastToChilds(&GuiRect::OnLMouseUp,iMsg);

	if(wasPressing!=this->pressing && this->colorPressing!=this->colorBackground)
		iMsg.tab->SetDraw(2,0,this);
}

void GuiRect::OnRMouseUp(const GuiMsg& iMsg)
{
	this->BroadcastToChilds(&GuiRect::OnRMouseUp,iMsg);
}

void GuiRect::OnMouseMove(const GuiMsg& iMsg)
{
	vec2 mpos=*(vec2*)iMsg.data;

	bool _oldHover=this->hovering;
	bool _curHover=this->Contains(this->rect,mpos);

	if(parent && _curHover)
		parent->hovering=false;

	this->hovering=_curHover;

	this->BroadcastToChilds(&GuiRect::OnMouseMove,iMsg);

	if(_oldHover!=this->hovering && this->colorBackground!=this->colorHovering)
		iMsg.tab->SetDraw(2,0,this);
}

void GuiRect::OnUpdate(const GuiMsg& iMsg)
{
	this->BroadcastToChilds(&GuiRect::OnUpdate,iMsg);
}

void GuiRect::OnReparent(const GuiMsg& iMsg)
{
	this->BroadcastToChilds(&GuiRect::OnReparent,iMsg);
}

void GuiRect::OnSelected(const GuiMsg& iMsg)
{
	this->BroadcastToChilds(&GuiRect::OnSelected,iMsg);
}

void GuiRect::OnRender(const GuiMsg& iMsg)
{
	this->BroadcastToChilds(&GuiRect::OnRender,iMsg);
}

void GuiRect::OnMouseWheel(const GuiMsg& iMsg)
{
	this->BroadcastToChilds(&GuiRect::OnMouseWheel,iMsg);
}

void GuiRect::OnActivate(const GuiMsg& iMsg)
{
	this->active=true;
	this->BroadcastToChilds(&GuiRect::OnActivate,iMsg);
}
void GuiRect::OnDeactivate(const GuiMsg& iMsg)
{
	this->active=false;
	this->BroadcastToChilds(&GuiRect::OnDeactivate,iMsg);
}
void GuiRect::OnEntitySelected(const GuiMsg& iMsg)
{
	this->BroadcastToChilds(&GuiRect::OnEntitySelected,iMsg);
}

void GuiRect::OnExpandos(const GuiMsg& iMsg)
{
	if(this->parent)
		this->parent->OnExpandos(iMsg);
}

void GuiRect::OnKeyDown(const GuiMsg& iMsg)
{
	this->BroadcastToChilds(&GuiRect::OnKeyDown,iMsg);
}

void GuiRect::OnKeyUp(const GuiMsg& iMsg)
{
	this->BroadcastToChilds(&GuiRect::OnKeyDown,iMsg);
}

void GuiRect::OnMouseEnter(const GuiMsg& iMsg)
{
	this->BroadcastToChilds(&GuiRect::OnMouseEnter,iMsg);
}
void GuiRect::OnMouseExit(const GuiMsg& iMsg)
{
	this->BroadcastToChilds(&GuiRect::OnMouseExit,iMsg);
}

void GuiRect::OnEnterFocus(const GuiMsg& iMsg)
{
	this->BroadcastToChilds(&GuiRect::OnEnterFocus,iMsg);
}

void GuiRect::OnExitFocus(const GuiMsg& iMsg)
{
	this->BroadcastToChilds(&GuiRect::OnExitFocus,iMsg);
}

GuiRect* GuiRect::GetRoot()
{
	return this->parent ? this->parent->GetRoot() : this;
}

GuiRootRect* GuiRect::GetRootRect()
{
	return (GuiRootRect*)this->GetRoot();
}

GuiString* GuiRect::Text(String str)
{
	GuiString* label=new GuiString;
	label->parent=this;
	label->text=str.c_str();
	this->childs.push_back(label);
	return label;
}

void GuiRect::AppendAsProperty(GuiRect* iProperty)
{
	GuiRect* tGuiRect=	(
							this->childs.size() ?
							this->childs.back() :
							this
						);

	iProperty->refedges.top=	tGuiRect->parent ? 
								&tGuiRect->edges.w :
								0;

	iProperty->SetParent(this);
}
	

GuiContainer* GuiRect::Container(String iText)
{
	GuiContainer* tContainer=new GuiContainer;

	tContainer->text=iText;
	tContainer->textAlign.make(0,0.5f);

	this->AppendAsProperty(tContainer);

	return tContainer;
}

GuiPropertyString* GuiRect::Property(String iDescription,void* iValuePointer1,unsigned int iValueType,void* iValuePointer2,unsigned int iValueParameter1,unsigned int iValueParameter2)
{
	GuiPropertyString* tPropertyString=new GuiPropertyString(iDescription,iValuePointer1,iValueType,iValuePointer2,iValueParameter1,iValueParameter2);
	this->AppendAsProperty(tPropertyString);
	return tPropertyString;
}



GuiPropertySlider* GuiRect::SliderProperty(String iDescription,float& ref,float& imin,float& imax)
{
	GuiPropertySlider* tGuiPropertySlider=new GuiPropertySlider(iDescription,ref,imin,imax);
	this->AppendAsProperty(tGuiPropertySlider);
	return tGuiPropertySlider;
}


GuiPropertyAnimationController* GuiRect::AnimationControllerProperty(AnimationController& ac)
{
	GuiPropertyAnimationController* tGuiPropertyAnimationController=new GuiPropertyAnimationController(ac);
	this->AppendAsProperty(tGuiPropertyAnimationController);
	return tGuiPropertyAnimationController;
}

GuiViewport* GuiRect::Viewport(vec3 pos,vec3 target,vec3 up,bool perspective)
{
	GuiViewport* tGuiViewport=new GuiViewport;

	tGuiViewport->SetParent(this);
	tGuiViewport->projection= !perspective ? tGuiViewport->projection : tGuiViewport->projection.perspective(90,16/9,1,1000);
	tGuiViewport->view.move(pos);
	tGuiViewport->view.lookat(target,up);

	return tGuiViewport;
}

GuiSceneViewer* GuiRect::SceneViewer()
{
	GuiSceneViewer* tGuiSceneViewer=new GuiSceneViewer;
	tGuiSceneViewer->SetParent(this);
	return tGuiSceneViewer;
}

GuiEntityViewer* GuiRect::EntityViewer()
{
	GuiEntityViewer* tGuiEntityViewer=new GuiEntityViewer;
	tGuiEntityViewer->SetParent(this);
	return tGuiEntityViewer;
}
GuiProjectViewer* GuiRect::ProjectViewer()
{
	GuiProjectViewer* tGuiProjectViewer=new GuiProjectViewer;
	tGuiProjectViewer->SetParent(this);
	return tGuiProjectViewer;
}

GuiScriptViewer* GuiRect::ScriptViewer()
{
	GuiScriptViewer* tGuiScriptViewer=new GuiScriptViewer();
	tGuiScriptViewer->SetParent(this);
	return tGuiScriptViewer;
}

GuiCompilerViewer* GuiRect::CompilerViewer()
{
	GuiCompilerViewer* tGuiCompilerViewer=new GuiCompilerViewer();
	tGuiCompilerViewer->SetParent(this);
	return tGuiCompilerViewer;
}

void GuiRect::DestroyChilds()
{
	for(size_t i=0;i<this->childs.size();i++)
	{
		this->childs[i]->DestroyChilds();
		SAFEDELETE(this->childs[i]);
	}

	this->childs.clear();
}

void* GuiRect::SetUserData(void* iData)
{
	return this->userData=iData;
}

void* GuiRect::GetUserData()
{
	return userData;
}

template<class GuiRectDerived> GuiRectDerived* GuiRect::Create(int sibIdx,int container,float ix, float iy, float iw,float ih,float iAlignPosX,float iAlignPosY,float iAlignRectX,float iAlignRectY)
{
	GuiRectDerived* guirectderived=new GuiRectDerived;

	if(!guirectderived)
		DEBUG_BREAK();

	guirectderived->SetParent(this);//,sibIdx>=0 ? this : 0,sibIdx<0 ? 0 : sibIdx,container,ix,iy,iw,ih,iAlignPosX,iAlignPosY,iAlignRectX,iAlignRectY);
	guirectderived->fixed.make(ix,iy,iw,ih);

	return guirectderived;
}

///////////////////////////////////////////////
///////////////////////////////////////////////
//////////////////Compiler/////////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

Compiler::Compiler()
{
	ideSrcPath=Ide::instance->pathExecutable.PathUp(5) + L"\\src";
	ideLibPath=Ide::instance->pathExecutable.Path();

	COMPILER msCompiler={L"ms",
						 L"vc2010",
						 L"cl.exe ",
						 L"linker.exe ",
						 L" /nologo /MDd /ZI /EHsc ",
						 L" /link /MANIFEST:NO /DLL /NOENTRY ",
						 L" /OUT:",
						 L"enginelibMS",
						 L".lib ",
						 L" /I"
						};

	COMPILER mingwCompiler={L"mingw",
							L"i686-w64-mingw32",
							L"c:\\sdk\\mingw32\\bin\\i686-w64-mingw32-g++.exe ",
							L"c:\\sdk\\mingw32\\bin\\i686-w64-mingw32-ld.exe ",
							L" -O0 -g -shared ",
							L"",
							L" -o ",
							L"enginelibMingW",
							L".dll ",
							L" -I"
						   };

	COMPILER llvmCompiler={L"llvm",
						   L"5.0.0 32bit",
						   L"c:\\sdk\\llvm32\\bin\\clang-cl.exe ",
						   L"c:\\sdk\\llvm32\\bin\\lld-link.exe ",
						   L" /nologo /MDd /ZI /EHsc ",
						   L" /link /MANIFEST:NO /DLL /NOENTRY ",
						   L" /OUT:",
						   L"enginelibLLVM",
						   L".lib ",
						   L" /I"
						  };

	compilers.push_back(msCompiler);
	compilers.push_back(mingwCompiler);
	compilers.push_back(llvmCompiler);
}


Compiler::~Compiler(){}

///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////EditorProperties////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

IdeViewerProperties::IdeViewerProperties():container(0)
{
}

///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////////EditorEntity////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

EditorEntity::EditorEntity():
	selected(false),
	expanded(false),
	level(0)
{
	this->entityViewerRootPropertyRect.name=L"EntityRootProperties";
	this->sceneViewerPropertyRect.SetStringMode(this->Entity::name,true);

	this->entityViewerRootPropertyRect.SetUserData(this);
	this->sceneViewerPropertyRect.SetUserData(this);
	this->sceneViewerPropertyRect.colorHovering=Renderer2D::COLOR_GUI_BACKGROUND+30;
	this->sceneViewerPropertyRect.colorPressing=Renderer2D::COLOR_GUI_BACKGROUND+90;
	this->sceneViewerPropertyRect.colorChecked=Renderer2D::COLOR_TEXT_SELECTED;
}

void EditorEntity::SetParent(Entity* iParent)
{
	Entity::SetParent(iParent);

	this->SetLevel(this);
}

void EditorEntity::SetLevel(EditorEntity* iEntity)
{
	EditorEntity* eeParent=(EditorEntity*)iEntity->parent;

	iEntity->level=eeParent ? eeParent->level+1 : iEntity->level;
	iEntity->expanded=!iEntity->level ? true : false;

	for(std::list<Entity*>::iterator i=iEntity->childs.begin();i!=iEntity->childs.end();i++)
		((EditorEntity*)*i)->SetLevel((EditorEntity*)*i);
}

///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////////GuiRootRect/////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

GuiRootRect::GuiRootRect(Tab* t):tabContainer(t)
{
	this->name=L"RootRect";
	//this->Set(0,0,0,-1,0,0,0,0,0,0,1,1);

}

GuiRootRect::~GuiRootRect()
{
}

void GuiRootRect::OnSize(const GuiMsg&)
{
	DEBUG_BREAK();
}

///////////////////////////////////////////////
///////////////////////////////////////////////
/////////////////GuiContainer//////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

GuiContainer::GuiContainer():state(false)
{
	this->name=L"GuiContainer";
	this->fixed.make(0,0,0,20);
	this->textOffsets.make(20,0,0,0);
}

void GuiContainer::CalcContainerRect()
{
	if(this->state && !this->childs.empty())
	{
		GuiRect* tLastChild=this->childs.back();

		this->rect.w=tLastChild->rect.y+tLastChild->rect.w-this->rect.y;
		this->edges.w=tLastChild->edges.w;
	}
}

void GuiContainer::AppendAsProperty(GuiRect* iProperty)
{
	iProperty->offsets.x=GuiRect::ROW_ADVANCE;

	GuiString::AppendAsProperty(iProperty);
}

void GuiContainer::BroadcastToChilds(void (GuiRect::*iFunction)(const GuiMsg&),const GuiMsg& iMsg)
{
	if(this->state)
		GuiString::BroadcastToChilds(iFunction,iMsg);
}

void GuiContainer::OnSize(const GuiMsg& iMsg)
{
	this->textOffsets.x=this->childs.size() ? ROW_ADVANCE : 0;
	GuiString::OnSize(iMsg);
	this->CalcContainerRect();
}

void GuiContainer::OnPaint(const GuiMsg& iMsg)
{
	this->DrawBackground(iMsg.tab);

	if(this->childs.size())
		iMsg.tab->renderer2D->DrawBitmap(
												this->state ?
												iMsg.tab->iconDown :
												iMsg.tab->iconRight,
												this->rect.x,
												this->rect.y,
												this->rect.x+Tab::CONTAINER_ICON_WH,
												this->rect.y+Tab::CONTAINER_ICON_WH
											);

	this->DrawTheText(iMsg.tab);

	this->BroadcastToChilds(&GuiRect::OnPaint,iMsg);
}

void GuiContainer::OnLMouseDown(const GuiMsg& iMsg)
{
	vec2 tMousePosition=*(vec2*)iMsg.data;
	bool tContainerButtonPressed=0;

	tContainerButtonPressed=(	
								tMousePosition.x > this->rect.x && 
								tMousePosition.x < this->rect.x+Tab::CONTAINER_ICON_WH &&
								tMousePosition.y > this->rect.y && 
								tMousePosition.y <this->rect.y+Tab::CONTAINER_ICON_WH
							);

	if(tContainerButtonPressed)
		this->state=!this->state;

	if(tContainerButtonPressed)
	{
		iMsg.tab->BroadcastToSelected(&GuiRect::OnSize);
		this->OnExpandos(iMsg);
		iMsg.tab->SetDraw(1,false);
	}

	GuiString::OnLMouseDown(iMsg);
}

///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////////GuiString///////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

GuiString::GuiStringBase::GuiStringBase():_______text(new String),________dtor(true){};
GuiString::GuiStringBase::~GuiStringBase()
{
	if(________dtor)
	{
		SAFEDELETE(this->_______text);
		________dtor=false;
	}
}

void GuiString::GuiStringBase::SetStringMode(String& iString,bool isReference)
{
	if(this->________dtor)
		SAFEDELETE(this->_______text);

	isReference ? 
		this->________dtor=false,
		this->_______text=&iString
		:
	this->_______text=new String,
		this->________dtor=true,
		this->_______text->assign(iString)
		;
}
GuiString::GuiStringBase::operator String&()
{
	return *this->_______text;
}
String& GuiString::GuiStringBase::operator=(const String& iString)
{
	return *this->_______text=iString;
}
String* GuiString::GuiStringBase::operator->()
{
	return this->_______text;
}

GuiString::GuiString():
	textAlign(0.0f,0.5f),
	textSpot(0.0f,0.5f)
{
	this->fixed.make(0,0,0,20);
	this->name=L"GuiString";
}


void GuiString::SetStringMode(String& iString,bool isReference)
{
	this->text.SetStringMode(iString,isReference);
}

void GuiString::CalcTextRect(Tab* iTab)
{
	vec4 tEdges(
					this->edges.x + this->textOffsets.x,
					this->edges.y + this->textOffsets.y,
					this->edges.z + this->textOffsets.z,
					this->edges.w + this->textOffsets.w
				);

	vec4 tRect(
					tEdges.x,
					tEdges.y,
					tEdges.z-tEdges.x,
					tEdges.w-tEdges.y
			);

	vec2 tTextSize=iTab->renderer2D->MeasureText(this->text->c_str());

	float tLeft=tEdges.x + (tRect.z*this->textAlign.x) - (tTextSize.x * this->textSpot.x);
	float tTop=tEdges.y + (tRect.w*this->textAlign.y) - (tTextSize.y * this->textSpot.y);

	this->textEdges.make(
							tLeft,
							tTop,
							tLeft + tTextSize.x,
							tTop + tTextSize.y
						);

	this->textRect.make(
							tLeft,
							tTop,
							tTextSize.x,
							tTextSize.y
						);
}

void GuiString::OnSize(const GuiMsg& iMsg)
{
	this->CalcRect();
	this->CalcTextRect(iMsg.tab);
	this->BroadcastToChilds(&GuiRect::OnSize,iMsg);
}

void GuiString::DrawTheText(Tab* iTab)
{
	iTab->renderer2D->DrawText(
											this->text,
											this->textEdges.x,
											this->textEdges.y,
											this->textEdges.z,
											this->textEdges.w
										);
}

void GuiString::OnPaint(const GuiMsg& iMsg)
{
	this->DrawBackground(iMsg.tab);
	this->DrawTheText(iMsg.tab);
	this->BroadcastToChilds(&GuiRect::OnPaint,iMsg);
}

bool GuiString::ParseKeyInput(const GuiMsg& iMsg)
{
	StringEditor&	stringEditor=*Ide::instance->stringEditor;

	bool			tRedraw=false;

	if(stringEditor.string==this && stringEditor.enabled)
	{
		unsigned int	tCaretOperation=stringEditor.CARET_DONTCARE;
		void*			tCaretParameter=0;
		char			tCharcode;

		if(iMsg.data)
		{
			tCharcode=*(int*)iMsg.data;

			switch(tCharcode)
			{
				case 0x08:/*VK_BACK*/tCaretOperation=stringEditor.CARET_BACKSPACE; break;
				default:
					tCaretOperation=stringEditor.CARET_ADD;
					tCaretParameter=&tCharcode;
			}
		}
		else
		{
			if(InputManager::keyboardInput.IsPressed(0x25/*VK_LEFT*/))
				tCaretOperation=stringEditor.CARET_ARROWLEFT;
			if(InputManager::keyboardInput.IsPressed(0x27/*VK_RIGHT*/))
				tCaretOperation=stringEditor.CARET_ARROWRIGHT;
			if(InputManager::keyboardInput.IsPressed(0x26/*VK_UP*/))
				tCaretOperation=stringEditor.CARET_ARROWUP;
			if(InputManager::keyboardInput.IsPressed(0x28/*VK_DOWN*/))
				tCaretOperation=stringEditor.CARET_ARROWDOWN;
			if(InputManager::keyboardInput.IsPressed(0x03/*VK_CANCEL*/))
				tCaretOperation=stringEditor.CARET_CANCEL;
			if(InputManager::keyboardInput.IsPressed(0x2E/*VK_DELETE*/))
				tCaretOperation=stringEditor.CARET_CANCEL;
			if(InputManager::keyboardInput.IsPressed(0x1B/*VK_ESCAPE*/)) 
			{
				stringEditor.Enable(false);
				return false;
			}
		}

		tRedraw=true;

		bool tMustResize=stringEditor.EditText(tCaretOperation,tCaretParameter);
	}
	else if(InputManager::keyboardInput.IsPressed(0x71/*VK_F2*/))
	{
		stringEditor.Bind(this);
		stringEditor.Enable(true);
	}

	return tRedraw;
}

void GuiString::OnKeyDown(const GuiMsg& iMsg)
{
	if(this==Tab::GetFocus())
	{
		bool tRedraw=this->ParseKeyInput(iMsg);

		if(tRedraw)
			iMsg.tab->SetDraw(2,0,this);
	}

	GuiRect::OnKeyDown(iMsg);
}


void GuiString::OnLMouseDown(const GuiMsg& iMsg)
{
	if(this->hovering)
		Tab::SetFocus(this);

	GuiRect::OnLMouseDown(iMsg);
}

///////////////////////////////////////////////
///////////////////////////////////////////////
////////////////////GuiButton//////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

GuiButton::GuiButton()
{
	this->textAlign.make(0.5f,0.5f);
	this->textSpot.make(0.5f,0.5f);
}
void GuiButton::OnLMouseUp(const GuiMsg& iMsg)
{
	GuiString::OnLMouseUp(iMsg);

	if(this->hovering)
	{
		if(this->parent)
		{
			GuiMsg tMsg(iMsg.tab,this,0,&GuiRect::OnButtonPressed,this);
			this->parent->OnButtonPressed(tMsg);
		}	
	}
}

///////////////////////////////////////////////
///////////////////////////////////////////////
////////////////GuiButtonFunc//////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

GuiButtonFunc::GuiButtonFunc(void (*iFunc)(void*),void* iParam):func(iFunc),param(iParam)
{

}

void GuiButtonFunc::OnLMouseUp(const GuiMsg& iMsg)
{
	GuiString::OnLMouseUp(iMsg);

	if(this->hovering)
	{
		if(this->func)
			this->func(this->param);
	}
}

///////////////////////////////////////////////
///////////////////////////////////////////////
////////////////GuiButtonBool//////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

GuiButtonBool::GuiButtonBool(bool& iBool):referenceValue(iBool),updateMode(-1)
{
	this->name=L"Button";
}

void GuiButtonBool::OnLMouseUp(const GuiMsg& iMsg)
{
	GuiString::OnLMouseUp(iMsg);

	if(this->hovering)
	{
		switch(this->updateMode)
		{
		case -1:	referenceValue=!referenceValue; break;
		case 0:		referenceValue=false;			break;
		case 1:		referenceValue=true;			break;
		}

		if(this->parent)
			this->parent->OnButtonPressed(GuiMsg(iMsg.tab,this,0,&GuiRect::OnButtonPressed,this));
	}
}

///////////////////////////////////////////////
///////////////////////////////////////////////
////////////////GuiScrollRect//////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

GuiScrollRect::GuiScrollRect():
contentHeight(0),
contentWidth(0),
hScrollbar(GuiScrollBar::SCROLLBAR_HORIZONTAL),
vScrollbar(GuiScrollBar::SCROLLBAR_VERTICAL)
{
	this->vScrollbar.guiRect=this;
	this->vScrollbar.SetEdges(&this->edges.z,&this->edges.y,0,&this->edges.w);

	this->hScrollbar.guiRect=this;
	this->hScrollbar.SetEdges(&this->edges.x,&this->edges.w,&this->edges.z,0);
}

GuiScrollRect::~GuiScrollRect()
{
}

vec2 GuiScrollRect::GetClippedMouse(vec2& iMpos)
{
	vec2 tMpos(iMpos);

	tMpos.x=tMpos.x+this->hScrollbar.scrollerPosition*this->contentWidth;
	tMpos.y=tMpos.y+this->vScrollbar.scrollerPosition*this->contentHeight;

	return tMpos;
}

void GuiScrollRect::OnLMouseDown(const GuiMsg& iMsg)
{
	vec2 tMpos=this->GetClippedMouse(*(vec2*)iMsg.data);

	this->GuiRect::BroadcastToChilds(&GuiRect::OnLMouseDown,GuiMsg(iMsg.tab,this,0,&GuiRect::OnLMouseDown,tMpos));

	this->vScrollbar.OnLMouseDown(iMsg);
	this->hScrollbar.OnLMouseDown(iMsg);
}

void GuiScrollRect::OnMouseMove(const GuiMsg& iMsg)
{
	vec2 tMpos=this->GetClippedMouse(*(vec2*)iMsg.data);

	this->GuiRect::BroadcastToChilds(&GuiRect::OnMouseMove,GuiMsg(iMsg.tab,this,0,&GuiRect::OnMouseMove,tMpos));

	this->vScrollbar.OnMouseMove(iMsg);
	this->hScrollbar.OnMouseMove(iMsg);
}

void GuiScrollRect::OnMouseWheel(const GuiMsg& iMsg)
{
	if(this->vScrollbar.IsVisible() && this->Contains(this->rect,vec2(iMsg.tab->mousex,iMsg.tab->mousey)))
		this->vScrollbar.Scroll(iMsg.tab,*(float*)iMsg.tab);

	this->BroadcastToChilds(&GuiRect::OnMouseWheel,iMsg);
}

void GuiScrollRect::BroadcastToChilds(void (GuiRect::*iFunction)(const GuiMsg&),const GuiMsg& iMsg)
{
	GuiRect::BroadcastToChilds(iFunction,iMsg);

	(this->vScrollbar.*iFunction)(iMsg);
	(this->hScrollbar.*iFunction)(iMsg);
}

void GuiScrollRect::OnSize(const GuiMsg& iMsg)
{
	this->CalcRect();

	this->contentHeight=(!this->childs.empty() ? this->childs.back()->edges.w : this->edges.w) - this->edges.y;
	this->contentWidth=this->rect.z;

	this->vScrollbar.SetScrollerRatio(this->contentHeight,this->rect.w);
	this->hScrollbar.SetScrollerRatio(this->contentWidth,this->rect.z);

	if(this->vScrollbar.IsVisible())
	{
		this->rect.z-=GuiScrollBar::SCROLLBAR_TICK;
		this->edges.z-=GuiScrollBar::SCROLLBAR_TICK;
	}

	if(this->hScrollbar.IsVisible())
	{
		this->rect.w-=GuiScrollBar::SCROLLBAR_TICK;
		this->edges.w-=GuiScrollBar::SCROLLBAR_TICK;
	}

	this->BroadcastToChilds(&GuiRect::OnSize,iMsg);
}


void GuiScrollRect::BeginSelfClip(Tab* tabContainer)
{
	if(this->vScrollbar.IsVisible())
	{
		vec4& tClipEdges=this->edges;

		tabContainer->renderer2D->PushScissor(tClipEdges.x,tClipEdges.y,tClipEdges.z,tClipEdges.w);
		tabContainer->renderer2D->Translate(0,-this->vScrollbar.scrollerPosition*this->contentHeight);
	}
}

void GuiScrollRect::EndSelfClip(Tab* tabContainer)
{
	tabContainer->renderer2D->DrawRectangle(this->rect.x+1,this->rect.y+1,this->rect.x+this->rect.z-1,this->rect.y+this->rect.w-1,0xffffff,false);

	if(this->vScrollbar.IsVisible())
	{
		tabContainer->renderer2D->Identity();
		tabContainer->renderer2D->PopScissor();
	}
}

void GuiScrollRect::OnPaint(const GuiMsg& iMsg)
{
	this->BeginSelfClip(iMsg.tab);
	this->GuiRect::DrawBackground(iMsg.tab);
	this->GuiRect::BroadcastToChilds(&GuiRect::OnPaint,iMsg);
	this->EndSelfClip(iMsg.tab);
	this->vScrollbar.OnPaint(iMsg);
	this->hScrollbar.OnPaint(iMsg);
}

///////////////////////////////////////////////
///////////////////////////////////////////////
////////////////GuiProperty*///////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

GuiProperty::GuiProperty()
{
	this->description.SetParent(this);
	this->description.scalars.make(1,1,0.5f,1);
}

GuiPropertyString::GuiPropertyString(String iDescription,void* iValuePointer1,unsigned int iValueType,void* iValuePointer2,unsigned int iValueParameter1,unsigned int iValueParameter2):
	valuePointer1(iValuePointer1),
	valuePointer2(iValuePointer2),
	valueType(iValueType),
	valueParameter1(iValueParameter1),
	valueParameter2(iValueParameter2)
{
	this->description.text=iDescription;
	this->fixed.make(0,0,0,20);
	this->value.SetParent(this);
	this->value.SetEdges(&this->description.edges.z);

	switch(this->valueType)
	{
		case STRING: this->name+=L"STRING"; break;
		case BOOL: this->name+=L"BOOL"; break;
		case BOOLPTR: this->name+=L"BOOLPTR"; break;
		case INT: this->name+=L"INT"; break;
		case FLOAT: this->name+=L"FLOAT"; break;
		case VEC2: this->name+=L"VEC2"; break;
		case VEC3: this->name+=L"VEC3"; break;
		case VEC4: this->name+=L"VEC4"; break;
		case PTR: this->name+=L"PTR"; break;
		case MAT4POS: this->name+=L"MAT4POS"; break;
		case ENTITYVECSIZE: this->name+=L"ENTITYVECSIZE"; break;
		case ANIMATIONVECSIZE: this->name+=L"ANIMATIONVECSIZE"; break;
		case ISBONECOMPONENT: this->name+=L"ISBONECOMPONENT"; break;
		case FLOAT2MINUSFLOAT1: this->name+=L"FLOAT2MINUSFLOAT1"; break;
		case VEC32MINUSVEC31: this->name+=L"VEC32MINUSVEC31"; break;
	}

	this->name+=L" PropertyString";
}

void GuiPropertyString::RefreshReference(Tab* iTabContainer)
{
	const unsigned int ctMaxTmpArraySize=256;

	switch(this->valueType)
	{
	case GuiPropertyString::STRING:
		{
			String& tString=*(String*)this->valuePointer1;

			this->value.text=tString;
		}
		break;
	case GuiPropertyString::BOOL:
		{
			bool& tBool=*(bool*)this->valuePointer1;

			this->value.text=tBool ? L"True" : L"False";
		}
		break;
	case GuiPropertyString::BOOLPTR:
		{
			void* pRef=*(void**)this->valuePointer1;

			this->value.text=pRef ? L"True" : L"False";
		}
		break;
	case GuiPropertyString::INT:
		{
			int& tInt=*(int*)this->valuePointer1;

			wchar_t tCharInt[ctMaxTmpArraySize];
			swprintf(tCharInt,L"%d",tInt);

			this->value.text=tCharInt;
		}
		break;
	case GuiPropertyString::FLOAT:
		{
			float& tFloat=*(float*)this->valuePointer1;

			//https://stackoverflow.com/questions/16413609/printf-variable-number-of-decimals-in-float

			wchar_t tCharFloat[ctMaxTmpArraySize];
			swprintf(tCharFloat,L"%*.*f",this->valueParameter1,this->valueParameter2,tFloat);

			this->value.text=tCharFloat;
		}
		break;
	case GuiPropertyString::VEC2:
		{
			vec2& tVec2=*(vec2*)this->valuePointer1;

			wchar_t tCharVec2[ctMaxTmpArraySize];
			swprintf(tCharVec2,L"%*.*f , %*.*f",this->valueParameter1,this->valueParameter2,tVec2.x,this->valueParameter1,this->valueParameter2,tVec2.y);

			this->value.text=tCharVec2;
		}
		break;
	case GuiPropertyString::VEC3:
		{
			vec3& tVec3=*(vec3*)this->valuePointer1;

			wchar_t tCharVec3[ctMaxTmpArraySize];
			swprintf(tCharVec3,L"%*.*f , %*.*f , %*.*f",	this->valueParameter1,this->valueParameter2,tVec3.x,
				this->valueParameter1,this->valueParameter2,tVec3.y,
				this->valueParameter1,this->valueParameter2,tVec3.z);

			this->value.text=tCharVec3;
		}
		break;
	case GuiPropertyString::VEC4:
		{
			vec4& tVec4=*(vec4*)this->valuePointer1;

			wchar_t tCharVec4[ctMaxTmpArraySize];
			swprintf(tCharVec4,L"%*.*f , %*.*f , %*.*f , %*.*f",	this->valueParameter1,this->valueParameter2,tVec4.x,
				this->valueParameter1,this->valueParameter2,tVec4.y,
				this->valueParameter1,this->valueParameter2,tVec4.z,
				this->valueParameter1,this->valueParameter2,tVec4.w);

			this->value.text=tCharVec4;
		}
		break;
	case GuiPropertyString::PTR:
		{
			wchar_t tCharPointer[ctMaxTmpArraySize];
			swprintf(tCharPointer,L"0x%p",this->valuePointer1);

			this->value.text=tCharPointer;
		}
		break;
	case GuiPropertyString::MAT4POS:
		{
			mat4& tMat4=*(mat4*)this->valuePointer1;

			vec3 tPosition=tMat4.position();

			wchar_t tCharVec3[ctMaxTmpArraySize];
			swprintf(tCharVec3,L"%*.*f , %*.*f , %*.*f",	this->valueParameter1,this->valueParameter2,tPosition.x,
				this->valueParameter1,this->valueParameter2,tPosition.y,
				this->valueParameter1,this->valueParameter2,tPosition.z);

			this->value.text=tCharVec3;
		}
		break;
	case GuiPropertyString::ENTITYVECSIZE:
		{
			std::vector<Entity*>& tEntityVec=*(std::vector<Entity*>*)this->valuePointer1;

			size_t tCount=tEntityVec.size();

			wchar_t tCharVecSize[10];
			swprintf(tCharVecSize,L"%d",tCount);

			this->value.text=tCharVecSize;
		}
		break;
	case GuiPropertyString::ANIMATIONVECSIZE:
		{
			std::vector<Animation*>& tAnimationVec=*(std::vector<Animation*>*)this->valuePointer1;

			size_t tCount=tAnimationVec.size();

			wchar_t tCharVecSize[10];
			swprintf(tCharVecSize,L"%d",tCharVecSize);

			this->value.text=tCharVecSize;
		}
		break;
	case GuiPropertyString::ISBONECOMPONENT:
		{
			Entity* tEntity=(Entity*)this->valueParameter1;

			this->value.text=L"Error";
		}
		break;
	case GuiPropertyString::FLOAT2MINUSFLOAT1:
		{
			float& a=*(float*)this->valueParameter1;
			float& b=*(float*)this->valueParameter2;

			wchar_t tCharFloatMinusOp[20];
			swprintf(tCharFloatMinusOp,L"%*.*d",this->valueParameter1,this->valueParameter2,b-a);

			this->value.text=tCharFloatMinusOp;
		}
		break;
	case GuiPropertyString::VEC32MINUSVEC31:
		{
			vec3& a=*(vec3*)this->valueParameter1;
			vec3& b=*(vec3*)this->valueParameter2;

			vec3 tVecResult=b-a;

			wchar_t tCharVec3[ctMaxTmpArraySize];
			swprintf(tCharVec3,L"%*.*f , %*.*f , %*.*f",	this->valueParameter1,this->valueParameter2,tVecResult.x,
				this->valueParameter1,this->valueParameter2,tVecResult.y,
				this->valueParameter1,this->valueParameter2,tVecResult.z);

			this->value.text=tCharVec3;
		}
		break;
	default:
		iTabContainer->renderer2D->DrawText(String(L"valueType error"),this->rect.x+this->rect.z/2.0f,this->rect.y,this->rect.x+this->rect.z,this->rect.y+this->rect.w);
	}
}

void GuiPropertyString::OnSize(const GuiMsg& iMsg)
{
	this->RefreshReference(iMsg.tab);

	GuiProperty::OnSize(iMsg);
}

void GuiPropertyString::OnPaint(const GuiMsg& iMsg)
{
	this->DrawBackground(iMsg.tab);

	/*tabContainer->renderer2D->DrawText(
										this->description,
										this->rect.x,
										this->rect.y,
										this->rect.x+this->rect.z/2.0f,
										this->rect.y+this->rect.w,
										vec2(0,0.5f),
										vec2(0,0.5f),
										Renderer2D::COLOR_TEXT
										);*/

	this->BroadcastToChilds(&GuiRect::OnPaint,iMsg);
}

///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////////GuiSlider///////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////



void GuiSlider::DrawSliderTip(Tab* tabContainer,void* data)
{
	float tip=(this->rect.x+10) + ((referenceValue)/(maximum-minimum))*(this->rect.z-20);
	tabContainer->renderer2D->DrawRectangle(tip-5,this->rect.y+this->rect.w/4.0f-5,tip+5,this->rect.y+this->rect.w/4.0f+5,Renderer2D::COLOR_TEXT);
}


void GuiSlider::OnPaint(const GuiMsg& iMsg)
{
	this->DrawBackground(iMsg.tab);

	iMsg.tab->renderer2D->DrawRectangle(this->edges.x+10,this->edges.w/4.0f-2,this->edges.z-10,this->edges.w/4.0f+2,0x000000);

	float tMinimum=this->minimum;

	String smin(StringUtils::Float(this->minimum));
	String smax(StringUtils::Float(this->maximum));
	String value(StringUtils::Float(this->referenceValue));

	iMsg.tab->renderer2D->DrawText(smin,this->edges.x+10,this->edges.y,this->edges.z-10,this->edges.w,vec2(0,0.5f),vec2(0,0.5f),Renderer2D::COLOR_TEXT);
	iMsg.tab->renderer2D->DrawText(smax,this->edges.x+10,this->edges.y,this->edges.z-10,this->edges.w,vec2(0,0.5f),vec2(0,0.5f),Renderer2D::COLOR_TEXT);
	iMsg.tab->renderer2D->DrawText(value,this->edges.x+10,this->edges.y,this->edges.z-10,this->edges.w,vec2(0,0.5f),vec2(0,0.5f),Renderer2D::COLOR_TEXT);

	float tip=(this->rect.x+10) + ((referenceValue)/(maximum-minimum))*(this->rect.z-20);

	iMsg.tab->renderer2D->DrawRectangle(tip-5,this->edges.w/4.0f-5,tip+5,this->edges.w/4.0f+5,Renderer2D::COLOR_TEXT);

	this->BroadcastToChilds(&GuiRect::OnPaint,iMsg);
}

void GuiSlider::OnMouseMove(const GuiMsg& iMsg)
{
	GuiRect::OnMouseMove(iMsg);

	if(this->pressing)
	{
		vec2& mpos=*(vec2*)iMsg.data;

		if(mpos.x > this->rect.x && mpos.x < this->rect.x+this->rect.z)
		{
			float f1=(mpos.x-(this->rect.x+10))/(this->rect.z-20);
			float f2=maximum-minimum;
			float cursor=f1*f2;

			cursor = cursor<minimum ? minimum : (cursor>maximum ? maximum : cursor);

			if(referenceValue!=cursor)
			{
				referenceValue=cursor;
				iMsg.tab->SetDraw(2,0,this);
			}
		}
	}
}

void GuiSlider::OnSize(const GuiMsg& iMsg)
{
	/*float oldRatio=maximum/minimum;
	float value=this->referenceValue ? *this->referenceValue : 0;*/

	GuiRect::OnSize(iMsg);
}

///////////////////////////////////////////////
///////////////////////////////////////////////
///////////GuiPropertySlider///////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

GuiPropertySlider::GuiPropertySlider(String iDescription,float& iRefVal,float& iMin,float& iMax):slider(iRefVal,iMin,iMax)
{
	this->description.text=iDescription;
	this->name=L"PropertySlider";
	this->fixed.make(0,0,0,25);//Set(0,0,0,-1,0,0,0,25,0,0,1,-1);
	//this->slider.Set(this,0,0,-1,0,0,0,0,0.5f,0,0.5f,1);
	this->slider.SetParent(this);
	this->slider.scalars.make(0.5f,1,0.5f,1);
}

void GuiPropertySlider::OnPaint(const GuiMsg& iMsg)
{
	this->DrawBackground(iMsg.tab);

	if(description.text->c_str())
	{
		String s=description.text;
		s+ L" " + StringUtils::Float(this->slider.referenceValue);
		iMsg.tab->renderer2D->DrawText(s,this->edges.x,this->edges.y,this->edges.z/2.0f,this->edges.w);
	}

	this->BroadcastToChilds(&GuiRect::OnPaint,iMsg);
}

///////////////////////////////////////////////
///////////////////////////////////////////////
///////////GuiAnimationController//////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

GuiAnimationController::GuiAnimationController(AnimationController& iAnimationController)
	:animationController(iAnimationController),
	slider(animationController.cursor,this->animationController.start,this->animationController.end),
	play(this->animationController.play),
	stop(this->animationController.play)
{
	this->name=L"GuiAnimationController";

	this->fixed.make(0,0,0,41);//Set(0,0,0,-1,0,0,0,41,0,0,1,-1);

	//this->slider.Set(this,0,0,-1,0,0,0,26,0.5f,0,1,-1);
	this->slider.SetParent(this);
	this->slider.fixed.make(0,0,0,26);

	//this->play.Set(this,0,0,-1,0,0,15,15,0.5f,0.75f,-1,-1);
	this->play.SetParent(this);
	this->play.fixed.make(0,0,15,15);

	//this->stop.Set(this,&this->play,2,-1,20,0,15,15,-1,0.75f,-1,-1);
	this->stop.SetParent(this);
	this->stop.SetEdges(&this->play.edges.z);
	this->stop.fixed.make(20,0,15,15);

	this->stop.colorBackground=this->play.colorBackground=0x000000;
	this->stop.colorPressing=this->play.colorPressing=0xffffff;
	this->stop.colorHovering=this->play.colorHovering=0x88888888;

	this->play.updateMode=1;
	this->stop.updateMode=0;//set 0 onlyif 1
}

void GuiAnimationController::OnMouseMove(const GuiMsg& iMsg)
{
	float value=this->slider.referenceValue;

	GuiRect::OnMouseMove(iMsg);

	if(value!=this->slider.referenceValue && this->slider.pressing)
	{
		this->animationController.SetFrame(this->slider.referenceValue);
		iMsg.tab->SetDraw(2,0,this);
	}
}

void GuiAnimationController::OnButtonPressed(const GuiMsg& iMsg)
{
	if(iMsg.data==&this->play)
		this->animationController.Play();

	if(iMsg.data==&this->stop)
		this->animationController.Stop();
}

///////////////////////////////////////////////
///////////////////////////////////////////////
///////GuiPropertyAnimationController//////////
///////////////////////////////////////////////
///////////////////////////////////////////////

GuiPropertyAnimationController::GuiPropertyAnimationController(AnimationController& iAnimationController)
	:guiAnimationController(iAnimationController)
{
	this->name=L"GuiPropertyAnimationController";
	this->fixed.w=this->guiAnimationController.rect.w;//Set(0,0,0,-1,0,0,0,this->guiAnimationController.rect.w,0,0,1,-1);
	this->description.text=L"Controller";
	this->guiAnimationController.SetParent(this);
	/*this->guiAnimationController.alignPos.x=0.5f;
	this->guiAnimationController.alignRect.x=0.5f;*/
}

///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////////GuiViewport/////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

void launchStopGuiViewportCallback(void* iData)
{
	GuiViewport* guiViewport=(GuiViewport*)iData;

	bool executedWithSuccess=Ide::instance->compiler->CreateAndroidTarget();

	if(!executedWithSuccess)
		DEBUG_BREAK();

}

GuiViewport::GuiViewport():
	renderBuffer(0),
	renderBitmap(0),
	rootEntity(0),
	needsPicking(0),
	pickedEntity(0),
	playStopButton(0)
{
	this->name=L"ViewportViewer";

	this->playStopButton=new GuiButtonFunc;

	this->playStopButton->func=launchStopGuiViewportCallback;
	this->playStopButton->param=this;
	this->playStopButton->colorHovering=Renderer2D::COLOR_GUI_BACKGROUND+30;
	this->playStopButton->colorPressing=Renderer2D::COLOR_GUI_BACKGROUND+90;
	this->playStopButton->text=L"Run";
	this->playStopButton->SetEdges(0,&this->edges.y);
	this->playStopButton->fixed.make(0,0,0,20);
	//this->playStopButton->alignRect.make(1,-1);

	this->playStopButton->SetParent(this);

}
GuiViewport::~GuiViewport()
{
	SAFEDELETEARRAY(this->renderBuffer);
}

void GuiViewport::OnSize(const GuiMsg& iMsg)
{
	GuiRect::OnSize(iMsg);
}

void GuiViewport::OnPaint(const GuiMsg& iMsg)
{
	iMsg.tab->renderer3D->Render(this,false);
	this->BroadcastToChilds(&GuiRect::OnPaint,iMsg);
}

void GuiViewport::OnMouseWheel(const GuiMsg& iMsg)
{
	GuiRect::OnMouseWheel(iMsg);

	float factor=*(float*)iMsg.data;

	this->view*=mat4().translate(0,0,factor*10);
}

void GuiViewport::OnLMouseUp(const GuiMsg& iMsg)
{
	if(this->hovering/* && this->pickedEntity*/)
		Tab::BroadcastToPool(&Tab::OnGuiEntitySelected,(void*)this->pickedEntity);

	GuiRect::OnLMouseUp(iMsg);
}

void GuiViewport::OnMouseMove(const GuiMsg& iMsg)
{
	GuiRect::OnMouseMove(iMsg);

	if(this->hovering)
	{
		vec2 &mpos=*(vec2*)iMsg.data;

		if(InputManager::keyboardInput.IsPressed(0x01/*VK_LBUTTON*/))
		{
			float dX=(mpos.x-this->mouseold.x);
			float dY=(mpos.y-this->mouseold.y);

			if(InputManager::keyboardInput.IsPressed(0x011/*VK_CONTROL*/))
			{
				mat4 mview;
				vec3 vx,vy,vz;
				vec3 pos;
				mat4 rot;

				mview=this->view;

				mview.traspose();
				mview.inverse();

				mview.axes(vx,vy,vz);

				pos=this->model.position();

				this->model.move(vec3());

				if(dY)
					rot.rotate(dY,vx);
				this->model.rotate(dX,0,0,1);

				this->model*=rot;

				this->model.move(pos);
			}
			else
			{
				this->view*=mat4().translate(dX,dY,0);
			}
		}

		this->needsPicking=true;

		mouseold=mpos;
	}
}


void GuiViewport::OnActivate(const GuiMsg& iMsg)
{
	GuiRect::OnActivate(iMsg);
	iMsg.tab->renderer3D->Register(this);
}
void GuiViewport::OnDeactivate(const GuiMsg& iMsg)
{
	GuiRect::OnDeactivate(iMsg);
	iMsg.tab->renderer3D->Unregister(this);
}

void GuiViewport::OnReparent(const GuiMsg& iMsg)
{
	GuiRect::OnReparent(iMsg);
}

///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////////GuiScrollBar////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

GuiScrollBar::GuiScrollBar(unsigned int iScrollbarType):
	scrollbarType(iScrollbarType),
	guiRect(0),
	scrollerPressed(-1),
	scrollerPosition(0),
	scrollerRatio(1)
{
	this->fixed.make(0,0,this->scrollbarType==SCROLLBAR_VERTICAL ? GuiScrollBar::SCROLLBAR_TICK : 0,this->scrollbarType==SCROLLBAR_HORIZONTAL ? GuiScrollBar::SCROLLBAR_TICK : 0);
	this->name=L"ScrollBar";
}
GuiScrollBar::~GuiScrollBar()
{

}

void GuiScrollBar::SetType(unsigned int iScrollbarType)
{
	this->scrollbarType=iScrollbarType;

	this->fixed.make(0,0,this->scrollbarType==SCROLLBAR_VERTICAL ? GuiScrollBar::SCROLLBAR_TICK : 0,this->scrollbarType==SCROLLBAR_HORIZONTAL ? GuiScrollBar::SCROLLBAR_TICK : 0);
}


void GuiScrollBar::SetScrollerRatio(float contentLength,float containerLength)
{
	float oldScrollerRatio=this->scrollerRatio;

	this->scrollerRatio = (contentLength<containerLength) ? 1.0f : containerLength/contentLength;

	if(oldScrollerRatio!=this->scrollerRatio)
		SetScrollerPosition(this->scrollerPosition);
}

void GuiScrollBar::SetScrollerPosition(float positionPercent)
{
	float oldScrollerPosition=this->scrollerPosition;

	float scrollerContainerLength=this->GetContainerLength();
	float scrollerLength=this->GetScrollerLength();

	if(positionPercent+scrollerRatio>1)
		this->scrollerPosition=(scrollerContainerLength-scrollerLength)/scrollerContainerLength;
	else
		this->scrollerPosition = positionPercent < 0 ? 0 : positionPercent;
}

void GuiScrollBar::Scroll(Tab* tabContainer,float upOrDown)
{
	float rowHeightRatio=this->scrollerRatio/GuiSceneViewer::ROW_HEIGHT;

	float amount=this->scrollerPosition + (upOrDown<0 ? rowHeightRatio : -rowHeightRatio);

	this->SetScrollerPosition(amount);

	tabContainer->SetDraw(2,0,this->guiRect);
}

void GuiScrollBar::SetRect(GuiRect* iRect)
{

}

bool GuiScrollBar::IsVisible()
{
	return this->scrollerRatio<1.0f;
}

float GuiScrollBar::GetContainerLength()
{
	return	this->scrollbarType==SCROLLBAR_VERTICAL ? 
			this->rect.w-2.0f*SCROLLBAR_TIP_SIZE :
			this->rect.z-2.0f*SCROLLBAR_TIP_SIZE;
}
float GuiScrollBar::GetScrollerBegin()
{
	return this->GetContainerBegin()+this->scrollerPosition*this->GetContainerLength();
}
float GuiScrollBar::GetScrollerEnd()
{
	return this->GetScrollerBegin()+this->scrollerRatio*this->GetContainerLength();
}
float GuiScrollBar::GetScrollerLength()
{
	return this->GetScrollerEnd()-this->GetScrollerBegin();
}
float GuiScrollBar::GetContainerBegin()
{
	return	this->scrollbarType==SCROLLBAR_VERTICAL ? 
			this->rect.y+SCROLLBAR_TIP_SIZE :
			this->rect.x+SCROLLBAR_TIP_SIZE;
}
float GuiScrollBar::GetContainerEnd()
{
	return	this->scrollbarType==SCROLLBAR_VERTICAL ? 
			this->edges.w-SCROLLBAR_TIP_SIZE :
			this->edges.z-SCROLLBAR_TIP_SIZE;
}

void GuiScrollBar::OnLMouseUp(const GuiMsg& iMsg)
{
	GuiRect::OnLMouseUp(iMsg);

	this->scrollerPressed=-1;
}

void GuiScrollBar::OnLMouseDown(const GuiMsg& iMsg)
{
	GuiRect::OnLMouseDown(iMsg);

	if(!this->hovering || scrollerRatio==1.0f)
		return;

	vec2& mpos=*(vec2*)iMsg.data;

	float& tTreshold=this->scrollbarType==SCROLLBAR_VERTICAL ? mpos.y : mpos.x;

	if(tTreshold<this->GetContainerBegin())
	{
		this->Scroll(iMsg.tab,1);
	}
	else if(tTreshold<this->GetContainerEnd())
	{
		this->scrollerPressed=0;

		if(tTreshold>=this->GetScrollerBegin() && tTreshold<=this->GetScrollerEnd())
			this->scrollerPressed=((tTreshold-this->GetScrollerBegin())/this->GetScrollerLength())*this->scrollerRatio;
		else
			SetScrollerPosition((tTreshold-this->GetContainerBegin())/this->GetContainerLength());
	}
	else
	{
		this->Scroll(iMsg.tab,-1);
	}

	iMsg.tab->SetDraw(2,0,this);
	iMsg.tab->SetDraw(2,0,this->guiRect);
}

void GuiScrollBar::OnMouseMove(const GuiMsg& iMsg)
{
	GuiRect::OnMouseMove(iMsg);

	if(this->hovering && (this->scrollerRatio<1.0f && this->scrollerPressed>=0))
	{
		vec2& mpos=*(vec2*)iMsg.data;

		float& tTreshold=this->scrollbarType==SCROLLBAR_VERTICAL ? mpos.y : mpos.x;

		if(tTreshold>this->GetContainerBegin() && tTreshold<this->GetContainerEnd())
		{
			float mouseContainerTreshold=(tTreshold-this->GetContainerBegin())/this->GetContainerLength();

			this->SetScrollerPosition(mouseContainerTreshold-this->scrollerPressed);

			iMsg.tab->SetDraw(2,0,this);
			iMsg.tab->SetDraw(2,0,this->guiRect);
		}
	}
}


void GuiScrollBar::OnPaint(const GuiMsg& iMsg)
{
	if(this->scrollerRatio==1.0f)
		return;

	if(this->scrollbarType==SCROLLBAR_VERTICAL)
	{
		iMsg.tab->renderer2D->DrawRectangle(this->rect.x,this->rect.y,this->rect.x+SCROLLBAR_TICK,this->rect.y+SCROLLBAR_TIP_SIZE,Renderer2D::COLOR_GUI_BACKGROUND);
		iMsg.tab->renderer2D->DrawRectangle(this->rect.x,this->edges.w-SCROLLBAR_TIP_SIZE,this->rect.x+SCROLLBAR_TICK,this->edges.w,Renderer2D::COLOR_GUI_BACKGROUND);

		iMsg.tab->renderer2D->DrawBitmap(iMsg.tab->iconUp,this->rect.x,this->rect.y,this->rect.x+SCROLLBAR_TICK,this->rect.y+SCROLLBAR_TIP_SIZE);
		iMsg.tab->renderer2D->DrawBitmap(iMsg.tab->iconDown,this->rect.x,this->edges.w-SCROLLBAR_TIP_SIZE,this->rect.x+SCROLLBAR_TICK,this->edges.w);

		iMsg.tab->renderer2D->DrawRectangle(this->rect.x,this->GetContainerBegin(),this->rect.x+SCROLLBAR_TICK,this->GetContainerEnd(),Renderer2D::COLOR_GUI_BACKGROUND);

		iMsg.tab->renderer2D->DrawRectangle(this->rect.x,this->GetScrollerBegin(),this->rect.x+SCROLLBAR_TICK,this->GetScrollerEnd(),0x00000000);
	}
	else
	{
		iMsg.tab->renderer2D->DrawRectangle(this->rect.x,this->rect.y,this->rect.x+SCROLLBAR_TICK,this->rect.y+SCROLLBAR_TIP_SIZE,Renderer2D::COLOR_GUI_BACKGROUND);
		iMsg.tab->renderer2D->DrawRectangle(this->edges.z-SCROLLBAR_TIP_SIZE,this->rect.y,this->edges.z,this->edges.w,Renderer2D::COLOR_GUI_BACKGROUND);

		iMsg.tab->renderer2D->DrawBitmap(iMsg.tab->iconLeft,this->rect.x,this->rect.y,this->rect.x+SCROLLBAR_TICK,this->rect.y+SCROLLBAR_TIP_SIZE);
		iMsg.tab->renderer2D->DrawBitmap(iMsg.tab->iconRight,this->edges.z-SCROLLBAR_TIP_SIZE,this->rect.y,this->edges.z,this->rect.y+this->rect.w);

		iMsg.tab->renderer2D->DrawRectangle(this->GetContainerBegin(),this->rect.y,this->GetContainerEnd(),this->rect.y+SCROLLBAR_TICK,Renderer2D::COLOR_GUI_BACKGROUND);

		iMsg.tab->renderer2D->DrawRectangle(this->GetScrollerBegin(),this->rect.y,this->GetScrollerEnd(),this->rect.y+SCROLLBAR_TICK,0x00000000);
	}

	this->BroadcastToChilds(&GuiRect::OnPaint,iMsg);
}

///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////GuiSceneViewer/////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

GuiSceneViewer::GuiSceneViewer():entityRoot((EditorEntity*&)scene.entityRoot)
{
	this->entityRoot=new EditorEntity;
	this->entityRoot->name=L"SceneRootEntity";
	this->entityRoot->expanded=true;

	this->entityRoot->sceneViewerPropertyRect.SetParent(this);

	this->name=L"SceneViewer";
	this->scene.name=L"Scene";
}

GuiSceneViewer::~GuiSceneViewer()
{
	wprintf(L"destroying treeview %p\n",this);
}

void GuiSceneViewer::OnRMouseUp(const GuiMsg& iMsg)
{
	GuiRect::OnRMouseUp(iMsg);

	vec2& mpos=*(vec2*)iMsg.data;

	vec2 tDrawCanvas(-GuiRect::ROW_ADVANCE,-GuiRect::ROW_HEIGHT);

	GuiContainer*	tSelectedRect=dynamic_cast<GuiContainer*>(iMsg.tab->GetFocus());

	EditorEntity* tEditorEntity=tSelectedRect ? (EditorEntity*)tSelectedRect->GetUserData() : 0;

	int tChosedMenuIndex=iMsg.tab->TrackGuiSceneViewerPopup(tSelectedRect ? true : false);

	switch(tChosedMenuIndex)
	{
	case 1:
		{
			EditorEntity* tNewEntity=new EditorEntity;

			tNewEntity->name=L"EntityPippo";

			tNewEntity->SetParent(tEditorEntity ? tEditorEntity : this->entityRoot);
			tNewEntity->bbox.a.make(-1,-1,-1);
			tNewEntity->bbox.b.make(1,1,1);

			tNewEntity->OnPropertiesCreate();

			tEditorEntity	? 
								tEditorEntity->sceneViewerPropertyRect.AppendAsProperty(&tNewEntity->sceneViewerPropertyRect) 
							: 
								this->entityRoot->sceneViewerPropertyRect.AppendAsProperty(&tNewEntity->sceneViewerPropertyRect)
							;
		}
		break;
	case 2:tEditorEntity->parent->childs.erase(std::find(tEditorEntity->parent->childs.begin(),tEditorEntity->parent->childs.end(),tEditorEntity));break;
	case 3:tEditorEntity->CreateComponent<EditorLight>();break;
	case 4:tEditorEntity->CreateComponent<EditorMesh>();break;
	case 5:tEditorEntity->CreateComponent<EditorCamera>();break;
	case 14:tEditorEntity->CreateComponent<EditorScript>();break;
	}

	this->OnSize(iMsg);
	iMsg.tab->SetDraw(2,0,this);
}

void GuiSceneViewer::OnEntitiesChange(const GuiMsg& iMsg)
{
	EditorEntity* entity=(EditorEntity*)iMsg.data;

	if(entity)
		entity->SetParent(this->entityRoot);

	vScrollbar.SetScrollerRatio(this->contentHeight,this->rect.w);

	if(this->active)
	{
		this->OnSize(iMsg);
		iMsg.tab->SetDraw(2,0,this);
	}

	GuiRect::OnEntitiesChange(iMsg);
}

void GuiSceneViewer::OnEntitySelected(const GuiMsg& iMsg)
{
	GuiRect::OnEntitySelected(iMsg);

	EditorEntity* entity=(EditorEntity*)iMsg.data;

	/*if(entity)
	{
		if(this->selection.end()==std::find(this->selection.begin(),this->selection.end(),entity))
		{
			this->selection.clear();
			this->selection.push_back(entity);

			this->OnSize(tabContainer);

			entity->selected=true;

			entity->CreateComponent<EditorGizmo>();

			tabContainer->SetDraw(2,0,this);
		}
	}*/
}

void GuiSceneViewer::OnLMouseDown(const GuiMsg& iMsg)
{
	bool tWasHovering=this->Contains(this->rect,(vec2&)*(vec2*)iMsg.data);

	GuiScrollRect::OnLMouseDown(iMsg);

	if(tWasHovering)
	{
		GuiContainer*	tSelectedRect=dynamic_cast<GuiContainer*>(iMsg.tab->GetFocus());

		if(tSelectedRect==&this->entityRoot->sceneViewerPropertyRect)
			return;

		EditorEntity* tEditorEntity=tSelectedRect ? (EditorEntity*)tSelectedRect->GetUserData() : 0;

		if(!InputManager::keyboardInput.IsPressed(0x11/*VK_CONTROL*/))
			this->selection.clear();

		Tab::BroadcastToPool(&Tab::OnGuiEntitySelected,tEditorEntity);
		
		iMsg.tab->SetDraw(2,0,this);
	}
}

void GuiSceneViewer::OnKeyDown(const GuiMsg& iMsg)
{
	if(this==iMsg.tab->GetFocus())
	{
		if(InputManager::keyboardInput.IsPressed(0x11/*VK_CONTROL*/) && !InputManager::keyboardInput.IsPressed(0x12/*VK_ALT*/))
		{
			if(InputManager::keyboardInput.IsPressed('S'))
			{
				String tSaveFile=Ide::instance->folderProject + L"\\" + this->scene.name + Ide::instance->GetSceneExtension();
				this->Save(tSaveFile.c_str());
			}
		}
	}

	GuiScrollRect::OnKeyDown(iMsg);
}

void saveEntityRecursively(Entity* iEntity,FILE* iFile)
{
	int childsSize=iEntity->childs.size();
	int componentsSize=iEntity->components.size();
	int nameCount=iEntity->name.size();

	fwrite(&childsSize,sizeof(int),1,iFile);//4

	fwrite(iEntity->local,sizeof(float),16,iFile);//64
	fwrite(iEntity->world,sizeof(float),16,iFile);//64

	StringUtils::WriteWstring(iFile,iEntity->name);

	fwrite(iEntity->bbox.a,sizeof(float),3,iFile);//12
	fwrite(iEntity->bbox.b,sizeof(float),3,iFile);//12

	fwrite(&componentsSize,sizeof(int),1,iFile);//4

	for(std::vector<EntityComponent*>::iterator cIter=iEntity->components.begin();cIter!=iEntity->components.end();cIter++)
	{
		if((*cIter)->is<Script>())
		{
			Script* tScript=(Script*)(*cIter);

			fwrite(&Serialization::Script,sizeof(unsigned char),1,iFile);//1

			StringUtils::WriteWstring(iFile,tScript->file);
		}
		else
			fwrite(&Serialization::Unknown,sizeof(unsigned char),1,iFile);//1
	}

	if(childsSize)
	{
		for(std::list<Entity*>::iterator eIter=iEntity->childs.begin();eIter!=iEntity->childs.end();eIter++)
			saveEntityRecursively(*eIter,iFile);
	}
}

EditorEntity* loadEntityRecursively(EditorEntity* iEditorEntityParent,FILE* iFile)
{
	int nameCount;
	int componentsSize;
	int childsSize;
	unsigned char componentCode;

	EditorEntity* tEditorEntity=new EditorEntity;

	tEditorEntity->SetParent(iEditorEntityParent);

	fread(&childsSize,sizeof(int),1,iFile);//4

	fread(tEditorEntity->local,sizeof(float),16,iFile);//64
	fread(tEditorEntity->world,sizeof(float),16,iFile);//64

	StringUtils::ReadWstring(iFile,tEditorEntity->name);

	fread(tEditorEntity->bbox.a,sizeof(float),3,iFile);//12
	fread(tEditorEntity->bbox.b,sizeof(float),3,iFile);//12

	tEditorEntity->OnResourcesCreate();
	tEditorEntity->OnPropertiesCreate();

	fread(&componentsSize,sizeof(int),1,iFile);//4

	for(int i=0;i<componentsSize;i++)
	{
		fread(&componentCode,sizeof(unsigned char),1,iFile);//1

		if(componentCode==Serialization::Script)
		{
			EditorScript* tScript=tEditorEntity->CreateComponent<EditorScript>();
			StringUtils::ReadWstring(iFile,tScript->file);
		}
	}

	if(childsSize)
	{
		for(int i=0;i<childsSize;i++)
			loadEntityRecursively(tEditorEntity,iFile);
	}

	return tEditorEntity;
}

void GuiSceneViewer::Save(String iFilename)
{
	File tScriptFile(iFilename);

	if(tScriptFile.Open(L"wb"))
	{
		saveEntityRecursively(this->entityRoot,tScriptFile);
		tScriptFile.Close();
	}
}

void GuiSceneViewer::Load(String iFilename)
{
	File tScriptFile(iFilename);

	if(tScriptFile.Open(L"rb"))
	{
		for(std::list<Entity*>::iterator i=this->entityRoot->childs.begin();i!=this->entityRoot->childs.end();)
			i=this->entityRoot->childs.erase(i);

		EditorEntity* tEntity=loadEntityRecursively(0,tScriptFile);

		std::list<Entity*> tChildsCopy=tEntity->childs;

		for(std::list<Entity*>::iterator i=tChildsCopy.begin();i!=tChildsCopy.end();i++)
			(*i)->SetParent(this->entityRoot);

		SAFEDELETE(tEntity);

		if(this->active)
		{
			Tab* tab=this->GetRootRect()->tabContainer;

			this->OnSize(GuiMsg(tab,this,0,&GuiRect::OnSize,0));
			tab->SetDraw(2,0,this);
		}

		tScriptFile.Close();
	}
}

///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////GuiEntityViewer/////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

GuiEntityViewer::GuiEntityViewer():
entity(0),tabContainer(0)
{
	this->name=L"EntityViewer";
};

GuiEntityViewer::~GuiEntityViewer()
{
	wprintf(L"destroying properties %p\n",this);
}

void GuiEntityViewer::OnEntitySelected(const GuiMsg& iMsg)
{
	EditorEntity* iEntity=(EditorEntity*)iMsg.data;

	GuiMsg tMsg(iMsg.tab,this);

	if(this->entity!=iEntity)
	{
		if(this->entity)
		{
			this->BroadcastToChilds(&GuiRect::OnDeactivate,tMsg);
			this->entity->entityViewerRootPropertyRect.SetParent(0);
			this->entity=0;
		}

		if(iEntity)
		{
			this->entity=iEntity;
			this->entity->entityViewerRootPropertyRect.SetParent(this);

			this->vScrollbar.SetScrollerPosition(0);
			this->hScrollbar.SetScrollerPosition(0);

			this->OnSize(GuiMsg(iMsg.tab,this));
			this->entity->entityViewerRootPropertyRect.OnActivate(tMsg);
		}
		else
		{
			this->OnSize(tMsg);
		}
		
		iMsg.tab->SetDraw(2,0,this);
	}
	else
	{
		this->OnSize(tMsg);

		iMsg.tab->SetDraw(2,0,this);
	}

	GuiRect::OnEntitySelected(iMsg);
}

void GuiEntityViewer::OnExpandos(const GuiMsg& iMsg)
{
	this->OnSize(iMsg);
}

void GuiEntityViewer::OnActivate(const GuiMsg& iMsg)
{
	tabContainer=iMsg.tab;

	GuiRect::OnActivate(iMsg);
}


///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////GuiProjectViewer////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

extern ResourceNodeDir rootProjectDirectory;

GuiProjectViewer::GuiProjectViewer():
	projectDirectory(&rootProjectDirectory),
	splitterLeftActive(false),
	splitterRightActive(false),
	splitterLeft(0),
	splitterRight(0)
{
	this->name=L"ProjectViewer";

	this->dirViewer.projectViewer=this;
	this->fileViewer.projectViewer=this;
	this->resViewer.projectViewer=this;

	const float tHalfSplit=2;

	this->dirViewer.SetParent(this);
	this->dirViewer.SetEdges(0,0,&this->splitterLeft);
	this->dirViewer.offsets.make(0,0,-tHalfSplit,0);

	this->fileViewer.SetParent(this);
	this->fileViewer.SetEdges(&this->splitterLeft,0,&this->splitterRight);
	this->fileViewer.offsets.make(tHalfSplit,0,-tHalfSplit,0);

	this->resViewer.SetParent(this);
	this->resViewer.SetEdges(&this->splitterRight);
	this->resViewer.offsets.make(tHalfSplit,0,0,0);

	this->projectDirectory->fileName=Ide::instance->folderProject;
	this->projectDirectory->expanded=true;
	this->projectDirectory->isDir=true;

	dirViewer.rootResource=this->projectDirectory;
	fileViewer.rootResource=this->projectDirectory;

	dirViewer.selectedDirs.push_back(this->projectDirectory);
}

GuiProjectViewer::~GuiProjectViewer()
{
	wprintf(L"destroying resources %p\n",this);
}



void GuiProjectViewer::OnActivate(const GuiMsg& iMsg)
{
	if(!this->active)
	{
		Ide::instance->ScanDir(this->projectDirectory->fileName,this->projectDirectory);

		this->dirViewer.CalcNodesHeight(this->projectDirectory);
		this->fileViewer.CalcNodesHeight(this->projectDirectory);

		this->OnSize(GuiMsg(iMsg.tab,this));
	}

	GuiRect::OnActivate(iMsg);
}

void GuiProjectViewer::OnDeactivate(const GuiMsg& iMsg)
{
	if(this->active)
	{
		this->projectDirectory->files.erase(this->projectDirectory->files.begin(),this->projectDirectory->files.end());
		this->projectDirectory->dirs.erase(this->projectDirectory->dirs.begin(),this->projectDirectory->dirs.end());
	}

	GuiRect::OnDeactivate(iMsg);
}


void GuiProjectViewer::OnLMouseDown(const GuiMsg& iMsg)
{
	GuiRect::OnLMouseDown(iMsg);

	if(this->hovering)
	{
		vec2& mpos=*(vec2*)iMsg.data;

		if(mpos.x>this->dirViewer.edges.z && mpos.x<this->fileViewer.edges.x)
		{
			this->splitterLeftActive=true;
		}
		else if(mpos.x>this->fileViewer.edges.z && mpos.x<this->resViewer.edges.x)
		{
			this->splitterRightActive=true;
		}
	}
}

void GuiProjectViewer::OnLMouseUp(const GuiMsg& iMsg)
{
	GuiRect::OnLMouseUp(iMsg);

	if(this->pressing || this->splitterLeftActive || this->splitterRightActive)
	{
		this->splitterLeftActive=false;
		this->splitterRightActive=false;
	}
}

void GuiProjectViewer::OnMouseMove(const GuiMsg& iMsg)
{
	GuiRect::OnMouseMove(iMsg);

	if(this->hovering || this->splitterLeftActive || this->splitterRightActive)
	{
		iMsg.tab->SetCursor(1);

		if(this->pressing)
		{
			vec2& mpos=*(vec2*)iMsg.data;

			if(this->splitterLeftActive)
			{
				this->splitterLeft=mpos.x;

				this->dirViewer.OnSize(iMsg);
				this->fileViewer.OnSize(iMsg);
			}
			if(this->splitterRightActive)
			{
				this->splitterRight=mpos.x;

				this->fileViewer.OnSize(iMsg);
				this->resViewer.OnSize(iMsg);
			}

			iMsg.tab->SetDraw(1,0,0);
		}
	}
}

void GuiProjectViewer::OnReparent(const GuiMsg& iMsg)
{
	GuiRect::OnReparent(iMsg);

	iMsg.tab->OnGuiSize();
	iMsg.tab->OnGuiRecreateTarget();
}


void GuiProjectViewer::OnPaint(const GuiMsg& iMsg)
{
	iMsg.tab->renderer2D->DrawRectangle(this->rect,Renderer2D::COLOR_MAIN_BACKGROUND,true);

	this->BroadcastToChilds(&GuiRect::OnPaint,iMsg);
}

void GuiProjectViewer::OnSize(const GuiMsg& iMsg)
{
	GuiRect::OnSize(iMsg);

	float tPanelsSizeWidth=this->rect.z/3.0f - 2*4;

	this->splitterLeft=tPanelsSizeWidth;
	this->splitterRight=tPanelsSizeWidth*2;

	this->dirViewer.OnSize(iMsg);
	this->fileViewer.OnSize(iMsg);
	this->resViewer.OnSize(iMsg);
}


/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
///////////////GuiProjectViewer::GuiProjectDirViewer/////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////


void GuiProjectViewer::DirViewer::DrawNodes(Tab* tabContainer,ResourceNodeDir* node,vec2& pos,bool& terminated)
{
	if(terminated)
		return;

	float drawFromHeight=this->vScrollbar.scrollerPosition*this->contentHeight;

	if(pos.y+ROW_HEIGHT>=drawFromHeight && pos.y<=drawFromHeight+this->rect.w)
	{
		float relativeY=this->rect.y+pos.y-drawFromHeight;

		if(node->selectedLeft)
			tabContainer->renderer2D->DrawRectangle(this->rect.x,relativeY,this->rect.x+this->rect.z,(float)relativeY+GuiSceneViewer::ROW_HEIGHT,Renderer2D::COLOR_TAB_SELECTED);

		float xCursor=this->rect.x+ROW_ADVANCE*node->level;

		if(node->dirs.size())
		{
			tabContainer->renderer2D->DrawBitmap(node->expanded ? tabContainer->iconDown : tabContainer->iconRight,xCursor,relativeY,xCursor+Tab::CONTAINER_ICON_WH,relativeY+GuiSceneViewer::ROW_HEIGHT);
			xCursor+=ROW_ADVANCE;
		}

		tabContainer->renderer2D->DrawBitmap(tabContainer->iconFolder,xCursor,relativeY,xCursor+Tab::CONTAINER_ICON_WH,relativeY+GuiSceneViewer::ROW_HEIGHT);

		xCursor+=ROW_ADVANCE;

		tabContainer->renderer2D->DrawText(node->fileName,xCursor,relativeY,this->rect.z,relativeY+GuiSceneViewer::ROW_HEIGHT,vec2(0,0.5f),vec2(0,0.5f),Renderer2D::COLOR_TEXT);


	}

	pos.y+=ROW_HEIGHT;

	if(pos.y>drawFromHeight+this->rect.w)
	{
		terminated=true;
		return;
	}

	if(node->expanded)
	{
		for(std::list<ResourceNodeDir*>::iterator nCh=node->dirs.begin();nCh!=node->dirs.end();nCh++)
			this->DrawNodes(tabContainer,*nCh,pos,terminated);
	}

	return;
}

int GuiProjectViewer::DirViewer::CalcNodesHeight(ResourceNodeDir* node)
{
	if(!node)
		return 0;

	if(node==this->rootResource)
		this->contentHeight=0;

	this->contentHeight += node->isDir  ? ROW_HEIGHT : 0;

	if(node->expanded)
	{
		for(std::list<ResourceNodeDir*>::iterator nCh=node->dirs.begin();nCh!=node->dirs.end();nCh++)
			this->CalcNodesHeight(*nCh);
	}

	return this->contentHeight;
}

void GuiProjectViewer::DirViewer::UnselectNodes(ResourceNodeDir* node)
{
	if(!node)
		return;

	node->selectedLeft=false;

	for(std::list<ResourceNode*>::iterator nCh=node->files.begin();nCh!=node->files.end();nCh++)
		(*nCh)->selectedLeft=0;

	for(std::list<ResourceNodeDir*>::iterator nCh=node->dirs.begin();nCh!=node->dirs.end();nCh++)
		this->UnselectNodes(*nCh);
}

ResourceNodeDir* GuiProjectViewer::DirViewer::GetHoveredRow(ResourceNodeDir* iResourceNodeDirNode,vec2& iMousePos,vec2& iFramePos,bool& oExpandos)
{
	float tDrawFromHeight=this->vScrollbar.scrollerPosition*this->contentHeight;

	if(iFramePos.y+ROW_HEIGHT>=tDrawFromHeight && iFramePos.y<=tDrawFromHeight+this->rect.w)
	{
		float tRelativeY=this->rect.y+iFramePos.y-tDrawFromHeight;

		float tCursor=this->rect.x+iFramePos.x+ROW_ADVANCE*iResourceNodeDirNode->level;

		oExpandos= iResourceNodeDirNode->dirs.size() && (iMousePos.x>tCursor && iMousePos.x<tCursor+ROW_ADVANCE);

		if(iMousePos.y>tRelativeY && iMousePos.y<tRelativeY+GuiSceneViewer::ROW_HEIGHT)
			return iResourceNodeDirNode;
	}

	iFramePos.y+=ROW_HEIGHT;

	if(iResourceNodeDirNode->expanded)
	{
		for(std::list<ResourceNodeDir*>::iterator nCh=iResourceNodeDirNode->dirs.begin();nCh!=iResourceNodeDirNode->dirs.end();nCh++)
		{
			ResourceNodeDir* tHoveredEntity=this->GetHoveredRow((ResourceNodeDir*)*nCh,iMousePos,iFramePos,oExpandos);
			if(tHoveredEntity)
				return tHoveredEntity;
		}
	}

	return 0;
}

void GuiProjectViewer::DirViewer::OnLMouseDown(const GuiMsg& iMsg)
{
	GuiRect::OnLMouseDown(iMsg);

	if(!this->hovering)
		return;

	vec2& tMousePos=*(vec2*)iMsg.data;

	vec2 tDrawCanvas(0,0);

	bool tResourceNodeDirExpanded=false;

	ResourceNodeDir* tResourceNodeDir=this->GetHoveredRow(this->rootResource,tMousePos,tDrawCanvas,tResourceNodeDirExpanded);

	if(tResourceNodeDir)
	{
		if(!tResourceNodeDirExpanded)
		{
			FileViewer& tFileViewer=this->projectViewer->fileViewer;

			this->UnselectNodes(this->rootResource);

			if(!tResourceNodeDir->selectedLeft)
				tResourceNodeDir->selectedLeft=true;

			this->CalcNodesHeight(this->rootResource);
			this->OnSize(iMsg);

			tFileViewer.rootResource=tResourceNodeDir;

			tFileViewer.CalcNodesHeight(tFileViewer.rootResource);
			tFileViewer.OnSize(iMsg);

			iMsg.tab->SetDraw(2,0,&tFileViewer);
		}
		else
			tResourceNodeDir->expanded=!tResourceNodeDir->expanded;

		if(!InputManager::keyboardInput.IsPressed(0x11/*VK_CONTROL*/))
			this->selectedDirs.clear();

		this->selectedDirs.push_back(tResourceNodeDir);

		iMsg.tab->SetDraw(2,0,this);
	}
}

void GuiProjectViewer::DirViewer::OnPaint(const GuiMsg& iMsg)
{
	this->DrawBackground(iMsg.tab);

	iMsg.tab->renderer2D->PushScissor(this->rect.x,this->rect.y,this->rect.x+this->rect.z,this->rect.y+this->rect.w);

	vec2 tDrawCanvas(0,0);

	bool terminated=false;
	this->DrawNodes(iMsg.tab,this->rootResource,tDrawCanvas,terminated);

	iMsg.tab->renderer2D->PopScissor();

	this->BroadcastToChilds(&GuiRect::OnPaint,iMsg);
}


/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
///////////////GuiProjectViewer::GuiProjectDirViewer/////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////

void GuiProjectViewer::FileViewer::DrawNodes(Tab* tabContainer,ResourceNodeDir* _node,vec2& pos)
{
	float drawFromHeight=this->vScrollbar.scrollerPosition*this->contentHeight;

	for(std::list<ResourceNodeDir*>::iterator nCh=_node->dirs.begin();nCh!=_node->dirs.end();nCh++)
	{
		if(pos.y+ROW_HEIGHT>=drawFromHeight && pos.y<=drawFromHeight+this->rect.w)
		{
			float relativeY=this->rect.y+pos.y-drawFromHeight;

			ResourceNodeDir* node=(*nCh);

			if(node->selectedRight)
				tabContainer->renderer2D->DrawRectangle(this->rect.x,relativeY,this->rect.x+this->rect.z,(float)relativeY+GuiSceneViewer::ROW_HEIGHT,Renderer2D::COLOR_TAB_SELECTED);

			float xCursor=this->rect.x;

			tabContainer->renderer2D->DrawBitmap(tabContainer->iconFolder,xCursor,relativeY,xCursor+Tab::CONTAINER_ICON_WH,relativeY+GuiSceneViewer::ROW_HEIGHT);

			xCursor+=ROW_ADVANCE;

			tabContainer->renderer2D->DrawText(node->fileName,xCursor,relativeY,xCursor+this->rect.z,relativeY+GuiSceneViewer::ROW_HEIGHT,vec2(0,0.5f),vec2(0,0.5f),Renderer2D::COLOR_TEXT);
		}
		else if(pos.y>drawFromHeight)
			return;

		pos.y+=ROW_HEIGHT;
	}

	for(std::list<ResourceNode*>::iterator nCh=_node->files.begin();nCh!=_node->files.end();nCh++)
	{
		if(pos.y+ROW_HEIGHT>=drawFromHeight && pos.y<=drawFromHeight+this->rect.w)
		{
			float relativeY=this->rect.y+pos.y-drawFromHeight;

			ResourceNode* node=(*nCh);

			if(node->selectedRight)
				tabContainer->renderer2D->DrawRectangle(this->rect.x,relativeY,this->rect.x+this->rect.z,relativeY+GuiSceneViewer::ROW_HEIGHT,Renderer2D::COLOR_TAB_SELECTED);

			float xCursor=this->rect.x;
			tabContainer->renderer2D->DrawBitmap(tabContainer->iconFile,xCursor,relativeY,xCursor+Tab::CONTAINER_ICON_WH,relativeY+GuiSceneViewer::ROW_HEIGHT);

			xCursor+=ROW_ADVANCE;

			tabContainer->renderer2D->DrawText(node->fileName,xCursor,relativeY,xCursor+rect.z,relativeY+GuiSceneViewer::ROW_HEIGHT,vec2(0,0.5f),vec2(0,0.5f),Renderer2D::COLOR_TEXT);
		}
		else if(pos.y>drawFromHeight)
			return;

		pos.y+=ROW_HEIGHT;
	}

	return;
}

int GuiProjectViewer::FileViewer::CalcNodesHeight(ResourceNodeDir* node)
{
	if(!node)
		return 0;

	return this->contentHeight=(node->dirs.size() + node->files.size())*ROW_HEIGHT;
}

void GuiProjectViewer::FileViewer::UnselectNodes(ResourceNodeDir* node)
{
	if(!node)
		return;

	node->selectedRight=false;

	for(std::list<ResourceNode*>::iterator nCh=node->files.begin();nCh!=node->files.end();nCh++)
		(*nCh)->selectedRight=0;

	for(std::list<ResourceNodeDir*>::iterator nCh=node->dirs.begin();nCh!=node->dirs.end();nCh++)
		this->UnselectNodes(*nCh);
}




ResourceNode* GuiProjectViewer::FileViewer::GetHoveredRow(ResourceNodeDir* iResourceNodeDirNode,vec2& iMousePos,vec2& iFramePos,bool& oExpandos)
{
	float drawFromHeight=this->vScrollbar.scrollerPosition*this->contentHeight;

	for(std::list<ResourceNodeDir*>::iterator dir=iResourceNodeDirNode->dirs.begin();dir!=iResourceNodeDirNode->dirs.end();dir++)
	{
		if(iFramePos.y+ROW_HEIGHT>=drawFromHeight && iFramePos.y<=drawFromHeight+this->rect.w)
		{
			float relativeY=this->rect.y+iFramePos.y-drawFromHeight;

			ResourceNodeDir* node=(*dir);

			float xCursor=this->rect.x+ROW_ADVANCE*node->level;

			if(iMousePos.y>relativeY && iMousePos.y<relativeY+GuiSceneViewer::ROW_HEIGHT)
				return node;
		}

		iFramePos.y+=ROW_HEIGHT;
	}

	for(std::list<ResourceNode*>::iterator file=iResourceNodeDirNode->files.begin();file!=iResourceNodeDirNode->files.end();file++)
	{
		if(iFramePos.y+ROW_HEIGHT>=drawFromHeight && iFramePos.y<=drawFromHeight+this->rect.w)
		{
			float relativeY=this->rect.y+iFramePos.y-drawFromHeight;

			ResourceNode* node=(*file);

			float xCursor=this->rect.x+ROW_ADVANCE*node->level;

			if(iMousePos.y>relativeY && iMousePos.y<relativeY+GuiSceneViewer::ROW_HEIGHT)
				return node;

		}

		iFramePos.y+=ROW_HEIGHT;
	}

	return 0;
}
void GuiProjectViewer::FileViewer::OnLMouseDown(const GuiMsg& iMsg)
{
	if(this->hovering)
	{
		vec2& mpos=*(vec2*)iMsg.data;

		if(!InputManager::keyboardInput.IsPressed(0x11/*VK_CONTROL*/))
			this->selectedFiles.clear();

		vec2 tDrawCanvas(0,0);

		bool exp=false;
		ResourceNode* node=this->GetHoveredRow(this->rootResource,mpos,tDrawCanvas,exp);

		if(node)
		{
			this->UnselectNodes(this->rootResource);

			if(!node->selectedRight)
				node->selectedRight=true;

			if(exp)
			{
				this->CalcNodesHeight(this->rootResource);
				this->OnSize(iMsg);
			}

			this->selectedFiles.push_back(node);

			//TabContainer::BroadcastToPool(&TabContainer::OnGuiEntitySelected,this->selection[0]);
		}
		else
		{
			this->UnselectNodes(this->rootResource);
		}

		iMsg.tab->SetDraw(2,0,this);
	}

	GuiRect::OnLMouseDown(iMsg);
}
void GuiProjectViewer::FileViewer::OnRMouseUp(const GuiMsg& iMsg)
{
	GuiRect::OnRMouseUp(iMsg);

	vec2& mpos=*(vec2*)iMsg.data;

	vec2 tDrawCanvas(0,0);

	bool tHoveredResourceNodeExpandedPressed=false;
	ResourceNode* tHoveredResourceNode=this->GetHoveredRow(this->rootResource,mpos,tDrawCanvas,tHoveredResourceNodeExpandedPressed);

	int menuResult=iMsg.tab->TrackProjectFileViewerPopup(tHoveredResourceNode);

	switch(menuResult)
	{
		case 1:
			if(tHoveredResourceNode && tHoveredResourceNode->parent)
			{
				ResourceNodeDir* parentDirectory=(ResourceNodeDir*)tHoveredResourceNode->parent;

				String tFileNameBase=tHoveredResourceNode->parent->fileName + L"\\" + tHoveredResourceNode->fileName;
                String tFileNameBaseExtended=tFileNameBase + Ide::instance->GetEntityExtension();

				//first remove from the list

				if(tHoveredResourceNode->isDir)
                {
                    parentDirectory->dirs.remove((ResourceNodeDir*)tHoveredResourceNode);

                    Ide::instance->subsystem->Execute(parentDirectory->fileName.c_str(),L"rd /S /Q " + tHoveredResourceNode->fileName);
                }
				else
                {
                    parentDirectory->files.remove(tHoveredResourceNode);

                    File::Delete(tFileNameBase.c_str());
                    File::Delete(tFileNameBaseExtended.c_str());
                }

				SAFEDELETE(tHoveredResourceNode);
			}
		break;
		case 3://load
			if(tHoveredResourceNode->fileName.PointedExtension() == Ide::instance->GetSceneExtension())
			{
				GuiSceneViewer* tGuiSceneViewer=GuiSceneViewer::GetPool().front();

				if(tGuiSceneViewer)
				{
					String tHoveredNodeFilename=tHoveredResourceNode->parent->fileName + L"\\" + tHoveredResourceNode->fileName;

					tGuiSceneViewer->Load(tHoveredNodeFilename.c_str());
					tGuiSceneViewer->GetRootRect()->tabContainer->SetDraw(2,0,tGuiSceneViewer);
				}
			}
		break;
	}

	this->OnSize(iMsg);
	iMsg.tab->SetDraw(2,0,this);
}



void GuiProjectViewer::FileViewer::OnPaint(const GuiMsg& iMsg)
{
	this->DrawBackground(iMsg.tab);

	iMsg.tab->renderer2D->PushScissor(this->rect.x,this->rect.y,this->rect.x+this->rect.z,this->rect.y+this->rect.w);

	vec2 tDrawCanvas(0,0);

	this->DrawNodes(iMsg.tab,this->rootResource,tDrawCanvas);

	iMsg.tab->renderer2D->PopScissor();

	this->BroadcastToChilds(&GuiRect::OnPaint,iMsg);
}

void GuiProjectViewer::FileViewer::OnDLMouseDown(const GuiMsg& iMsg)
{
	if(this==iMsg.tab->GetFocus())
	{
		vec2& mpos=*(vec2*)iMsg.data;

		vec2 tDrawCanvas(0,0);

		bool tHoveredResourceNodeExpandedPressed=false;
		ResourceNode* tHoveredResourceNode=this->GetHoveredRow(this->rootResource,mpos,tDrawCanvas,tHoveredResourceNodeExpandedPressed);

		if(tHoveredResourceNode)
		{
			if(!tHoveredResourceNode->isDir)
			{
				String tExtension=tHoveredResourceNode->fileName.Extension();
				String tFilename=tHoveredResourceNode->parent->fileName + L"\\" + tHoveredResourceNode->fileName;

				if(tExtension == &Ide::instance->GetSceneExtension()[1])
				{
					Thread* renderThread=GuiViewport::GetPool()[0]->GetRootRect()->tabContainer->threadRender;
					Task* drawTask=GuiViewport::GetPool()[0]->GetRootRect()->tabContainer->taskDraw;

					drawTask->Block(true);

					GuiSceneViewer* guiSceneViewer=iMsg.tab->parentWindowContainer->SpawnViewer<GuiSceneViewer>();
					guiSceneViewer->Load(tFilename);

					drawTask->Block(false);

					//guiSceneViewer->GetRootRect()->tabContainer->SetDraw(2,0,guiSceneViewer);
				}
				else if(tExtension==L"cpp")
				{
					/*GuiScriptViewer* guiScriptViewer=tabContainer->parentWindowContainer->SpawnViewer<GuiScriptViewer>();
					guiScriptViewer->Open(tFilename);
					guiScriptViewer->GetRootRect()->tabContainer->SetDraw(2,0,guiScriptViewer);*/
				}
			}
			else
			{
				ResourceNodeDir* tResourceNodeDir=(ResourceNodeDir*)tHoveredResourceNode;

				DirViewer& tDirViewer=this->projectViewer->dirViewer;

				tDirViewer.UnselectNodes(tDirViewer.rootResource);

				if(!tResourceNodeDir->selectedLeft)
					tResourceNodeDir->selectedLeft=true;

				tDirViewer.CalcNodesHeight(tDirViewer.rootResource);
				tDirViewer.OnSize(iMsg);

				this->rootResource=tResourceNodeDir;

				this->CalcNodesHeight(this->rootResource);
				this->OnSize(iMsg);

				iMsg.tab->SetDraw(2,0,&tDirViewer);
				iMsg.tab->SetDraw(2,0,this);
			}
		}
	}

	GuiRect::OnDLMouseDown(iMsg);
}

///////////////////////////////////////////////
///////////////////////////////////////////////
//////////////////////GuiImage/////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////
GuiImage::GuiImage():
width(0),
height(0),
bpp(0)
{}

GuiImage::~GuiImage()
{
	this->width=-1;
	this->height=-1;
	this->bpp=-1;
}

///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////DrawInstance/////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////


DrawInstance::DrawInstance(int iNoneAllRect,bool iFrame,GuiRect* iRect,String iName,bool iRemove):code(iNoneAllRect),frame(iFrame),rect(iRect),name(iName),remove(iRemove){}

///////////////////////////////////////////////
///////////////////////////////////////////////
////////////////////GuiPaper///////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

GuiPaper::GuiPaper():lineCount(0),lineNumbers(true)
{
	this->textSpot.make(0,0);
	this->textAlign.make(0,0);
}

void GuiPaper::DrawLineNumbers(Tab* tabContainer)
{
	float tTextHeight=tabContainer->renderer2D->GetFontHeight();
	float tRowY=this->rect.y;
	float tRowW=0;

	String tLastLine=StringUtils::Int(this->lineCount);

	vec2 tLastLineTextRect=tabContainer->renderer2D->MeasureText(tLastLine.c_str());

	tRowW=tLastLineTextRect.x;

	for(int i=0;i<this->lineCount;i++)
	{
		int tInteger=i+1;
		tabContainer->renderer2D->DrawText(StringUtils::Int(tInteger),this->rect.x,tRowY,this->rect.x + tRowW,tRowY + tTextHeight,vec2(0,0.5f),vec2(0,0.5f));
		tRowY+=tTextHeight;
	}
}

void GuiPaper::DrawBreakpoints(Tab* tabContainer)
{
	float tFontHeight=tabContainer->renderer2D->GetFontHeight();

	std::vector<Debugger::Breakpoint>& breakpoints=Ide::instance->debugger->breakpointSet;

	for(size_t i=0;i<breakpoints.size();i++)
	{
		if(breakpoints[i].script==this->scriptViewer->script)
		{
			unsigned int tLineInsertion=this->rect.y + (breakpoints[i].line - 1) * tFontHeight;

			unsigned int tBreakColor = breakpoints[i].breaked ? 0xff0000 : 0xffff00 ;

			tabContainer->renderer2D->DrawRectangle(this->rect.x + 1,tLineInsertion + 1,this->rect.x+this->textOffsets.x -1,tLineInsertion + tFontHeight - 1,tBreakColor,true);
		}
	}
}

void GuiPaper::OnPaint(const GuiMsg& iMsg)
{
	this->DrawBackground(iMsg.tab);

	this->DrawBreakpoints(iMsg.tab);

	if(this->lineNumbers)
		this->DrawLineNumbers(iMsg.tab);

	this->DrawTheText(iMsg.tab);

	this->BroadcastToChilds(&GuiRect::OnPaint,iMsg);
}

void GuiPaper::OnLMouseDown(const GuiMsg& iMsg)
{
	GuiString::OnLMouseDown(iMsg);

	vec2 tMpos=*(vec2*)iMsg.data;

	if(tMpos.x < this->textOffsets.x)
	{
		unsigned int tBreakOnLine=(tMpos.y-this->rect.y)/iMsg.tab->renderer2D->GetFontHeight() + 1;

		EditorScript* tEditorScript=(EditorScript*)this->scriptViewer->script;

		std::vector<Debugger::Breakpoint>& tAvailableBreakpoints=Ide::instance->debugger->allAvailableBreakpoints;
		std::vector<Debugger::Breakpoint>& tBreakpoints=Ide::instance->debugger->breakpointSet;

		for(size_t i=0;i<tAvailableBreakpoints.size();i++)
		{
			if(tAvailableBreakpoints[i].script==this->scriptViewer->script && tAvailableBreakpoints[i].line==tBreakOnLine)
			{
				std::vector<Debugger::Breakpoint>::iterator tFoundedBreakpointIterator=std::find(tBreakpoints.begin(),tBreakpoints.end(),tAvailableBreakpoints[i]);

				bool tAdd=tBreakpoints.end()==tFoundedBreakpointIterator;

				if(tAdd)
					tBreakpoints.push_back(tAvailableBreakpoints[i]);
				else
					tBreakpoints.erase(tFoundedBreakpointIterator);

				Ide::instance->debugger->SetBreakpoint(tAvailableBreakpoints[i],tAdd);

				iMsg.tab->SetDraw(2,false,this->scriptViewer);

				break;
			}
		}
	}
}

///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////GuiScriptViewer/////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

GuiScriptViewer::GuiScriptViewer():
	script(0),
	lineNumbers(true)
{
	this->name=L"ScriptViewer";

	this->paper=this->Create<GuiPaper>();
	this->paper->scriptViewer=this;
	this->paper->name=L"ScriptSource";
	this->paper->textOffsets.make(20,0,0,0);
}

void GuiScriptViewer::Open(Script* iScript)
{
	this->script=(EditorScript*)iScript;
	this->paper->cursor=StringEditor::Cursor();

	this->paper->text=StringUtils::ReadCharFile(iScript->file);

	this->paper->cursor.cursor=this->paper->text->c_str();
	this->paper->cursor.rowcol.make(0,0);

	Ide::instance->stringEditor->Bind(this->paper,&this->paper->cursor);

	this->script->scriptViewer=this;
}

bool GuiScriptViewer::Save()
{
	if(this->script)
	{
		File tScriptFile(this->script->file);

		if(tScriptFile.Open(L"wb"))
		{
			tScriptFile.Write((void*)this->paper->text->c_str(),sizeof(wchar_t),this->paper->text->size());

			tScriptFile.Close();

			return true;
		}
		else
			DEBUG_BREAK();
	}

	return false;
}


bool GuiScriptViewer::Compile()
{
	bool exited=false;
	bool compiled=false;
	bool runned=false;

	if(this->script)
	{
		exited=Ide::instance->compiler->UnloadScript(this->script);

		compiled=Ide::instance->compiler->Compile(this->script);

		runned=Ide::instance->compiler->LoadScript(this->script);
	}

	return exited && compiled && runned;
}



void GuiScriptViewer::OnKeyDown(const GuiMsg& iMsg)
{
	if(this->script)
	{
		if(InputManager::keyboardInput.IsPressed(0x11/*VK_CONTROL*/) && !InputManager::keyboardInput.IsPressed(0x12/*VK_ALT*/))
		{
			if(InputManager::keyboardInput.IsPressed('S'))
				this->Save();
		}
		else
		{
			bool tRedraw=this->paper->ParseKeyInput(iMsg);

			if(tRedraw)
				iMsg.tab->SetDraw(2,0,this);
		}
	}

	GuiRect::OnKeyDown(iMsg);
}

void GuiScriptViewer::OnKeyUp(const GuiMsg& iMsg)
{
	GuiRect::OnKeyUp(iMsg);
}

void GuiScriptViewer::OnLMouseDown(const GuiMsg& iMsg)
{
	GuiRect::OnLMouseDown(iMsg);

	vec2 tMpos=*(vec2*)iMsg.data;

	iMsg.tab->SetFocus(this->paper);

	Ide::instance->stringEditor->Bind(this->paper,&this->paper->cursor);
	Ide::instance->stringEditor->Enable(true);
}

void GuiScriptViewer::OnDeactivate(const GuiMsg& iMsg)
{
	iMsg.tab->SetFocus(0);
	Ide::instance->stringEditor->Enable(false);

	GuiRect::OnDeactivate(iMsg);
}

void GuiScriptViewer::OnMouseMove(const GuiMsg& iMsg)
{
	GuiRect::OnMouseMove(iMsg);

	if(this->hovering)
	{
		vec2 tMpos=*(vec2*)iMsg.data;

		if(tMpos.x < this->paper->textOffsets.x)
		{

		}
		else
		{

		}
	}
}

void GuiScriptViewer::OnSize(const GuiMsg& iMsg)
{
	if(!this->paper->text->empty())
	{
		this->paper->lineCount=this->CountScriptLines()-1;

		float tFontHeight=iMsg.tab->renderer2D->GetFontHeight();

		this->contentHeight=this->paper->lineCount * tFontHeight;
	}

	GuiScrollRect::OnSize(iMsg);
}


int GuiScriptViewer::CountScriptLines()
{
	const wchar_t* t=this->paper->text->c_str();

	int tLinesCount=!(*t) ? 0 : 1;

	while(*t)
	{
		if(*t=='\n' || *t=='\r')
			tLinesCount++;

		t++;
	}

	return tLinesCount;
}

///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////GuiCompilerViewer///////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

GuiCompilerViewer::GuiCompilerViewer(){this->name=L"Compiler";}

const wchar_t* nthOccurrenceInLine(const wchar_t* iStr,char iChar,int iNth)
{
	const wchar_t* str=iStr;
	int occurr=0;

	char c=*str;

	while(c!='\0' || c!='\n')
	{
		if(c==iChar)
		{
			if(++occurr==iNth)
				return str;
		}

		c=*(++str);
	}

	return 0;
}


bool GuiCompilerViewer::ParseCompilerOutputFile(String iFileBuffer)
{
	bool bReturnValue=true;

	this->vScrollbar.SetParent(0);

	this->DestroyChilds();

	GuiRect* messagesGlue=this->Create<GuiRect>();

	const int MESSAHE_ROW_HEIGHT=20;

	const wchar_t* fileBuffer=iFileBuffer.c_str();

	if(fileBuffer)
	{
		const wchar_t* LineBegin=fileBuffer;
		const wchar_t* FileEnd=LineBegin;
		while(*FileEnd++);

		while(LineBegin!=FileEnd-1)
		{
			const wchar_t* LineEnd=wcschr(LineBegin,'\n');

			const wchar_t* compileError=wcsstr(LineBegin,L"error C");
			const wchar_t* linkError=wcsstr(LineBegin,L"error LNK");

			compileError!=0 && LineEnd < compileError ? compileError=0 : 0;
			linkError!=0 && LineEnd < linkError ? linkError=0 : 0;

			bool simpleMessage=!compileError && !linkError;

			GuiString* tCompilerMessageRow=new GuiString;

			{
				/*tCompilerMessageRow->fixed.w=MESSAHE_ROW_HEIGHT;
				tCompilerMessageRow->alignRect.y=-1;
				tCompilerMessageRow->alignText.make(-1,0.5f);*/
			}

			if(simpleMessage)
			{
				tCompilerMessageRow->text=String(LineBegin,LineEnd-LineBegin);
			}
			else
			{
				bReturnValue=false;

				const wchar_t* FileEnd=nthOccurrenceInLine(LineBegin,':', compileError ? 2 : 1);//the first : should be the volume drive

				if(FileEnd)
					FileEnd+=2;

				const wchar_t* ErrorEnd=nthOccurrenceInLine(FileEnd,':',1);

				if(ErrorEnd)
					ErrorEnd+=2;

				tCompilerMessageRow->text=String(FileEnd,ErrorEnd-FileEnd)+String(ErrorEnd,LineEnd-ErrorEnd);
				tCompilerMessageRow->colorBackground=0xff0000;
			}

			tCompilerMessageRow->SetEdges(0,&messagesGlue->edges.w);

			tCompilerMessageRow->SetParent(this);

			LineBegin=++LineEnd;
		}

		this->vScrollbar.SetParent(this);

		this->contentHeight=messagesGlue->childs.size()*MESSAHE_ROW_HEIGHT;
	}

	return bReturnValue;
}


void GuiCompilerViewer::OnSize(const GuiMsg& iMsg)
{
	this->vScrollbar.SetScrollerRatio(this->contentHeight,this->rect.w);

	if(this->childs.size()==2)
		//we don't need the GuiScrollRect::width cause the newly GuiRect::offset
		this->vScrollbar.IsVisible() ? this->childs[0]->offsets.z=-GuiScrollBar::SCROLLBAR_TICK : this->childs[0]->offsets.z=0;

	GuiRect::OnSize(iMsg);

	this->rect.z=this->rect.z;
}


///////////////////////////////////////////////
///////////////////////////////////////////////
/////////////////Properties////////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////



void EditorEntity::OnPropertiesCreate()
{
	//fill entityViewer properties

	std::vector<GuiRect*> tRootLevel(2);

	this->container=this->entityViewerRootPropertyRect.Container(L"Entity");

	tRootLevel[0]=this->container;
	tRootLevel[0]->Property(L"Name",&this->name,GuiPropertyString::STRING);
	tRootLevel[0]->Property(L"Ptr",this,GuiPropertyString::PTR);
	tRootLevel[0]->Property(L"Position",&this->world,GuiPropertyString::MAT4POS);
	tRootLevel[1]=tRootLevel[0]->Container(L"AABB");
	tRootLevel[1]->Property(L"Min",this->bbox.a,GuiPropertyString::VEC3);
	tRootLevel[1]->Property(L"Max",this->bbox.b,GuiPropertyString::VEC3);
	tRootLevel[1]->Property(L"Volume",this->bbox.a,GuiPropertyString::VEC3,this->bbox.b);
	tRootLevel[0]->Property(L"ChildNum",&this->childs,GuiPropertyString::ENTITYVECSIZE);
}

void EditorEntity::OnPropertiesUpdate(Tab* tab)
{
	for(std::vector<EntityComponent*>::iterator it=this->components.begin();it!=this->components.end();it++)
	{
		IdeViewerProperties* componentProperties=dynamic_cast<IdeViewerProperties*>(*it);
		if(componentProperties)
			componentProperties->OnPropertiesUpdate(tab);
	}
}

void EditorMesh::OnPropertiesCreate()
{
	EditorEntity* tEditorEntity=(EditorEntity*)this->entity;

	this->container=tEditorEntity->entityViewerRootPropertyRect.Container(L"Mesh");

	this->container->Property(L"Controlpoints",&this->ncontrolpoints,GuiPropertyString::INT);
	this->container->Property(L"Normals",&this->nnormals,GuiPropertyString::INT);
	this->container->Property(L"Polygons",&this->npolygons,GuiPropertyString::INT);
	this->container->Property(L"Texcoord",&this->ntexcoord,GuiPropertyString::INT);
	this->container->Property(L"Vertexindices",&this->nvertexindices,GuiPropertyString::INT);
}

void EditorMesh::OnPropertiesUpdate(Tab* tab)
{
}

void EditorSkin::OnPropertiesCreate()
{
	EditorEntity* tEditorEntity=(EditorEntity*)this->entity;

	this->container=tEditorEntity->entityViewerRootPropertyRect.Container(L"Skin");

	this->container->Property(L"Clusters",&this->nclusters,GuiPropertyString::INT);
	this->container->Property(L"Textures",&this->ntextures,GuiPropertyString::INT);
}
void EditorSkin::OnPropertiesUpdate(Tab* tab)
{
}
void EditorRoot::OnPropertiesCreate()
{
	EditorEntity* tEditorEntity=(EditorEntity*)this->entity;

	this->container=tEditorEntity->entityViewerRootPropertyRect.Container(L"Root");
}
void EditorRoot::OnPropertiesUpdate(Tab* tab)
{
}
void EditorSkeleton::OnPropertiesCreate()
{
	EditorEntity* tEditorEntity=(EditorEntity*)this->entity;

	this->container=tEditorEntity->entityViewerRootPropertyRect.Container(L"Skeleton");
}
void EditorSkeleton::OnPropertiesUpdate(Tab* tab)
{
}
void EditorGizmo::OnPropertiesCreate()
{
	EditorEntity* tEditorEntity=(EditorEntity*)this->entity;

	this->container=tEditorEntity->entityViewerRootPropertyRect.Container(L"Gizmo");
}
void EditorGizmo::OnPropertiesUpdate(Tab* tab)
{
}
void EditorAnimation::OnPropertiesCreate()
{
	EditorEntity* tEditorEntity=(EditorEntity*)this->entity;

	this->container=tEditorEntity->entityViewerRootPropertyRect.Container(L"Animation");

	this->container->Property(L"IsBone",this,GuiPropertyString::ISBONECOMPONENT);
	this->container->Property(L"Duration",&this->start,GuiPropertyString::FLOAT2MINUSFLOAT1,&this->end);
	this->container->Property(L"Begin",&this->start,GuiPropertyString::FLOAT);
	this->container->Property(L"End",&this->end,GuiPropertyString::FLOAT);
}
void EditorAnimation::OnPropertiesUpdate(Tab* tab)
{
}
void EditorAnimationController::OnPropertiesCreate()
{
	EditorEntity* tEditorEntity=(EditorEntity*)this->entity;

	this->container=tEditorEntity->entityViewerRootPropertyRect.Container(L"AnimationController");

	this->container->name=L"EditorAnimationControllerProperties";
	this->container->text=L"AnimationController";
	this->container->Property(L"Number of nodes",&this->animations,GuiPropertyString::ANIMATIONVECSIZE);
	this->container->SliderProperty(L"Velocity",this->speed,this->start,this->end);
	this->container->Property(L"Duration",&this->start,GuiPropertyString::FLOAT2MINUSFLOAT1,&this->end);
	this->container->Property(L"Begin",&this->start,GuiPropertyString::FLOAT);
	this->container->Property(L"End",&this->end,GuiPropertyString::FLOAT);
	guiPropertyAnimationController=this->container->AnimationControllerProperty(*this);
}

void EditorAnimationController::OnPropertiesUpdate(Tab* tab)
{
	if(this->oldCursor!=this->cursor)
		tab->SetDraw(2,0,&guiPropertyAnimationController->guiAnimationController.slider);

	this->oldCursor=this->cursor;
}



void EditorBone::OnPropertiesCreate()
{
	EditorEntity* tEditorEntity=(EditorEntity*)this->entity;

	this->container=tEditorEntity->entityViewerRootPropertyRect.Container(L"Bone");
}
void EditorBone::OnPropertiesUpdate(Tab* tab)
{
}
void EditorLight::OnPropertiesCreate()
{
	EditorEntity* tEditorEntity=(EditorEntity*)this->entity;

	this->container=tEditorEntity->entityViewerRootPropertyRect.Container(L"Light");
}
void EditorLight::OnPropertiesUpdate(Tab* tab)
{
}

void editScriptEditorCallback(void* iData)
{
	EditorScript* editorScript=(EditorScript*)iData;

	Tab* tabContainer=Ide::instance->mainAppWindow->containers[0]->tabContainers[0];

	if(!tabContainer)
		DEBUG_BREAK();

	if(GuiScriptViewer::GetPool().empty())
		tabContainer->rects.ScriptViewer();

	GuiScriptViewer* guiScriptViewer=GuiScriptViewer::GetPool().front();

	if(guiScriptViewer)
	{
		guiScriptViewer->Open(editorScript);
		tabContainer->SetDraw(0,1);
	}
}

void compileScriptEditorCallback(void* iData)
{
	EditorScript* editorScript=(EditorScript*)iData;

    Ide::instance->compiler->Compile(editorScript);
}

void launchStopScriptEditorCallback(void* iData)
{
	EditorScript* editorScript=(EditorScript*)iData;

	if(editorScript->runtime)
	{
		if(Ide::instance->compiler->UnloadScript(editorScript))
			editorScript->buttonLaunch->text=L"Launch";
	}
	else
	{
		if(Ide::instance->compiler->LoadScript(editorScript))
			editorScript->buttonLaunch->text=L"Stop";
	}

	editorScript->container->GetRootRect()->tabContainer->SetDraw(2,0,editorScript->buttonLaunch);
}

EditorScript::EditorScript():scriptViewer(0)
{

};

void EditorScript::OnPropertiesCreate()
{
	EditorEntity* tEditorEntity=(EditorEntity*)this->entity;

	this->container=tEditorEntity->entityViewerRootPropertyRect.Container(L"Script");

	GuiProperty* tFile=container->Property(L"File",&this->Script::file,GuiPropertyString::STRING);
	GuiProperty* tRunning=container->Property(L"Running",&this->Script::runtime,GuiPropertyString::BOOLPTR);

	GuiButtonFunc* buttonEdit=new GuiButtonFunc;
	buttonEdit->name=L"EditorScript Edit Button";
	buttonEdit->func=editScriptEditorCallback;
	buttonEdit->param=this;
	buttonEdit->colorHovering=Renderer2D::COLOR_GUI_BACKGROUND+30;
	buttonEdit->colorPressing=Renderer2D::COLOR_GUI_BACKGROUND+90;
	buttonEdit->text=L"Edit";
	buttonEdit->fixed.make(0,0,0,20);
	container->AppendAsProperty(buttonEdit);

	GuiButtonFunc* buttonCompile=new GuiButtonFunc;
	buttonCompile->func=compileScriptEditorCallback;
	buttonCompile->param=this;
	buttonCompile->colorHovering=Renderer2D::COLOR_GUI_BACKGROUND+30;
	buttonCompile->colorPressing=Renderer2D::COLOR_GUI_BACKGROUND+90;
	buttonCompile->text=L"Compile";
	buttonCompile->fixed.make(0,0,0,20);
	container->AppendAsProperty(buttonCompile);

	this->buttonLaunch=new GuiButtonFunc;
	this->buttonLaunch->func=launchStopScriptEditorCallback;
	this->buttonLaunch->param=this;
	this->buttonLaunch->colorHovering=Renderer2D::COLOR_GUI_BACKGROUND+30;
	this->buttonLaunch->colorPressing=Renderer2D::COLOR_GUI_BACKGROUND+90;
	this->buttonLaunch->text=L"Launch";
	this->buttonLaunch->fixed.make(0,0,0,20);
	container->AppendAsProperty(this->buttonLaunch);
}
void EditorScript::OnPropertiesUpdate(Tab* tab)
{
}

void EditorScript::OnResourcesCreate()
{
	String tFileNamePath=Ide::instance->folderProject + L"\\" + this->entity->name;
	this->file=tFileNamePath + L".cpp";

	if(!File::Exist(this->file))
	{
		if(!File::Create(this->file))
			DEBUG_BREAK();

		StringUtils::WriteCharFile(
									this->file,
									L"#include \"entities.h\"\n\nstruct " + this->entity->name + L"_ : EntityScript\n{\n\t int counter;\n\tvoid init()\n\t{\n\t\tcounter=0;\n\tthis->entity->local.identity();\n\t\tprintf(\"inited\\n\");\n\t}\n\n\tvoid update()\n\t{\n\t\tthis->entity->local.translate(0.1f,0,0);\n\t//printf(\"counter: %d\\n\",counter);\n\tcounter++;\n\t}\n\n\tvoid deinit()\n\t{\n\t\tprintf(\"deinited\\n\");\n\t}\n\n};\n",
									L"wb"
								   );
	}
}

void EditorCamera::OnPropertiesCreate()
{
	EditorEntity* tEditorEntity=(EditorEntity*)this->entity;

	this->container=tEditorEntity->entityViewerRootPropertyRect.Container(L"Camera");
}
void EditorCamera::OnPropertiesUpdate(Tab* tab)
{
}




///////////////////////////////////////////////
///////////////////////////////////////////////
/////////////////FileSystem////////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////

bool FileExists(const char* iFile)
{
	FILE* tFile=fopen(iFile,"rb");

	if(tFile)
	{
		return true;
		fclose(tFile);
	}

	return false;
}
